Port scans are often used to profile systems before they are attacked
Knowing what ports are open allows an attacker to determine which services can be attacked
Many IDSs offer methods to detect port scans, but by then the information has already been leaked
Is it possible to prevent port scans before they actually happen
Hacking, really, is about coming up with new ideas, so a newly developed method for proactive port-scanning defense will be presented here

First of all, the FIN, NULL, and X-mas scans can be prevented by a simple kernel modification
If the kernel never sends the reset packets, these scans will turn up nothing
The following output uses grep to find the kernle code responsible for sending reset packets
__________________________________________________________________________________
reader@hacking:~/booksrc $ grep -n -A 20 "void.*send_reset" /usr/src/linux/net/ipv4/tcp_ipv4.c
547:static void tcp_v4_send_reset(struct sock *sk, struct sk_buff *skb)
548-{
549-    struct tcphdr *th = skb->h.th;
550-    struct {
551-            struct tcphdr th;
552-#ifdef CONFIG_TCP_MD5SIG
553-            __be32 opt[(TCPOLEN_MD5SIG_ALIGNED >> 2)];
554-#endif
555-    } rep;
556-    struct ip_reply_arg arg;
557-#ifdef CONFIG_TCP_MD5SIG
558-    struct tcp_md5sig_key *key;
559-#endif
560-

      return; // Modification: Never send RST, always return.

561-     /* Never send a reset in response to a reset. */
562-     if (th->rst)
563-             return;
564-
565-     if (((struct rtable *)skb->dst)->rt_type != RTN_LOCAL)
566-             return;
567-
__________________________________________________________________________________

By adding the return command (shown above without line numbers), the tcp_v4_send_reset() kernel function will simply return instead of doing anything
After the kernel is recompiled, the resulting kernel won't send out reset packets, avoiding information leakage


FIN Scan Before the Kernel Modification
__________________________________________________________________________________
matrix@euclid:~ $ sudo nmap -T5 -sF 192.168.42.72
Starting Nmap 4.11 ( http://www.insecure.org/nmap/ ) at 2007-03-17 16:58 PDT
Interesting ports on 192.168.42.72:
Not shown: 1678 closed ports
PORT   STATE         SERVICE
22/tcp open|filtered ssh
80/tcp open|filtered http
MAC Address: 00:01:6C:EB:1D:50 (Foxconn)
Nmap finished: 1 IP address (1 host up) scanned in 1.462 seconds
__________________________________________________________________________________


FIN Scan After the Kernel Modification
__________________________________________________________________________________
matrix@euclid:~ $ sudo nmap -T5 -sF 192.168.42.72
Starting Nmap 4.11 ( http://www.insecure.org/nmap/ ) at 2007-03-17 16:58 PDT
Interesting ports on 192.168.42.72:
Not shown: 1678 closed ports
PORT    STATE        SERVICE
MAC Address: 00:01:6C:EB:1D:50 (Foxconn)
Nmap finished: 1 IP address (1 host up) scanned in 1.462 seconds
__________________________________________________________________________________

This works fine for scans that rely on RST packets, but preventing information leakage with SYN scans and full-connect scans is a bit more difficult
In order to maintain functionality, oepn ports have to respond with SYN/ACK packets-- there is no way around that
But if all the closed ports also responded with SYN/ACK packets, the amount of useful information an attacker could retrieve from port scans would be minimized
Simply opening every port would cause a major performance hit, though, which isn't desirable
Ideally, this should all be done without using a TCP stack
The following program does exactly that
It's a modification of the rst_hijack.c program, using a more complex BPF string to filter only SYN packets destined for closed ports
The callback function spoofs a legitimate looking SYN/ACK response to any SYN packet that makes it through the BPF
This will flood port scanners with a sea of false positives, which will hide legitimate ports

shroud.c
__________________________________________________________________________________
#include <libnet.h>
#include <pcap.h>
#include "hacking.h"

#define MAX_EXISTING_PORTS 30

void caught_packet(u_char *, const struct pcap_pkthdr *, const u_char *);
int set_packet_filter(pcap_t *, struct in_addr *, u_short *);

struct data_pass {
   int libnet_handle;
   u_char *packet;
};

int main(int argc, char *argv[]) {
   struct pcap_pkthdr cap_header;
   const u_char *packet, *pkt_data;
   pcap_t *pcap_handle;
   char errbuf[PCAP_ERRBUF_SIZE]; // Same size a LIBNET_ERRBUF_SIZE
   char *device;
   u_long target_ip;
   int network, i;
   struct data_pass critical_libnet_data;
   u_short existing_ports[MAX_EXISTING_PORTS];

   if((argc < 2) || (argc > MAX_EXISTING_PORTS+2)) {
      if(argc > 2)
         printf("Limited to tracking %d existing ports.\n", MAX_EXISTING_PORTS);
      else
         printf("Usage: %s <IP to shroud> [existing ports...]\n", argv[0]);
      exit(0);
   }

   target_ip = libnet_name_resolve(argv[1], LIBNET_RESOLVE);
   if (target_ip == -1)
      fatal("Invalid target address");

   for(i=2; i < argc; i++)
      existing_ports[i-2] = (u_short) atoi(argv[i]);

   existing_ports[argc-2] = 0;

   device = pcap_lookupdev(errbuf);
   if(device == NULL)
      fatal(errbuf);

   pcap_handle = pcap_open_live(device, 128, 1, 0, errbuf);
   if(pcap_handle == NULL)
      fatal(errbuf);

   critical_libnet_data.libnet_handle = libnet_open_raw_sock(IPPROTO_RAW);
   if(critical_libnet_data.libnet_handle == -1)
      libnet_error(LIBNET_ERR_FATAL, "can't open network interface.  -- this program must run as root.\n");

   libnet_init_packet(LIBNET_IP_H + LIBNET_TCP_H, &(critical_libnet_data.packet));
   if (critical_libnet_data.packet == NULL)
      libnet_error(LIBNET_ERR_FATAL, "can't initialize packet memory.\n");

   libnet_seed_prand();

   set_packet_filter(pcap_handle, (struct in_addr *)&target_ip, existing_ports);

   pcap_loop(pcap_handle, -1, caught_packet, (u_char *)&critical_libnet_data);
   pcap_close(pcap_handle);
}

/* Sets a packet filter to look for established TCP connections to target_ip */
int set_packet_filter(pcap_t *pcap_hdl, struct in_addr *target_ip, u_short *ports) {
   struct bpf_program filter;
   char *str_ptr, filter_string[90 + (25 * MAX_EXISTING_PORTS)];
   int i=0;

   sprintf(filter_string, "dst host %s and ", inet_ntoa(*target_ip)); // Target IP
   strcat(filter_string, "tcp[tcpflags] & tcp-syn != 0 and tcp[tcpflags] & tcp-ack = 0");

   if(ports[0] != 0) { // If there is at least one existing port
      str_ptr = filter_string + strlen(filter_string);
      if(ports[1] == 0) // There is only one existing port
         sprintf(str_ptr, " and not dst port %hu", ports[i]);
      else { // Two or more existing ports
         sprintf(str_ptr, " and not (dst port %hu", ports[i++]);
         while(ports[i] != 0) {
            str_ptr = filter_string + strlen(filter_string);
            sprintf(str_ptr, " or dst port %hu", ports[i++]);
         }
         strcat(filter_string, ")");
      }
   }
   printf("DEBUG: filter string is \'%s\'\n", filter_string);
   if(pcap_compile(pcap_hdl, &filetr, filter_string, 0, 0) == -1)
      fatal("pcap_compile failed");

   if(pcap_setfilter(pcap_hdl, &filter) == -1)
      fatal("pcap_setfilter failed");
}

void caught_packet(u_char *user_args, const struct pcap_pkthdr *cap_header, const u_char *packet) {
   u_char *pkt_data;
   struct libnet_ip_hdr *IPhdr;
   struct libnet_tcp_hdr *TCPhdr;
   struct data_pass *passed;
   int bcount;

   passed = (struct data_pass *) user_args; // Pass data using a pointer to a struct

   IPhdr = (struct libnet_ip_hdr *) (packet + LIBNET_ETH_H);
   TCPhdr = (struct libnet_tcp_hdr *) (packet + LIBNET_ETH_H + LIBNET_TCP_H);

   libnet_build_ip(LIBNET_TCP_H,      // size of the packet sans IP header 
      IPTOS_LOWDELAY,                 // IP tos 
      libnet_get_prand(LIBNET_PRu16), // IP ID (randomized) 
      0,                              // frag stuff 
      libnet_get_prand(LIBNET_PR8),   // TTL (randomized) 
      IPPROTO_TCP,                    // transport protocol 
      *((u_long *)&(IPhdr->ip_dst)),  // source IP (pretend we are dst) 
      *((u_long *)&(IPhdr->ip_src)),  // destination IP (send back to src) 
      NULL,                           // payload (none) 
      0,                              // payload length 
      passed->packet);                // packet header memory 

   libnet_build_tcp(htons(TCPhdr->th_dport),// source TCP port (pretend we are dst) 
      htons(TCPhdr->th_sport),        // destination TCP port (send back to src) 
      htonl(TCPhdr->th_ack),          // sequence number (use previous ack) 
      htonl((TCPhdr->th_seq) + 1),    // acknowledgement number (SYN's seq # + 1) 
      TH_SYN | TH_ACK,                // control flags (RST flag set only) 
      libnet_get_prand(LIBNET_PRu16), // window size (randomized) 
      0,                              // urgent pointer 
      NULL,                           // payload (none) 
      0,                              // payload length 
      (passed->packet) + LIBNET_IP_H);// packet header memory 

   if (libnet_do_checksum(passed->packet, IPPROTO_TCP, LIBNET_TCP_H) == -1)
      libnet_error(LIBNET_ERR_FATAL, "can't compute checksum\n");

   bcount = libnet_write_ip(passed->libnet_handle, passed->packet, LIBNET_IP_H+LIBNET_TCP_H);
   if(bcount < LIBNET_IP_H + LIBNET_TCP_H)
      libnet_error(LIBNET_ERR_WARNING, "Warning: Incomplete packet written.");
   printf("bing!\n");
}
__________________________________________________________________________________

There are a few tricky parts in the code above, but we should be able to follow all of it
When the program is compiled and executed, it will shroud the IP address given as the first argument, with the exception of a list of existing ports provided as the remaining arguments

__________________________________________________________________________________
reader@hacking:~/booksrc $ gcc $(libnet-config --defines) -o shroud shroud.c -lnet -lpcap
reader@hacking:~/booksrc $ sudo ./shroud 192.168.42.72 22 80
DEBUG: filter string is 'dst host 192.168.42.72 and tcp[tcpflags] & tcp-syn != 0 and
tcp[tcpflags] & tcp-ack = 0 and not (dst port 22 or dst port 80)'
__________________________________________________________________________________

While shroud is running, any port scanning attempts will show every port to be open

__________________________________________________________________________________
matrix@euclid:~ $ sudo nmap -sS 192.168.0.189

Starting nmap V. 3.00 ( www.insecure.org/nmap/ )
Interesting ports on (192.168.0.189):
Port       State      Service 
1/tcp      open       tcpmux 
2/tcp      open       compressnet 
3/tcp      open       compressnet 
4/tcp      open       unknown 
5/tcp      open       rje 
6/tcp      open       unknown 
7/tcp      open       echo 
8/tcp      open       unknown 
9/tcp      open       discard 
10/tcp     open       unknown 
11/tcp     open       systat 
12/tcp     open       unknown 
13/tcp     open       daytime 
14/tcp     open       unknown 
15/tcp     open       netstat 
16/tcp     open       unknown 
17/tcp     open       qotd 
18/tcp     open       msp 
19/tcp     open       chargen 
20/tcp     open       ftp-data 
21/tcp     open       ftp 
22/tcp     open       ssh 
23/tcp     open       telnet 
24/tcp     open       priv-mail 
25/tcp     open       smtp 

[ output trimmed ]

32780/tcp  open       sometimes-rpc23 
32786/tcp  open       sometimes-rpc25 
32787/tcp  open       sometimes-rpc27 
43188/tcp  open       reachout 
44442/tcp  open       coldfusion-auth 
44443/tcp  open       coldfusion-auth 
47557/tcp  open       dbbrowse 
49400/tcp  open       compaqdiag 
54320/tcp  open       bo2k 
61439/tcp  open       netprowler-manager 
61440/tcp  open       netprowler-manager2 
61441/tcp  open       netprowler-sensor 
65301/tcp  open       pcanywhere 

Nmap run completed -- 1 IP address (1 host up) scanned in 37 seconds
__________________________________________________________________________________


The only service that is actually running is ssh on port 22, but it is hidden in a sea of false positives
A dedicated attacker could simply telnet to every port to check the banners, but this technique could easily be expanded to spoof banners also