The best way to show how these functions are used is by example
The following server code listens for TCP connections on port 7890
When a client connects, it sends the message Hello, workd! and then receives data until the connection is closed
This is done using socket functions and structures from the include files mentioned earlier, so these files are included at the beginning of the program
A useful memory dump function has been added to hacking.h, which is shown below:

Added to hacking.h
_________________________________________________________________________________
// dumps raw memory in hex byte and printable split format
void dump(const unsigned char *data_buffer, const unsigned int length) {
    unsigned char byte;
    unsigned int i, j;
    for(i=0; i < length; i++) {
        byte = data_buffer[i];
        printf("%02x ", data_buffer[i]);  // display byte in hex
        if(((i%16)==15) || (i==length-1)) {
            for(j=0; j < 15-(i%16); j++)
                printf("   ");
            printf("| ");
            for(j=(i-(i%16)); j <= i; j++) {  // display printable bytes from line
                byte = data_buffer[j];
                if((byte > 31) && (byte < 127)) // outside printable char range
                    printf("%c", byte);
                else
                    printf(".");
            }
            printf("\n"); // end of the dump line (each line 16 bytes)
        } // end if
    } // end for
}
_________________________________________________________________________________
This function is used to display packet data by the server program
However, since it is also useful in other places, it has been put into hacking.h, instead
The rest of the server program will be explained as we read the source code


simple_server.c
_________________________________________________________________________________
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include "hacking.h"

#define PORT 7890 // The port users will be connecting to

int main(void) {
    int sockfd, new_sockfd; // Listen on sock_fd, new connection on new_fd
    struct sockaddr_in host_addr, client_addr; // My address information
    socklen_t sin_size;
    itn recv_length=1, yes=1;
    char buffer[1024];

    if((sockfd = socket(PF_INET, SOCK_STREAM, 0)) == -1)
        fatal("in socket");

    if(setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int))  == -1)
        fatal("setting socket option SO_REUSEADDR");
_________________________________________________________________________________

So far, the program sets up a socket using the socket() function
We want a TCP/IP socket, so the protocol family is PF_INET for IPv4 and the socket type is SOCK_STREAM
The final protocol argument is 0, since there is only one protocol in the PF_INET protocol family
This function returns a socket file descriptor which is stored in sockfd

The setsockopt() function is simply used to set socket options
This function call sets the SO_REUSEADDR socket option to true, which will allow it to reuse a given address for binding
Without this option set, when the program tries to bind to a given port, it may fail if that port is already in use
If a socket isn't closed properly, it may appear to be in use, so this option lets a socket bind to a port (and take control of it), even if it seems to be in use

The first argument to this function is the socekt (referenced by a file descriptor), the second specifies the level of the option, and the third specifies the option itself
Since SO_REUSEADDR is a socket-level option, the level is set to SOL_SOCKET
There are mnay different socket options defined in /usr/include/asm/socket.h
The final 2 arguments are a pointer to the data that the option should be set to and the length of that data
A pointer to data and the length of that data are 2 arguments that are often used with socket functions
This allows the function to handle all sorts of data, from single bytes to large data structures
The SO_REUSEADDR option uses a 32-bit integer for its value, so to set this option to true, the final 2 arguments must be a pointer to the integer value of 1 and the size of an integer (which is 4 bytes)
_________________________________________________________________________________
    host_addr.sin_family = AF_INET; // Host byte order
    host_addr.sin_port = htons(PORT); // Short, network byte order
    host_addr.sin_addr.s_addr = 0; // Automatically fill with my IP
    memset(&(host_addr.sin_zero), '\0'. 8); // Zero the rest of the struct

    if (bind(sockfd, (struct sockaddr *)&host_addr, sizeof(struct sockaddr)) == -1)
        fatal("binding to socket")

    if(listen(sockfd, 5) == -1)
        fatal("listening on socket");
_________________________________________________________________________________
These next few lines set up the host_addr structure for use in the bind call
The address family is AF_INET, since we are using IPv4 and the sockaddr_in structure
The port is set to PORT, which is defined as 7890
This short integer value must be converted into network byte order, so the htons() function is used
The address is set to 0, which means it will automatically be filled with the host's current IP address
Since the value 0 is the same regardless if byte order, no  conversion is necessary

The bind() call passes the socket file descriptor, the address structure, and the length of the address structure
This call will bind the socket to the current IP address on port 7890

The listen() call tells the socket to listen for incoming connections, and a subsequent accept() call actually accepts and incoming connection
The listen() function plcaes all incoming connections into a backlog queue until an accept() call accepts the connections
The last argument to the listen() call sets the maximum size for the backlog queue
_________________________________________________________________________________
    while(1) { // Accept loop
        sin_size - sizeof(struct sockaddr_in);
        new_sockfd  = accept(sockfd, (struct sockaddr *)&client_addr, &sin_size);
        if(new_sockfd == -1)
            fatal("accepting connection");
        printf("server: got connection form %s port %d\n", inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));
        send(new_sockfd, "Hello, world!\n", 13, 0);
        recv_length = recv(new_sockfd, &buffer, 1024, 0);
        while(recv_length > 0) {
            printf("RECV: %d bytes\n", recv_length);
            dump(buffer, recv_length);
            recv_length = recv(new_sockfd, &buffer, 1024, 0);
        }
        close(new_sockfd);
    }
    return 0;
}
_________________________________________________________________________________
Next is a loop that accepts incoming connections
The accpet() funciton's first 2 arguments should make sense immediately; the final argument is a pointer to the size of the address structure
This is beacuse the accept() function will write the connecting client's address information into the address structure and the size of that structure into sin_size
For our puproses, the size never changes, but to use the funciton we must obey the calling convention
This way, the original socket file descriptor can continue to be used for accepting new connections, while the new socket file descriptor is used for communicating with the connected client

After getting a connection, the program prints out a connection message, using inet_ntoa() to convert the sin_addr address structure to a dotted-number IP strign and ntohs() to convert the byte order of the sin_port number

The send() function sends the 13 bytes of the string Hello, world!\n to the new socket that describes the new connection
The final arguments for the send() and recv() functions are flags, that for our purposes, will be always be 0

Next is a loop that receives data form the connection and prints it out
The recv() function is given a pointer to a buffer and a maximum length to read from the socket
The function writes the data into the buffer passed to it and returns the number of bytes it actually wrote
The loop will continue as long as the recv() call continues to receive data

When compiled and run, the program binds to port 7890 of the host and waits for incoming connections:
_________________________________________________________________________________
reader@hacking:~/booksrc $ gcc simple_server.c
reader@hacking:~/booksrc $ ./a.out
_________________________________________________________________________________

A telnet client basically works like a generic TCP connection client, so it can be used to connect to the simple server by specifying the target IP address and port

FROM A Remote Machine
_________________________________________________________________________________
matrix@euclid:~ $ telnet 192.168.42.248 7890
Trying 192.168.42.248...
Connected to 192.168.42.248.
Escape character is '^]'.
Hello, world!
this is a test
fjsghau;ehg;ihskjfhasdkfjhaskjvhfdkjhvbkjgf
_________________________________________________________________________________

Upon connection, the server sends the string Hello, world! and the rest is the local character echo of typing this is a test and a line of keyboard mashing
Since telnet is line-buffered, each of these 2 lines is sent back to the server when ENTER is pressed
Back on the server side, the output shows the connection and the packets of data that are sent back

ON A Local Machine
_________________________________________________________________________________
reader@hacking:~/booksrc $ ./a.out
server: got connection from 192.168.42.1 port 56971
RECV: 16 bytes
74 68 69 73 20 69 73 20 61 20 74 65 73 74 0d 0a | This is a test...
RECV: 45 bytes
66 6a 73 67 68 61 75 3b 65 68 67 3b 69 68 73 6b | fjsghau;ehg;ihsk
6a 66 68 61 73 64 6b 66 6a 68 61 73 6b 6a 76 68 | jfhasdkfjhaskjvh
66 64 6b 6a 68 76 62 6b 6a 67 66 0d 0a          | fdkjhvbkjgf...
_________________________________________________________________________________