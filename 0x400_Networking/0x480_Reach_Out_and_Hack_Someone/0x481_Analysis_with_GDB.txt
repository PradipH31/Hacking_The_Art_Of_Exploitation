To exploit the vulnerability in the tinyweb.c program, we just need to send packets that will strategically overwrite the return address
First, we need to know the offset form the start of a buffer we control to the stored return address
Using GDB, we can analyze the compiled program to find this; however, there are some subtle details that can cause tricky problems
For example, the program requires root privileges, so the debugger must be run as root
But using sudo or running with root's environment will change the stack, meaning the addresses seen in the debugger'r run of the binary won't match the address when it's running normally
There are other slight differences that can shift memory around in the debugger like this, creating inconsistencies that can be maddening to track down
According to the debugger, everything will look like it should work; however, the exploit fails when run outside the debugger, since the addresses are different

One elegant solution to this problem is to attach to the process after it's already running
In the output below, GDB is used to attach to an already-running tinyweb process that was started in another terminal
The source is recompiled using the -g option to include debugging symbols that GDB can apply to the running process
__________________________________________________________________________________
reader@hacking:~/booksrc $ ps aux | grep tinyweb
root     13019  0.0  0.0   1504   344 pts/0    S+   20:25   0:00 ./tinyweb
reader   13104  0.0  0.0   2880   748 pts/2    R+   20:27   0:00 grep tinyweb

reader@hacking:~/booksrc $ gcc -g tinyweb.c

reader@hacking:~/booksrc $ sudo gdb -q --pid=13019 --symbols=./a.out
Using host libthread_db library "/lib/tls/i686/cmov/libthread_db.so.1".
Attaching to process 13019
/cow/home/reader/booksrc/tinyweb: No such file or directory.
A program is being debugged already. Kill it? (y or n) n
Program not killed.
(gdb) bt
#0  0xb7fe77f2 in ?? ()
#1  0xb7f691e1 in ?? ()
#2  0x08048ccf in main () at tinyweb.c:44
(gdb) list 44
39         if (listen(sockfd, 20) == -1) 
40            fatal("listening on socket"); 
41         
42         while(1) {  // Accept loop 
43            sin_size = sizeof(struct sockaddr_in); 
44            new_sockfd = accept(sockfd, (struct sockaddr *)&client_addr, &sin_size); 
45            if(new_sockfd == -1) 
46               fatal("accepting connection"); 
47         
48            handle_connection(new_sockfd, &client_addr); 
(gdb) list handle_connection
53      /* This function handles the connection on the passed socket from the 
54      * passed client address. The connection is processed as a web request 
55      * and this function replies over the connected socket. Finally, the 
56      * passed socket is closed at the end of the function. 
57      */ 
58      void handle_connection(int sockfd, struct sockaddr_in *client_addr_ptr) { 
59         unsigned char *ptr, request[500], resource[500]; 
60         int fd, length; 
61        
62         length = (1)recv_line(sockfd, request); 
(gdb) break 62
Breakpoint 1 at 0x8048d02: file tinyweb.c, line 62.
(gdb) cont
Continuing.
__________________________________________________________________________________

After attaching to a running process, a stack backtrace shows the program is currently in main(), waiting for a connection
After setting a breakpoint at the first recv_line() call on line 62 (1), the program is allowed to continue
At this point, the program's execution must be advanced by making a web request using wget in another terminal or a browser
Then the breakpoint in handle_connection() will be hit

__________________________________________________________________________________
Breakpoint 2, handle_connection (sockfd=4, client_addr_ptr=0xbffff810) at tinyweb.c:62
62         length = (1)recv_line(sockfd, request);

(gdb) x/x request
0xbffff5c0:     0x00000000

(gdb) bt
#0  handle_connection (sockfd=4, client_addr_ptr=0xbffff810) at tinyweb.c:62
#1  0x08048cf6 in main () at tinyweb.c:48

(gdb) x/16xw request+500
0xbffff7b4:     0xb7fd5ff4     0xb8000ce0     0x00000000     0xbffff848 
0xbffff7c4:     0xb7ff9300     0xb7fd5ff4     0xbffff7e0     0xb7f691c0 
0xbffff7d4:     0xb7fd5ff4     0xbffff848     0x08048cf6     0x00000004 
0xbffff7e4:     0xbffff810     0xbffff80c     0xbffff834     0x00000004 

(gdb) x/x 0xbffff7d4+8
(2)0xbffff7dc:    0x08048cf6

(gdb) p 0xbffff7dc - 0xbffff5c0
$1 = 540

(gdb) p /x 0xbffff5c0 + 200
$2 = 0xbffff688

(gdb) quit
The program is running. Quit anyway (and detach it)? (y or n) y
Detaching from program: , process 13019
__________________________________________________________________________________

At the breakpoint, the request buffer begins at 0xbffff5c0
The bt command's stack backtrace shows that the return address from handle_connection() is 0x08048cf6
Since we know how the local variables are generally laid out on the stack, we know the request buffer is near the end of the frame
This means that the stored return address should be on the stack somewhere near the end of this 500-byte buffer
Since we already know the general area to look, a quick inspection shows the stored return address is at 0xbffff7dc(2)
A little math shows the stored return address is 540 bytes from the start of the request buffer

We are talking about the changes in memory address that can occur in different conditions

However, there are a few bytes near the beginning of the buffer that might be mangled by the rest of the function
Remember, we don't gain control of the program until the function returns
To account for this, it's best to just avoid the beginning of the buffer
Skipping the first 200 bytes should be safe, while leaving plenty of space for shellcode in the remaining 300 bytes
This means 0xbffff688 is the target return addresses(desired return address)