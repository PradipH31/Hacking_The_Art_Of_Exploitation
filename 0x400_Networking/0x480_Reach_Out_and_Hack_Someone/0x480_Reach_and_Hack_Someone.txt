Network programming tends to move many chunks of memory around and is heavy in typecasting
We've seen for ourselves how crazy some of the typecasts can get
Mistakes thrive in this type of chaos
And since many network programs need to run as root, these little mistakes can become critical vulnerabilities
One such vulnerability exists in the code from this chapter

FROM hacking-network.h
__________________________________________________________________________________
/* This function accepts a socket FD and a ptr to a destination
 * buffer.  It will receive from the socket until the EOL byte
 * sequence in seen.  The EOL bytes are read from the socket, but
 * the destination buffer is terminated before these bytes.
 * Returns the size of the read line (without EOL bytes).
 */
int recv_line(int sockfd, unsigned char *dest_buffer) {
#define EOL "\r\n" // End-of-line byte sequence
#define EOL_SIZE 2
   unsigned char *ptr;
   int eol_matched = 0;

   ptr = dest_buffer;
   while(recv(sockfd, ptr, 1, 0) == 1) { // Read a single byte
      if(*ptr == EOL[eol_matched]) { // Does this byte match terminator?
         eol_matched++;
         if(eol_matched == EOL_SIZE) { // If all bytes match terminator,
            *(ptr+1-EOL_SIZE) = '\0'; // terminate the string
            return strlen(dest_buffer); // Return bytes received
         }
      } else {
         eol_matched = 0;
      }
      ptr++; // Increment the pointer to the next byte
   }
   return 0; // Didn't find the end-of-line characters
}
__________________________________________________________________________________

The recv_line() function in hacking-network.h has a small mistake of omission-- there is no code to limit the length
This means received bytes can overflow if they exceed the dest_buffer size
The tinyweb server program and any other programs that use this function are vulnerable to attack