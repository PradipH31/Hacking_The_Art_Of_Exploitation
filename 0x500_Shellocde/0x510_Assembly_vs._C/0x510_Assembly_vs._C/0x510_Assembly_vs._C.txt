The shellcode bytes are actually architecture-specific machine instructions, so shellcode is written using the assembly language
Writing a program in assembly is different than writing it in C, but many of the principles are similar
The operating system manages things like input, output, process control, file access, and network communication in the kernel
Compiled C programs ultimately perform these tasks by making system calls to the kernel
Different operating systems have different sets of system calls

In C, standard libraries are used for convenience and portability
A C program that uses printf() to output a string can be compiled for many different systems, since the library knows the appropriate system calls for various arhitechtures
A C program compiled on an x86 processor will produce x86 assembly language

By definition, assembly language is already specific to a certain processor architecture, so portability is impossible
There are no standard libraries; instead, kernel system calls have to be made directly
To begin our comparison, let's write a C program, then rewrite it in x86 assembly

helloworld.c
__________________________________________________________________________________
#include <stdio.h>
int main() {
   printf("Hello, world!\n");
   return 0;
}
__________________________________________________________________________________

When the compiled program is run, execution flows through the standard I/O library, eventually making a system call to write the string Hello, world! to the screen
The strace program is used to trace a program's system calls
Used on the compiled helloworld program, it shows every system call that program makes

__________________________________________________________________________________
reader@hacking:~/booksrc $ gcc helloworld.c

reader@hacking:~/booksrc $ strace ./a.out
execve("./a.out", ["./a.out"], [/* 27 vars */]) = 0
brk(0)                                  = 0x804a000
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7ef6000
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
open("/etc/ld.so.cache", O_RDONLY)      = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=61323, ...}) = 0
mmap2(NULL, 61323, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb7ee7000
close(3)                                = 0
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 3
read(3, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20Z\1\000"..., 512) = 512
fstat64(3, {st_mode=S_IFREG|0755, st_size=1248904, ...}) = 0
mmap2(NULL, 1258876, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0xb7db3000
mmap2(0xb7ee0000, 16384, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x12c) = 0xb7ee0000
mmap2(0xb7ee4000, 9596, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7ee4000
close(3)                                = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7db2000
set_thread_area({entry_number:-1 -> 6, base_addr:0xb7db26b0, limit:1048575, seg_32bit:1,
contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
mprotect(0xb7ee0000, 8192, PROT_READ)   = 0
munmap(0xb7ee7000, 61323)               = 0
fstat64(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 2), ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7ef5000
write(1, "Hello, world!\n", 13Hello, world!
)          = 13
exit_group(0)                           = ?
Process 11528 detached
__________________________________________________________________________________

As we can see, the compiled program does more than just print a string
The system calls at the start are setting up the environment and memory for the program, but the important part is the write() syscall shown in bold
This is what actually outputs the string

The Unix manual pages (accessed with the man command) are separated into sections
Section 2 contains the manual pages for system calls, so man 2 write will describe the use of the write() system call:

__________________________________________________________________________________
WRITE(2)               Linux Programmer's Manual                WRITE(2)

NAME
       write - write to a file descriptor

SYNOPSIS
       #include <unistd.h>

       ssize_t write(int fd, const void *buf, size_t count);

DESCRIPTION
       write() writes up to count bytes  to the file referenced by the file descriptor fd from the buffer starting at buf. POSIX requires that a read() which can be proved to occur after a write() returns the new data. Note that not all file systems are POSIX conforming.
__________________________________________________________________________________

The strace output also shows the arguments for the syscall
The buf and count arguments are a pointer to our string and its length
The fd argument of 1 is a special standard file descriptor
File descriptors are used for almost everything in Unix: input, output, file access, network sockets, and so on
A file descriptor is similar to a number given out at a coat check
Opening a file descriptor is like checking in your coat, since you are given a number that can later be used to reference your coat
The first 3 file descriptor numbers (0, 1, and 2) are automatically used for standard input, output, and error
These values are standard and have been defined in several plcaes, such as the /usr/include/unistd.h file on the following page


FROM /usr/include/unistd.h
__________________________________________________________________________________
/* Standard file descriptors. */
#define STDIN_FILENO  0 /* Standard input. */
#define STDOUT_FILENO 1 /* Standard output. */
#define STDERR_FILENO 2 /* Standard error output. */
__________________________________________________________________________________

Writing bytes to standard output's file descriptor of 1 will print the bytes; reading from standard input's file descriptor of 0 will input bytes
The standard error file descriptor of 2 is used to display the error or debugging messages that can be filtered from the standard output