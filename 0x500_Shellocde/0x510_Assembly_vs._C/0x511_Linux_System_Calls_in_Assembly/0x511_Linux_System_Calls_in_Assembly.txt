Every possible Linux system call is enumerated, so they can be referenced by numbers when making the calls in assembly
These syscalls are listed in /usr/include/asm-i386/unistd.h

FROM /usr/include/asm-i386/unistd.h
__________________________________________________________________________________
#ifndef _ASM_I386_UNISTD_H_
#define _ASM_I386_UNISTD_H_

/*
* This file contains the system call numbers.
*/

#define __NR_restart_syscall     0
#define  __NR_exit      1 
#define  __NR_fork      2 
#define  __NR_read      3 
#define  __NR_write     4 
#define  __NR_open      5 
#define  __NR_close     6 
#define  __NR_waitpid   7 
#define  __NR_creat     8 
#define  __NR_link      9 
#define  __NR_unlink   10 
#define  __NR_execve   11 
#define  __NR_chdir    12 
#define  __NR_time     13 
#define  __NR_mknod    14 
#define  __NR_chmod    15 
#define  __NR_lchown   16 
#define  __NR_break    17 
#define  __NR_oldstat  18 
#define  __NR_lseek    19 
#define  __NR_getpid   20 
#define  __NR_mount    21 
#define  __NR_umount   22 
#define  __NR_setuid   23 
#define  __NR_getuid   24 
#define  __NR_stime    25 
#define  __NR_ptrace   26 
#define  __NR_alarm    27 
#define  __NR_oldfstat 28 
#define  __NR_pause    29 
#define  __NR_utime    30 
#define  __NR_stty     31 
#define  __NR_gtty     32 
#define  __NR_access   33 
#define  __NR_nice     34 
#define  __NR_ftime    35 
#define  __NR_sync     36 
#define  __NR_kill     37 
#define  __NR_rename   38 
#define  __NR_mkdir    39 
...
__________________________________________________________________________________

For our rewrite of helloworld.c in assembly, we will make a system call to the write() function for the output and then a second system call to exit() so the process quits cleanly
This can be done in x86 assembly using just 2 assembly instructions: mov and int

Assembly instructions for the x86 processor have 1, 2, 3, or no operands
The operands to an instruction can be numerical values, memory addresses, or processor registers
The x86 processor has several 32-bit registers that can be viewed as hardware variables
The registers EAX, EBX, ECX, EDX, ESI, EDI, EBI, EBP, and ESP can all be used as operands, while the EIP register (execution pointer) cannot

The mov instruction copies a value between its 2 operands
Using Intel assembly syntax, the first operand is the destination and the second is the source
The int instruction sends an interrupt signal to the kernel, defined by its single operand
With the Linux kernel, interrupt 0x80 is used to tell the kernel to make a system call
When the int 0x80 instruction is executed, the kernel will make a system call based on the first 4 registers
The EAX register is used to specify which system call to make, while the EBX, ECX, and EDX registers are used to hold the first, second, and the third arguments to the system call
All of these registers can be set using the mov function

In the following assembly code listing, the memory segments are simply declared
The string "Hello, world!" with a newline character (0x0a) is in the data segment, and the actual assembly instruction are in the text segment
This follows proper memory segmentation practices

helloworld.asm
__________________________________________________________________________________
section .data       ; Data segment
msg     db      "Hello, world!", 0x0a   ; The string and newline char

section .text       ; Text segment
global _start       ; Default entry point for ELF linking

_start:
  ; SYSCALL: write(1, msg, 14)
  mov eax, 4       ; Put 4 into eax, since write is syscall #4
  mov ebx, 1       ; Put 1 into ebx, since stdout is 1
  mov ecx, msg     ; Put the address of the string into ecx
  mov edx, 14      ; Put 14 into edx, since our string is 14 bytes
  int 0x80         ; Call the kernle to make the system call happen

  ; SYSCALL: exit(0)
  mov eax, 1       ; Put 1 into eax, since exit is syscall #1
  mov ebx, 0       ; End with success
  int 0x80         ; Do the syscall
__________________________________________________________________________________

The instructions of this program are straightforward
For the write() syscall to standard output, the value of 4 is put in EAX since the write() function is system call number 4
Then, the value of 1 is put into EBX, since the first argument of write() should be the file descriptor for standard output
Next, the address of thestring in the data segment is put into ECX, and the length of the string (in this case, 14 bytes) is put into EDX
After these registers are loaded, the system call interrupt is triggered, which will call the write() function

To exit cleanly, the exit() function needs to be called with a single argument of 0
So the value of 1 is put into EAX, since exit() is a system call number 1, and the value of 0 is put into EBX, since the first and only argument should be 0
Then the system call interrupt is triggered again

To create an executable binary, this assembly code must first be assembled and then linked into an executable format
When compiling C code, the GCC compiler takes care of all of this automatically
We are going to create an executable and linking format (ELF) binary, so the global _start line shows the linker where the assembly instructions begin

The nasm assembler with the -f elf argument will assemble the helloworld.asm into an object file called helloworld.o
The linker program ld will produce an executable a.out binary from the assembled object
__________________________________________________________________________________
reader@hacking:~/booksrc $ nasm -f elf helloworld.asm
reader@hacking:~/booksrc $ ld helloworld.o
reader@hacking:~/booksrc $ ./a.out
Hello, world!
__________________________________________________________________________________

This tiny program works, but it is's not shellcode, since it isn't self-contained and must be linked