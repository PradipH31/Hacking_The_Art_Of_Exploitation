There are two primary ways to access files in  C: file descriptors and file-streams
File descriptors use a set of low-level I/O functions, and filestreams are a higher-level form of buffered I/O that is built on the lower-level functions
Filestream functions are considered easier to program with but file descriptors are more direct

The bar code on the back of a book represents a number
Beacuse the number is unique among the other books in a bookstore, the cashier can scan the number at checkout and use it to reference information about the book in the store's database
Similarly, a file descriptor is a number that is used to reference open files

Four common functions that use file descriptors are open(), close(), read(), and write()
All of these functions will return -1 if there is an error
The open() function opens a file for reading and/or writing and returns a file descriptor
The returned file descriptor is just an integer value, but it is unique among open files
The file descriptor is passed as an argument to the other functions like a pointer to the opened file

For the close() function, the file descriptor is the only argument
The read() and write() functions' arguments are the file descriptor, a pointer to the data to read or write, and the number of bytes to read or write from that location
The arguments to the open() function are a pointer to the filename to open and a series of predefined flags that specify the access mode
The following program accepts a note as a command-line argument and then adds it to the end of the file /tmp/notes
This program uses several functions, including a error-checked heap memory allocation function
Other functions are to display usage message and to handle fatal errors
The usage function is defined before main, so it does not need a prototype

simplenote.c
__________________________________________________________________________________
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>

void usage(char *prog_name, char *filename) {
    printf("Usage: %s <data to add to %s>\n", prog_name, filename);
}

void fatal(char *); //A function for fatal errors
void *ec_malloc(unsigned int);  //An error-checked malloc() wrapper

int main(int argc, char *argv[]) {
    int fd; // file descriptor
    char *buffer, *datafile;

    buffer = (char *) ec_malloc(100);
    datafile = (char *) ec_malloc(20);
    strcpy(datafile, "/tmp/notes");

    if(argc < 2) //If there aren't command-line arguments,
        usage(argv[0], datafile); //display usage message and exit

    strcpy(buffer, argv[1]); // Copy into buffer

    printf("[DEBUG] buffer @ %p: \'%s\'\n", buffer, buffer);
    printf("[DEBUG] datafile @ %p: \'%s\'\n", datafile, datafile);

    strncat(buffer, "\n", 1); // Add a newline to the end

    //Opening file
    fd = open(datafile, 0_WRONLY|0_CREAT|0_APPEND, S_IRUSR|S_IWUSR);
    if(fd == -1)
        fatal("in main() while opening file");
    printf("[DEBUG] file descriptor is %d\n", fd);

    //Writing data
    if(write(fd, buffer, strlen(buffer)) == -1)
        fatal("in main() while writing buffer to file");

    //Closing file
    if(close(fd) == -1)
        fatal("in main() while closing file");

    printf("Note has been saved.\n");
    free(buffer);
    free(datafile);
}

// A function to display an error message and then exit
void fatal(char *message) {
    char error_message[100];

    strcpy(error_message, "[!!] Fatal Error");
    strncat(error_message, message, 83);
    perror(error_message);
    exit(-1);
}

// An error-checked malloc() wrapper function
void *ec_malloc(unsigned int size){
    void *ptr;
    ptr = malloc(size);
    if(ptr == NULL)
        fatal("in ec_malloc() on memory allocation")
    return ptr;
}
__________________________________________________________________________________

There are a few standard functions that we haven't used before
The strlen() function accepts a string and returns its length
It's used in combination with the write() function, since it needs to know how many bytes to write
The perror() function is short for print error and is used in fatal() to print an additional error message(if it exists) before exiting

__________________________________________________________________________________
reader@hacking:~/booksrc $ gcc -o simplenote simplenote.c
reader@hacking:~/booksrc $ ./simplenote
Usage: ./simplenote <data to add to /tmp/notes>
reader@hacking:~/booksrc $ ./simplenote "this is a test note"
[DEBUG] buffer   @ 0x804a008: 'this is a test note'
[DEBUG] datafile @ 0x804a070: '/tmp/notes'
[DEBUG] file descriptor is 3
Note has been saved.
reader@hacking:~/booksrc $ cat /tmp/notes
this is a test note
reader@hacking:~/booksrc $ ./simplenote "great, it works"
[DEBUG] buffer   @ 0x804a008: 'great, it works'
[DEBUG] datafile @ 0x804a070: '/tmp/notes'
[DEBUG] file descriptor is 3
Note has been saved.
reader@hacking:~/booksrc $ cat /tmp/notes
this is a test note
great, it works
__________________________________________________________________________________

The output of the program's execution is pretty self-explanatory, but there are some things about the source code that need further explanation
The files fcntl.h and sys/stat.h had to be included, since those files define the flags used with the open() function
The first set of flags is found in fcntl.h and is used to set the access mode
The access mode must use at least one of the following three flags:
    O_RDONLY     Open file for read-only access
    O_WRONLY     Open file for write-only access
    O_RDWR       Open file for both read and write access
        These flags can be combined with several other optional flags using the bitwise OR operator
        Few of more common and useful flags are:
               O_APPEND    Write data at the end of the file
               O_TRUNC     If the file already exists, truncate the file to 0 length
               O_CREAT     Create the file if it doesn't exist
Bitwise operations combine bits using standard logic gates such as OR and AND
When two bits enter an OR gate, the result is 1 if either the first bit or the second bit is 1
If two bits enter an AND gate, the result is 1 onlt if both the first bit and the second bit are 1
Full 32-bit values can use these bitwise operators to perform logic operations on each corresponding bit
For example, 1010 & 1100 = 1000
             1010 | 1100 = 1110
             110100110011 & 011010010110 = 010000010010
             110100110011 | 011010010110 = 111110110111
bitwise.c
__________________________________________________________________________________
#include <stdio.h>

int main() {
    int i, bit_a, bit_b;
    printf("bitwise OR operator |\n");
    for(i=0; i < 4: i++) {
        bit_a = (i & 2) /2 ; //Get the second bit
        bit_b = (i & 1); // Get the first bit
        printf("%d | %d = %d\n", bit_a, bit_b, bit_a | bit_b);
    }
    printf("\nbitwise AND operator &\n")
    for (i = 0; i < 4; i++){
        bit_a = (i & 1) /2; // Get the second bit
        bit_b = (1 & i); //Get the first bit
        printf("%d & %d =%d\n", bit_a, bit_b, bit_a & bit_b);
    }
}
__________________________________________________________________________________

__________________________________________________________________________________
reader@hacking:~/booksrc $ gcc bitwise.c
reader@hacking:~/booksrc $ ./a.out
bitwise OR operator |
0 | 0 = 0
0 | 1 = 1
1 | 0 = 1
1 | 1 = 1

bitwise AND operator &
0 & 0 = 0
0 & 1 = 0
1 & 0 = 0
1 & 1 = 1

__________________________________________________________________________________

The flags used for the open() function have values that correspond to single bits
This way, flags can be combined using OR logic without destroying any information

How fcntl_flags.c shows some of the flag values defined by fcntl.h and how they combine with each other

fcntl_flags.c
__________________________________________________________________________________

#include <stdio.h>
#include <fcntl.h>

void display_flags(char *, unsigned int);
void binary_print(unsigned int);

int main(int argc, char *argv[]) {
    display_flags("O_RDONLY\t\t", O_RDONLY);
    display_flags("O_WRONLY\t\t", O_WRONLY);
    display_flags("O_RDWR\t\t\t", O_RDWR);
    printf("\n");
    display_flags("O_APPEND\t\t", O_APPEND);
    display_flags("O_TRUNC\t\t\t", O_TRUNC);
    display_flags("O_CREAT\t\t\t", O_CREAT);
    printf("\n");
    display_flags("O_WRONLY|O_APPEND|O_CREAT", O_WRONLY|O_APPEND|O_CREAT);
}

void display_flags(char * label, unsigned int value) {
    printf("%s\t: %d\t:", label, value);
    binary_print(value);
    printf("\n");
}

void binary_print(unsigned int value) {
    unsigned int mask = 0xff000000; // Start with a mask for the highest byte
    unsigned int shift = 256*256*256; // Start with a shift for the highest byte
    unsigned int byte, byte_iterator, bit_iterator;

    for(byte_iterator=0; byte_iterator < 4; byte_iterator++) {
        byte = (value & mask) / shift; // Isolate each byte
        printf(" ");
        for(bit_iterator=0; bit_iterator < 8; bit_iterator++) {
            if(byte & 0x80) // If highest bit in the byte isn't 0,
                printf("1"); //print a 1
            else
                printf("0"); // Otherwise, print a 0
            byte *= 2;
        }
        mask /= 256;  //Move the bits in mask right by 8
        shift /= 256; //Move the bits in shift right by 8
    }
}
__________________________________________________________________________________

The mask has the highest value for the highest byte(highest byte is the first two hexadecimal numbers or the first byte or first 8 bits)(1111-1111)
The shift is in decimal(always 2 bytes less than the mask)
When we use the bitwise operator & on the value(value of flags used in open) and the mask, we get the value of the highest byte of the flag(first 2 hexadecimal numbers) after dividing by the shift
When we use the & on the value of the byte and 0x80(the highest value for highest bit)(1000-0000), we find out if the highest bit is 1 or 0
When muliplying byte by 2, we shift all the bits to the left(that causes 01101010 to become 11010100), so that it & checks if the next bit is 1 or 0
__________________________________________________________________________________
reader@hacking:~/booksrc $ gcc fcntl_flags.c
reader@hacking:~/booksrc $ ./a.out
O_RDONLY                        : 0     : 00000000 00000000 00000000 00000000
O_WRONLY                        : 1     : 00000000 00000000 00000000 00000001
O_RDWR                          : 2     : 00000000 00000000 00000000 00000010

O_APPEND                        : 1024  : 00000000 00000000 00000100 00000000
O_TRUNC                         : 512   : 00000000 00000000 00000010 00000000
O_CREAT                         : 64    : 00000000 00000000 00000000 01000000

O_WRONLY|O_APPEND|O_CREAT       : 1089  : 00000000 00000000 00000100 01000001
__________________________________________________________________________________

Using bit flags in combination with bitwise logic is an efficient and commonly used technique
As long as each flag is a number that only has unique bits turned on, the effect of doing a bitwise OR on these values is the same as adding them
This technique only works when all the bits are unique