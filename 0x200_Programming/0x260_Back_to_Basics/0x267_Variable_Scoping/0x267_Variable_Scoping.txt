An interesting concept regarding memory in C is variable scoping or context-in particular, the contexts of variables within functions
Each function has its own sets of local variables, which are independent of everything else
In fact, multiple calls to the same function all have their own contexts

Exploring the variable scopes in C:
scope.c
__________________________________________________________________________________
#include <stdio.h>

void func3() {
	int i = 11;
	printf("\t\t[in func3] i = %d\n", i);
}

void func2() {
	int i = 7;
	printf("\t\t[in func2] i = %d\n", i);
	func3();
	printf("\t\t[back in func2] i = %d\n", i);
}

void func1(){
	int i = 5;
	printf("\t[in func1] i = %d\n", i);
	func2();
	printf("\t[back in func1] i  = %d\n", i);
}

int main() {
	int i = 3;
	printf("[in main] i = %d\n", i);
	func1();
	printf("[back in main] i = %d\n", i);
}

The output of this simple program demonstrates nested function calls

reader@hacking:~/booksrc $ gcc scope.c
reader@hacking:~/booksrc $ ./a.out
[in main] i = 3
    [in func1] i = 5
        [in func2] i = 7
            [in func3] i = 11
        [back in func2] i = 7
    [back in func1] i = 5
[back in main] i = 3

In each function, the variable i is set to a different value and printed
Within the main() function, the variable i is 3, even after calling func1() where the variable i is 5
Within func1() the variable i reamins 5, even after calling func2() where i is 7, and so forth
The best way to think of this is that each function call has its own version of the variable i

Variables can also have a global scope, which means they will persist across all functions
Variables are global if they are defined at the beginning of the code, outside of any functions

Global variables in C:
scope2.c
__________________________________________________________________________________
#include <stdio.h>

int j = 42; //j is a global variable

void func3() {
	int i = 11, j = 999; //Here, j is a local variable of func3()
	printf("\t\t\t[in func3] i = %d, j = %d\n", i, j);
}

void func2() {
	int i = 7;
	printf("\t\t[in func2] i = %d, j = %d\n", i, j);
	printf("\t\t[in func2] setting j - 1337\n");
	j = 1337; // Writing to j
	func3();
	printf("\t\t[back in func2] i = %d, j = %d\n", i, j);
}

void func1() {
	int i = 5;
	printf("\t[in func1] i = %d, j = %d\n", i, j);
	func2();
	printf("[back in func1 i = %d, j = %d\n", i, j);
}

int main() {
	int i = 3;
	printf("[in main] i = %d, j = %d\n", i, j);
	fuc1();
	printf("[back in main] i = %d, j = %d\n", i, j);
}

reader@hacking:~/booksrc $ gcc scope2.c
reader@hacking:~/booksrc $ ./a.out
[in main] i = 3, j = 42
    [in func1] i = 5, j = 42
        [in func2] i = 7, j = 42
        [in func2] setting j = 1337
            [in func3] i = 11, j = 999
        [back in func2] i = 7, j = 1337
    [back in func1] i = 5, j = 1337
[back in main] i = 3, j = 1337

In the output, the global variable j is written to in func2(), and the change persists in all functions except func3(), which has its own local variable called j
In this case, the compiler prefers to use the local variable
With all these variables using the same names, it can be a little confusing, but remember that in the end, it's all just memory
The global variable j is just stored in memory, and every function is able to access that memory
The local variables for each function are each stored in their own places in memory, regardless of identical names
Printing the memory address of these variables will give a clearer picture of what's going on

scope3.c
__________________________________________________________________________________
#include <stdio.h>

int j = 42; // j is a global variable

void func3() {
	int i = 11, j = 999; //Here, j is a local variable of func3()
	printf("\t\t\t[in func3] i @ 0x%08x = %d\n", &i, i);
	printf("\t\t\t[in func3] j @ 0x%08x = %d\n", &j, j);
}

void func2() {
	int i = 7;
	printf("\t\t[in func2] i @ 0x%08x = %d\n", &i, i);
	printf("\t\t[in func2] j @ 0x%08x = %d\n", &j, j);
	printf("\t\t[in func2] setting j - 1337\n");
	j = 1337; // Writing to j
	func3();
	printf("\t\t[back in func2] i @ 0x%08x %d\n", &i, i);
	printf("\t\t[back in func2] j @ 0x%08x %d\n", &j, j);
}

void func1() {
	int i = 5;
	printf("\t[in func1] i @ 0x%08x = %d\n", &i, i);
	printf("\t[in func1] j @ 0x%08x = %d\n", &j, j);
	func2();
	printf("[back in func1 i @ 0x%08x = %d\n", &i, i);
	printf("[back in func1 j @ 0x%08x = %d\n", &j, j);
}

int main() {
	int i = 3;
	printf("[in main] i @ 0x%08x = %d\n", &i, i);
	printf("[in main] j @ 0x%08x = %d\n", &j, j);
	fuc1();
	printf("[back in main] i @ 0x%08x = %d\n", &i, i);
	printf("[back in main] j @ 0x%08x = %d\n", &j, j);
}

reader@hacking:~/booksrc $ gcc scope3.c
reader@hacking:~/booksrc $ ./a.out
[in main] i @ 0xbffff834 = 3
[in main] j @ 0x08049988 = 42
    [in func1] i @ 0xbffff814 = 5
    [in func1] j @ 0x08049988 = 42
        [in func2] i @ 0xbffff7f4 = 7
        [in func2] j @ 0x08049988 = 42
        [in func2] setting j = 1337
            [in func3] i @ 0xbffff7d4 = 11
            [in func3] j @ 0xbffff7d0 = 999
        [back in func2] i @ 0xbffff7f4 = 7
        [back in func2] j @ 0x08049988 = 1337
    [back in func1] i @ 0xbffff814 = 5
    [back in func1] j @ 0x08049988 = 1337
[back in main] i @ 0xbffff834 = 3
[back in main] j @ 0x08049988 = 1337

In this output, it is obvious that the variable j used by func3() is different than the j used by the other functions
The j used by func3() is located at 0x08049988
We can note that the variable i is actually a different memory address for each function

Viewing scope3.c in gdb:

reader@hacking:~/booksrc $ gcc -g scope3.c
reader@hacking:~/booksrc $ gdb -q ./a.out
Using host libthread_db library "/lib/tls/i686/cmov/libthread_db.so.1".
(gdb) list 1
1        #include <stdio.h> 
2       
3        int j = 42; // j is a global variable. 
4       
5        void func3() { 
6        int i = 11, j = 999; // Here, j is a local variable of func3(). 
7        printf("\t\t\t[in func3] i @ 0x%08x = %d\n", &i, i); 
8        printf("\t\t\t[in func3] j @ 0x%08x = %d\n", &j, j); 
9        } 
10
(gdb) break 7
Breakpoint 1 at 0x8048388: file scope3.c, line 7.
(gdb) run
Starting program: /home/reader/booksrc/a.out
[in main] i @ 0xbffff834 = 3
[in main] j @ 0x08049988 = 42
    [in func1] i @ 0xbffff814 = 5
    [in func1] j @ 0x08049988 = 42
        [in func2] i @ 0xbffff7f4 = 7
        [in func2] j @ 0x08049988 = 42
        [in func2] setting j = 1337

Breakpoint 1, func3 () at scope3.c:7
7       printf("\t\t\t[in func3] i @ 0x%08x = %d\n", &i, i);
(gdb) bt
#0 func3 () at scope3.c:7
#1 0x0804841d in func2 () at scope3.c:17
#2 0x0804849f in func1 () at scope3.c:26
#3 0x0804852b in main () at scope3.c:35

The backtrace also shows the nested function calls by looking at records kept on the stack
Each time a function is called, a record called a stack frame is put on the stack
Each line in the backtrace corresponds to a stack frame
Each stack frame also contains the localvariables for that context(scope)
The local variables contained in each frame can be shown in GDB by adding the word full to the backtrace command

(gdb) bt full
#0 func3 () at scope3.c:7
         i = 11
         j = 999
#1 0x0804841d in func2 () at scope3.c:17
         i = 7
#2 0x0804849f in func1 () at scope3.c:26
         i = 5
#3 0x0804852b in main () at scope3.c:35
         i = 3

The full backtrace clearly shows that the local variable j only exists in func3()'s context
The global version of the variable j is used in the other fucntion's contexts

In addition to globals, variables can also be defined as static variables by prepending the keyword static to the variable definition
Similar to global, a static variable remains intact between the function calls; however, static variables are akin to local variables since they remain local within a particular function context
A different and unique feature of static variables is that they are only initialized once
Until a program stops execution, the statuc variables in a context remain intact, they will not be re-initialized

static.c
____________________________________________________________________
#include <stdio.h>

void function() { // An example function, with its context
    int var = 5;
    static int static_var = 5; // Static variable initialization

    printf("\t[in function] var = %d\n", var);
    printf("\t[in function] static+var = %d\n", static_var);
    var++;        //Add one to var
    static_var++;        //Add one to static_var
}

int main() { //The main funtion, with its own cotent
    int i;
    static int static_var = 1337; // Another static, in a different context

    for(i = 0; i < 5; i++){ // Loop 5 times
        printf("[in main] static_var = %d\n", static_var);
        function(); // Call the function
    }
}

The aptly named static_var is defined as a static variable in two places: within the context of main() and within the context of function()
Since static variables are local within a particular functional context, these variables can have the same name, but represent 2 different locations in memory
The function simply prints the values of the two variables in its context and then adds 1 to both of them

Viewing the difference between static and nonstatic variables:

reader@hacking:~/booksrc $ gcc static.c
reader@hacking:~/booksrc $ ./a.out
[in main] static_var = 1337
    [in function] var = 5
    [in function] static_var = 5
[in main] static_var = 1337
    [in function] var = 5
    [in function] static_var = 6
[in main] static_var = 1337
    [in function] var = 5
    [in function] static_var = 7
[in main] static_var = 1337
    [in function] var = 5
    [in function] static_var = 8
[in main] static_var = 1337
    [in function] var = 5
    [in function] static_var = 9

The static_var retains its value between subsequent calls to function()
This is because static variables retain their values, but also because they are only initialized once
Also, since static variables are local to a particular context, the static_var in main() retains its value of 1337 the entire time

Getting clearer about static variables:

static2.c
____________________________________________________________________
#include <stdio.h>

void function() { // An example function, with its context
    int var = 5;
    static int static_var = 5; // Static variable initialization

    printf("\t[in function] var @ %p = %d\n", &var var);
    printf("\t[in function] static_var @ %p = %d\n", &static_var, static_var);
    var++;        //Add one to var
    static_var++;        //Add one to static_var
}

int main() { //The main funtion, with its own cotent
    int i;
    static int static_var = 1337; // Another static, in a different context

    for(i = 0; i < 5; i++){ // Loop 5 times
        printf("[in main] static_var @ %p = %d\n", &static_var, static_var);
        function(); // Call the function
    }
}

reader@hacking:~/booksrc $ gcc static2.c
reader@hacking:~/booksrc $ ./a.out
[in main] static_var @ 0x804968c = 1337
    [in function] var @ 0xbffff814 = 5
    [in function] static_var @ 0x8049688 = 5
[in main] static_var @ 0x804968c = 1337
    [in function] var @ 0xbffff814 = 5
    [in function] static_var @ 0x8049688 = 6
[in main] static_var @ 0x804968c = 1337
    [in function] var @ 0xbffff814 = 5
    [in function] static_var @ 0x8049688 = 7
[in main] static_var @ 0x804968c = 1337
    [in function] var @ 0xbffff814 = 5
    [in function] static_var @ 0x8049688 = 8
[in main] static_var @ 0x804968c = 1337
    [in function] var @ 0xbffff814 = 5
    [in function] static_var @ 0x8049688 = 9

With the addresses of the variables displayed, it is apparent that the static_var in main() is different than the one found in function(), since they are located at different memory addresses
Take note that local variables have very high addresses, like 0xbffff814, while the global and static variables all have memory addresses, like 0x8049688