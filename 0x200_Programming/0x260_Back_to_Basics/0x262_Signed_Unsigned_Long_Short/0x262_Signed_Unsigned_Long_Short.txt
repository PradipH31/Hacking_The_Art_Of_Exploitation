By default, numerical values in C are signed, meaning they can be both negative and positive
Unsigned values don't allow negative numbers
Since it's all just memory in the end, all numerical values must be stored in binary, and unsigned values make most sense in binary
A 32-bit signed integer can contain values from 0(all binary 0s) to 4,294,967,295(all binary 1s)
A 32-bit signed integer is still just 32 bits, which means it can only be in one of 2^32 possible bit combinations, allowing 32 bit signed integers to range from -2,147,483,648 to 2,147,483,648
Essentially, one of the bits is a flag marking the value positive or negative
Positively signed values look the same as unsigned values, but negative numbers are stored differently using a method called two's complement
Two's complement represents negative numbers in a form suited for binary adders-when a negative value in two's complement is added to a positive number of the same magnitude, the result will be 0
This is done by first writing the positive number in binary, then inverting all bits and finally adding 1
    For example, (73)dec=(01001001)bin
    Reversing the bits   (10110110)bin
    Adding 1             (10110111)bin = (183)dec
    Adding line 10 and 12((1)00000000)bin = (256)dec
    What happened is the byte became full(11111111) and adding 1 made the byte empty and carried over the extra bit(which would be thrown away in a variable, a signed integer(1 byte), beacuse the end of the variable's memory would have been reached)
    In decimal conversion, it filled from 0-255 and 256 means it got emptied

In C, variables can be declared as unsigned by simply prepending the keyword unsigned to the declaration(unsigned int)
The size of numerical variables can be extended or shortened by adding keywords long or short
The actual size varies depending on the architecture the code is compiled for
With function sizeof(), we can determine size of data types

Program to explore sizes of various data types:
datatype_sizes.c
__________________________________________________________
#include <stdio.h>

int main(){
    printf("The 'int' data type is\t\t %d bytes\n", sizeof(int));
    printf("The 'unsigned int' data type is \t %d bytes\n", sizeof(unsigned int));
    printf("The 'short int' data type is \t %d bytes\n", sizeof(short int));
    printf("The 'long int' data type is \t %d bytes\n", sizeof(long int));
    printf("The 'long long int' data type is %d bytes\n", sizeof(long long int));
    printf("The 'float' data type is \t %d bytes\n", sizeof(float));
    printf("The 'char' data type is \t\t %d bytes\n", sizeof(char));
}

We are using printf with a format specifier to display the value returned from sizeof() functin calls

reader@hacking:~/booksrc $ gcc datatype_sizes.c
reader@hacking:~/booksrc $ ./a.out
The 'int' data type is           4 bytes
The 'unsigned int' data type is  4 bytes
The 'short int' data type is     2 bytes
The 'long int' data type is      4 bytes
The 'long long int' data type is 8 bytes
The 'float' data type is         4 bytes
The 'char' data type is          1 bytes

We can see that both signed and unsigned integers are four bytes in size on the x86 architecture
A float is also four bytes, while a char only needs a single byte
The long and short keywords can also be used with floating-points variables to extend and shorten their sizes