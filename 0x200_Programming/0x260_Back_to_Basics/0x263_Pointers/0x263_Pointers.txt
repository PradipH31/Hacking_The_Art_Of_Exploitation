The EIP register is a pointer that 'points' to the current isntruction during a program's execution by containing its memory address
The idea of pointers is used in C as well
Since the physical memory cannot be moved, the information in it must be copied
It can be computationally very expensive to copy large chunks of memory to be used by different functions or in different places
This is also expensive from a memory standpoint as space for new destination copy must be saved or allocated before the source can be copied
Instead of copying a large block of memory, it is much simpler to pass around the address of the beginning of that bloack of memory

Pointers in C can be defined and used like any other variable type
Since memory on the x86 arhcitecture uses 32-bit addressing, pointers are 32-bits in size(4 bytes)
Pointers are defined by prepending an asterisk(*) to the variable name
Instead of defining a variable of that type, a pointer is defined as something that points to data of that type

Using pointer with char data type
pointer.c
_____________________________________________________________________
#include <stdio.h>
#include <string.h>

int main(){
    char str_a[20];  //A 20-element character array
    char *pointer;   // A pointer, meant for a character array
    char *pointer2;  // Another pointer

    strcpy(str_a, "Hello, world!\n");
    pointer = str_a;  //Set the first ponter to the start of array
    printf(pointer);

    pointer2 = pointer + 2; //Set the second pointer 2 bytes further in
    printf(pointer2);
    strcpy(pointer2, "y you guys!\n");  //Copy into that spot
    printf(pointer);
}

The first pointer is set at the beginning of the character array
When the character array is referenced like this, it is actually a pointer itself
This is how this buffer was passed a pointer to the printf() and strcpy() fucntions earlier

Looking at the program with GDB:

reader@hacking:~/booksrc $ \\\gcc -o pointer pointer.c
reader@hacking:~/booksrc $ \\\./pointer
Hello, world!
llo, world!
Hey you guys!

reader@hacking:~/booksrc $ gdb -q ./pointer
Using host libthread_db library "/lib/tls/i686/cmov/libthread_db.so.1".
(gdb) list
1     #include <stdio.h>
2     #include <string.h>
3
4      int main() {
5         char str_a[20]; // A 20-element character array
6         char *pointer; // A pointer, meant for a character array
7         char *pointer2; // And yet another one
8  
9         strcpy(str_a, "Hello, world!\n");
10        pointer = str_a; // Set the first pointer to the start of the array.
(gdb)    \\\[Enter]
11        printf(pointer);
12
13        pointer2 = pointer + 2; // Set the second one 2 bytes further in.
14        printf(pointer2);       // Print it.
15        strcpy(pointer2, "y you guys!\n"); // Copy into that spot.
16        printf(pointer);       // Print again.
17     }
(gdb) \\\break 11
Breakpoint 1 at 0x80483dd: file pointer.c, line 11.
(gdb) \\\run
Starting program: /home/reader/booksrc/pointer
Breakpoint 1, main () at pointer.c:11
11        printf(pointer);
(gdb) x/xw pointer
0xbffff7e0:        0x6c6c6548
(gdb) x/s pointer
0xbffff7e0:        "Hello, world!\n"

When we examine the pointer as a string, we can see the given string which is located at memory address 0xbffff7e0
Note that the string itself isn't stored in the pointer variable, only the memory address 0xbffff7e0 is stored in the pointer

To see actual data stored in pointer variable, we must use the address-of operator
The address-of operator is a unary operator(operatoes on a single argument)
This operator is just an ampersand(&) prepended to a variable name
When it's used, the address of that variable is returned, instead of the variable itself
This operator exists both in GDB and C programming language

(gdb) \\\x/xw &pointer
0xbffff7dc:         0xbffff7e0
(gdb) \\\print &pointer
$1 = (char **) 0xbffff7dc
(gdb) \\\print pointer
$2 = 0xbffff7e0 "Hello, world!\n"

Witht the use of address-of oeprator, we see that pointer varaible is in 0xbffff7dc in the memory and it is pointing to 0xbffff7e0(which contains Hello, world)
The address-of operator is often used in conjunction with pointers, since pointers contain memory addresses

Using address-of in C:

addressesof.c
_____________________________________________________________
#include <stdio.h>

int main(){
    int int_var = 5;
    int *int_ptr;

    int_ptr = &int_var; //puts the address of int_var into int_ptr
}


reader@hacking:~/booksrc $ \\\gcc -g addressof.c
reader@hacking:~/booksrc $ \\\gdb -q ./a.out
Using host libthread_db library "/lib/tls/i686/cmov/libthread_db.so.1".
(gdb) \\\list
1     #include <stdio.h>
2
3     int main() {
4               int int_var = 5;
5               int *int_ptr;
6
7               int_ptr = &int_var; // Put the address of int_var into int_ptr.
8     }
(gdb) \\\break 8
Breakpoint 1 at 0x8048361: file addressof.c, line 8.
(gdb) \\\run
Starting program: /home/reader/booksrc/a.out
Breakpoint 1, main () at addressof.c:8
8
 }
(gdb) \\\print int_var
$1 = 5
(gdb) \\\print &int_var
$2 = (int *) 0xbffff804
(gdb) \\\print int_ptr
$3 = (int *) 0xbffff804
(gdb) \\\print &int_ptr
$4 = (int **) 0xbffff800

We execute the program in the debugger and set a breakpoint
The first print command shows the value of int_var, second print shows its address using the address-of operator
The next two print commands show that int_ptr contains the address of int_var

Another unary operator called the deference operator exists for use with pointers
This operator returns the data found in the address the pointer is pointing to, instead of the address itself
It takes the form of an asterisk(*) in front of the variable name, similar to declaration of pointer
This deference operator exists both in C & GDB
When used in GDB, it can retreive the integer value int_ptr points to
(gdb) print *int_ptr
$5 = 5

Using the unary operators in a C program:
addressof2.c
____________________________________________________________________
#include <stdio.h>

int main(){
    int int_var = 5;
    int *int_ptr;

    int_ptr = &int_var; //Put the address of int_var into int_ptr

    printf("int_ptr = 0x%08x\n", int_ptr);
    printf("&int_ptr = 0x%08x\n", &int_ptr);
    printf("*int_ptr = 0x%08x\n", *int_ptr);

    printf("int_var is located at 0x%08x and contains %d\n", &int_var, int_var);
    printf("int_ptr is located at 0x%08x and contains 0x%08x, and points to %d\n", &int_ptr, int_ptr, *int_ptr);
}

The results of execution of the code is:
reader@hacking:~/booksrc $ gcc -g o addressof2 addressof2.c
reader@hacking:~/booksrc $ ./addressof2
int_ptr = 0xbffff834
&int_ptr = 0xbffff830
*int_ptr = 0x00000005
int_var is located at 0xbffff834 and contains 5
int_ptr is located at 0xbffff830, contains 0xbffff834, and points to 5

When unary operators are used with pointers, the address-of operator can be thought as moving backward, while the dereference operator moves forward in the direction the pointer is pointing