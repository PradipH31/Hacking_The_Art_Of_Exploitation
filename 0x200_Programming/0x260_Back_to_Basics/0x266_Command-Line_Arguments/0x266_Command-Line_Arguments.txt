Most nongraphical porgrams receive input in the form of command-line arguments
Unlike inputting with scanf(), command-line arguments don't require user interaction after the program has begun execution
This tends to be more efficient and is a useful input method

In C, command-line arguments can be accessed in the main() function by including two additional arguments to the function: an integer and a pointer to an array of strings
The integer will contain the number of arguments, and the array of strings will contain each of those arguments

commandline.c
_________________________________________________________________________________
#include <stdio.h>

int main(int arg_count, char *arg_list[]) {
	int i;
	printf("There were %d arguments provided:\n", arg_count);
	for(i = 0; i < arg_count; i++)
		printf("arguemt #%d\t-\t%s\n", i, arg_list[i]);
}

reader@hacking:~/booksrc $ gcc -o commandline commandline.c
reader@hacking:~/booksrc $ ./commandline
There were 1 arguments provided:
argument #0      -      ./commandline
reader@hacking:~/booksrc $ ./commandline this is a test
There were 5 arguments provided:
argument #0     -     ./commandline
argument #1     -      this
argument #2     -      is
argument #3     -      a
argument #4     -      test

The zeroeth argument is always the name of the executing binary, and the rest of the argument array (often called an argument vector) contains the remaining arguments as strings

Sometimes a program will want to use a command-line argument as an integer as opposed to a string
Regardless of this, the argument is passed in as a string; however, there are standard conversion functions
Unlike simple typecasting, these functions can actually convert character arrays containing number into actual integers
The most common of these functions is atoi(), short for ASCII to integer
It accepts a pointer to a string as its argument and returns the integer value it represents

convert.c
__________________________________________________________________________________
#include <stdio.h>

void usage(char *program_name) {
	pritnf("Usage: %s <message> <# of times to repeat>\n", program_name);
	exit(1);
}

int main(int argc, char *argv[]) {
	int i, count;

	if(argc < 3)
		usage(argv[0]);

	count = atoi(argv[2]);
	printf("Repeating %d times..\n", count);

	for(i=0; i < count; i++){
		printf("%3d - %s\n", i, argv[1]);
	}
}

reader@hacking:~/booksrc $ gcc convert.c
reader@hacking:~/booksrc $ ./a.out
Usage: ./a.out <message> <# of times to repeat>
reader@hacking:~/booksrc $ ./a.out 'Hello, world!' 3
Repeating 3 times..
0 - Hello, world!
1 - Hello, world!
2 - Hello, world!

In the preceding code, an if statement makes sure that three arguments are used before these strings are accessed
If the program tries to access memory that doesn't exist or that the program doesn't have permission to read, the program will crash(basically means if arguments are less than 3 or greater than 3, the program would have crashed otherwise)
In C, its important to check for these conditionals and handle them in program logic
If the error-checking if statement is commented out, this memory violation can be exploited

convert2.c
__________________________________________________________________________________
#include <stdio.h>

void usage(char *program_name) {
	pritnf("Usage: %s <message> <# of times to repeat>\n", program_name);
	exit(1);
}

int main(int argc, char *argv[]) {
	int i, count;

	// if(argc < 3)
	// 	usage(argv[0]);

	count = atoi(argv[2]);
	printf("Repeating %d times..\n", count);

	for(i=0; i < count; i++){
		printf("%3d - %s\n", i, argv[1]);
	}
}

reader@hacking:~/booksrc $ gcc convert2.c
reader@hacking:~/booksrc $ ./a.out test
Segmentation fault (core dumped)

When the program isn't given enough command-line arguments, it still tries to access elements of the argument array, even though they don't exist
This results in the program crashing due to a segmentation fault

Memory is split into segments, and some memory addresses aren't within the boundaries of the memory segments the program is given access to
When the program attempts to access an address that is out of bounds, it will crash and die in what's called a segmentation fault

Viewing memory segmentation fault with GDB

reader@hacking:~/booksrc $ gcc -g convert2.c
reader@hacking:~/booksrc $ gdb -q ./a.out
Using host libthread_db library "/lib/tls/i686/cmov/libthread_db.so.1".
(gdb) run test
Starting program: /home/reader/booksrc/a.out test
Program received signal SIGSEGV, Segmentation fault.
0xb7ec819b in ?? () from /lib/tls/i686/cmov/libc.so.6
(gdb) where
#0 0xb7ec819b in ?? () from /lib/tls/i686/cmov/libc.so.6
#1 0xb800183c in ?? ()
#2 0x00000000 in ?? ()
(gdb) break main
Breakpoint 1 at 0x8048419: file convert2.c, line 14.
(gdb) run test
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /home/reader/booksrc/a.out test
Breakpoint 1, main (argc=2, argv=0xbffff894) at convert2.c:14
14 count = atoi(argv[2]); // convert the 2nd arg into an integer
(gdb) cont
Continuing.
Program received signal SIGSEGV, Segmentation fault.
0xb7ec819b in ?? () from /lib/tls/i686/cmov/libc.so.6
(gdb) x/3xw 0xbffff894
0xbffff894:        0xbffff9b3        0xbffff9ce        0x00000000
(gdb) x/s 0xbffff9b3
0xbffff9b3:        "/home/reader/booksrc/a.out"
(gdb) x/s 0xbffff9ce
0xbffff9ce:        "test"
(gdb) x/s 0x00000000
0x0:               <Address 0x0 out of bounds>
(gdb) quit


The program is executed with a single command-line argument of test within GDB which causes the program to crash as the program requires exactly 2 arguments
The where command will sometime show a useful backtrace of the stack; however, in this case, the stack was too badly mangled in the crash
We set a breakpoint on main and re-execute the program to get the value of argument vector(0xbffff894)
Since the argument vector is a pointer to a list of strings, it is actually a pointer to a list of pointers
We examine the first 3 memory addresses stored at the argument vector's addresses, which are themselves pointers to strings(use the examine on the addresses, which point to another address that contains the strings)
The first pointer is the zeroeth argument, the second is the test argument and the third is zero, which is out of bounds
When the program tries to access this memory, it crashes with a segmentation fault