Typecasting is simply a way to temporarily change a variable's data type, despite how it was originally defined
When a variable is typecast into a different type, the compiler is basically told to treat that variable as if it were the new data type, but only for that operation

Syntax for typecasting:
(typecast_data_type) variable

typecasting.c
_________________________________________________________________________
#include <stdio.h>

int main() {
    int a, b;
    float c, d;

    a = 13;
    b = 5;

    c = a/b;                    //Divide using integers
    d = (float) a / (float) b;    //Divide integers typecast as floats

    printf("[integers]\t a = %d\t b = %d\n", a, b);
    printf("[floats]\t c = %f\t d = %f\n", c, d);
}

reader@hacking:~/booksrc $ \\\gcc typecasting.c
reader@hacking:~/booksrc $ \\\./a.out
[integers]     a = 13 b = 5
[floats]       c = 2.000000       d = 2.600000

Dividing the integer 13 by 5 will round down to the incorrect answer of 2, even if this value is being stored into a floating-point variable
However, if these integer variables are typecast into flocats, they will be treated as such
This allows for correct calculation of 2.6

Typecasting really shines in pointers
Even though a pointer is just a memory address, the C compiler still demands a data type for every pointer
One reason for this is to limit programming errors
An integer pointer should only point to integer data, while a character pointer should only point to character data
Another reason is for pointer arithmetic
An integer is 4 bytes in size, while a character only takes up a single byte
We can use %p tp output memory address(shorthand for displaying pointers and equivalent to 0x%08x)

pointer_types.c
_________________________________________________________________________
#include <stdio.h>

int main() {
    int i;

    char char_array[5] = {'a'. 'b', 'c'. 'd'. 'e'};
    int int_array[5] = {1, 2, 3, 4, 5};

    char *char_pointer;
    int *int_pointer;

    char_pointer = char_array;
    int_pointer = int_array;

    for(i=0; i < 5; i++) { //Iterate through the int array with the int_pointer
        printf("[integer pointer] points to %p, which contains the integer %d\n", int_pointer, *int_pointer);
        int_pointer = int_pointer + 1;
    }

    for(i=0; i < 5; i++){ //Iterate through the char array with the char_pointer
        printf("[char pointer] points to %p, which contains the char '%c\'n", char_pointer, *char_pointer);
        char_pointer = char_pointer + 1;
    }
}

In this code, two arrays are defined in memory-one containing integer data and other containing character data
Two pointers are also defined, integer type and character type and are set to point tat the start of the corresponding data arrays
Two separate for loops iterate through the arrays using pointer arithmetic to adjust pointer to point at next value
We use the derefernce unary operator in pointer variables to print the actual values of character and integer

reader@hacking:~/booksrc $ \\\gcc pointer_types.c
reader@hacking:~/booksrc $ \\\./a.out
[integer pointer] points to 0xbffff7f0, which contains the integer 1
[integer pointer] points to 0xbffff7f4, which contains the integer 2
[integer pointer] points to 0xbffff7f8, which contains the integer 3
[integer pointer] points to 0xbffff7fc, which contains the integer 4
[integer pointer] points to 0xbffff800, which contains the integer 5
[char pointer] points to 0xbffff810, which contains the char 'a'
[char pointer] points to 0xbffff811, which contains the char 'b'
[char pointer] points to 0xbffff812, which contains the char 'c'
[char pointer] points to 0xbffff813, which contains the char 'd'
[char pointer] points to 0xbffff814, which contains the char 'e'

Even though the value 1 is added to int_pointer and char_pointer in their respective loops, the compiler increments the pointer's addresses by different amounts
Since a char is only 1 byte, the pointer to the next char would be 1 byte over
But since an integer is 4 bytes, a pointer to the next integer has to be 4 bytes over

In this next program, pointers are juxtaposed such that int_pointer points to character data and char_pointer points to integer data

pointer_types2.c
_____________________________________________________________________________
#include <stdio.h>

int main() {
    int i;

    char char_array[5] = {'a'. 'b', 'c'. 'd'. 'e'};
    int int_array[5] = {1, 2, 3, 4, 5};

    char *char_pointer;
    int *int_pointer;

    char_pointer = int_array; //The char_pointer and int_pointer
    int_pointer = char_array; //point to incompatible data type

    for(i=0; i < 5; i++) { //Iterate through the int array with the int_pointer
        printf("[integer pointer] points to %p, which contains the integer %d\n", int_pointer, *int_pointer);
        int_pointer = int_pointer + 1;
    }

    for(i=0; i < 5; i++){ //Iterate through the char array with the char_pointer
        printf("[char pointer] points to %p, which contains the char '%c\'n", char_pointer, *char_pointer);
        char_pointer = char_pointer + 1;
    }
}

reader@hacking:~/booksrc $ \\\gcc pointer_types2.c
pointer_types2.c: In function `main':
pointer_types2.c:12: warning: assignment from incompatible pointer type
pointer_types2.c:13: warning: assignment from incompatible pointer type

The compiler gives warnings about pointers that point to incompatible data types to prevent programming mistake
But the compiler and perhaps the programmer are the only ones who care about a pointer's type
In the compiled code, a pointer is nothing more than a memory address, so the compiler will still compile the code if a pointer points to an incompatible data type(just warns the programmer to anticipate unexpected results)

reader@hacking:~/booksrc $ \\\./a.out
[integer pointer] points to 0xbffff810, which contains the char 'a'
[integer pointer] points to 0xbffff814, which contains the char 'e'
[integer pointer] points to 0xbffff818, which contains the char '8'
[integer pointer] points to 0xbffff81c, which contains the char '
[integer pointer] points to 0xbffff820, which contains the char '?'
[char pointer] points to 0xbffff7f0, which contains the integer 1
[char pointer] points to 0xbffff7f1, which contains the integer 0
[char pointer] points to 0xbffff7f2, which contains the integer 0
[char pointer] points to 0xbffff7f3, which contains the integer 0
[char pointer] points to 0xbffff7f4, which contains the integer 2

Even though the int_pointer points to character data that only contains 5 bytes of data, it is still typed as an integer
This means that adding 1 to the pointer will increase the address by 4 each time
Similarly, the char_pointer's address is only increased by 1 each time, stepping through the 20 bytes of integer data(five 4-bytes integers), one byte at a time
Once again, the little-endian byte order of the integer data is apparent when the 4-byte integer is examined one byte at a time
The 4-byte value of 0x00000001 is actually stored in the memory as 0x01, 0x00, 0x00, 0x00

Typecastin is just a way to change the type of a variable on the fly

pointer_types3.c
_____________________________________________________________________________
#include <stdio.h>

int main() {
    int i;

    char char_array[5] = {'a'. 'b'. 'c'. 'd'. 'e'};
    int int_array[5] = {1, 2, 3, 4, 5};

    char *char_pointer;
    int *int_pointer;

    char_pointer = (char *) int_array; //Typcast into the 
    int_pointer = (int *) char_array; //pointer's data type

    for(i = 0; i < 5; i++){ //Iterate through the int array with the int_pointer
        printf("[integer pointer] points to %p, which contains the char '%c'\n", int_pointer, *int_pointer);
        int_pointer =(int *) ((char *) int_pointer + 1);
    }

    for(i = 0; i < 5; i++){ //Iterate through the char array with the char_pointer
        printf("[char pointer] points to %p, which contains the integer %d\n", char_pointer, *char_pointer);
        char_pointer = (char *) ((int *) char_pointer + 1);
    }
}

In this code, when the pointers are initially set, the data is typecasted into the pointer's data type
This prevents the C compiler from complaining about the conflicting data types; however, any pointer arithmetic will still be incorrect
To fix that, when 1 is added to the pointers, they are first type-casted into the correct data type so that the address is incremented by the correct amount
Then this pointer needs to be typecast back into the pointer's data type once again
Example:
      integer pointer points to 0xbffff810, which contains character a
      int_pointer + 1 = 0xbffff814
      char *(int_pointer + 1) = 0xbffff811 //This is a char pointer(1 byte)
      What is happening is:
               (char *) int_pointer + (char *) 1
      int *(char *(int_pointer + 1)) = 0xbffff811 //This is an int pointer(4 bytes)

reader@hacking:~/booksrc $ gcc pointer_types3.c
reader@hacking:~/booksrc $ ./a.out
[integer pointer] points to 0xbffff810, which contains the char  'a'
[integer pointer] points to 0xbffff811, which contains the char  'b'
[integer pointer] points to 0xbffff812, which contains the char  'c'
[integer pointer] points to 0xbffff813, which contains the char  'd'
[integer pointer] points to 0xbffff814, which contains the char  'e'
[char pointer] points to 0xbffff7f0, which contains the integer  1
[char pointer] points to 0xbffff7f4, which contains the integer  2
[char pointer] points to 0xbffff7f8, which contains the integer  3
[char pointer] points to 0xbffff7fc, which contains the integer  4
[char pointer] points to 0xbffff800, which contains the integer  5

It is far easier to just to use the correct data type for pointers in the first place; sometimes a generic, typeless pointer is desired
In C, a void pointer is a typeless pointer, defined by the void keyword
Experimenting with void pointers quickly reveals a few things about typeless pointers
First, pointers cannot be dereferenced unless they have a type
In orde to retreive the value stored in the pointer's memory address, the compiler must first know what type of data it is
Secondly, void pointers must also be typecast before doing pointer arithmetic
These are fairly inttuitive limitations, which means a void pointer's main purpose is to simply hold a memory address

We modify the pointer_3c. program can be modified to use a single void pointer by typecasting it to the proper tyoe each time it's used
The compiler knows that a void pointer is typeless, so any type of pointer can be stored in a void pointer without typecasting
This also means a void pointer must always be typecast when dereferencing it

pointer_types4.c
__________________________________________________________________________________________
#include <stdio.h>

int main() {
	int i;

	char char_array[5] = {'a'. 'b'. 'c'. 'd'. 'e'};
	int int_array[5] = {1, 2, 3, 4, 5};

	void *void_pointer;

	void_pointer = (void *) char_array;

	for(i = 0; i < 5; i++){ //Iterate through the int array with the int_pointer
		printf("[char pointer] points to %p, which contains the char '%c'\n", void_pointer, *((char *) void_pointer));
		void_pointer = (void *) ((char *) void_pointer + 1);
	}

	void_pointer = (void *) int_array;

	for(i = 0; i < 5; i++){ //Iterate through the int array with the int_pointer
		printf("[integer pointer] points to %p, which contains the integer %d\n", void_pointer, *((int *) void_pointer));
		void_pointer = (void *) ((int *) void_pointer + 1);
	}
}

reader@hacking:~/booksrc $ \\\gcc pointer_types4.c
reader@hacking:~/booksrc $ \\\./a.out
[char pointer] points to 0xbffff810, which contains the char 'a'
[char pointer] points to 0xbffff811, which contains the char 'b'
[char pointer] points to 0xbffff812, which contains the char 'c'
[char pointer] points to 0xbffff813, which contains the char 'd'
[char pointer] points to 0xbffff814, which contains the char 'e'
[integer pointer] points to 0xbffff7f0, which contains the integer 1
[integer pointer] points to 0xbffff7f4, which contains the integer 2
[integer pointer] points to 0xbffff7f8, which contains the integer 3
[integer pointer] points to 0xbffff7fc, which contains the integer 4
[integer pointer] points to 0xbffff800, which contains the integer 5

The compilation and output of this program is basically the same as the pointer_types3
The void pointer is really just holding the memory addresses, while the hard-coded typecasting is telling the compiler to use proper types whenever the pointer is used

Since the type is taken care of by the typecasts, the void pointer is truly nothing more than a memory address
With the data types defined by type-casting, anything that is big enough to hold a four-byte value can work the same way as a void pointer

Using usigned integer to store the address
pointer_types5.c
__________________________________________________________________________________________
#include <stdio.h>

int main() {
	int i;

	char char_array[5] = {'a'. 'b'. 'c'. 'd'. 'e'};
	int int_array[5] = {1, 2, 3, 4, 5};

	unsigned int hacky_nonpointer;

	hacky_nonpointer = (unsigned int) char_array;

	for(i = 0; i < 5; i++){ //Iterate through the int array with the int_pointer
		printf("[hacky_nonpointer] points to %p, which contains the char '%c'\n", hacky_nonpointer, *((char *) hacky_nonpointer));
		hacky_nonpointer = hacky_nonpointer + sizeof(char);
	}

	hacky_nonpointer = (unsigned int) int_array;

	for(i = 0; i < 5; i++){ //Iterate through the int array with the int_pointer
		printf("[hacky_nonpointer] points to %p, which contains the integer %d\n", hacky_nonpointer, *((int *) hacky_nonpointer));
		hacky_nonpointer = hacky_nonpointer + sizeof(int);
	}
}

Here, the integer value is typecast into the proper pointer types when it is assigned and dereferenced, the end result is the same
Instead of typecasting multiple times to do pointer arithmetic on an unsigned integer(which isn't even a pointer), the sizeof() function is used to achieve the same result using normal arithmetic

reader@hacking:~/booksrc $ \\\gcc pointer_types5.c
reader@hacking:~/booksrc $ \\\./a.out
[hacky_nonpointer] points to 0xbffff810, which contains the char 'a'
[hacky_nonpointer] points to 0xbffff811, which contains the char 'b'
[hacky_nonpointer] points to 0xbffff812, which contains the char 'c'
[hacky_nonpointer] points to 0xbffff813, which contains the char 'd'
[hacky_nonpointer] points to 0xbffff814, which contains the char 'e'
[hacky_nonpointer] points to 0xbffff7f0, which contains the integer 1
[hacky_nonpointer] points to 0xbffff7f4, which contains the integer 2
[hacky_nonpointer] points to 0xbffff7f8, which contains the integer 3
[hacky_nonpointer] points to 0xbffff7fc, which contains the integer 4
[hacky_nonpointer] points to 0xbffff800, which contains the integer 5

The important thing to remember about variables in C is that the compiler is the only thing that cares about a variable's type
In the end, after the program has been compiled, the variables are nothing more than memory addresses
This means that variables of one type can easily be coerced into behaving like another type by telling the compiler to typecast them into the desired type