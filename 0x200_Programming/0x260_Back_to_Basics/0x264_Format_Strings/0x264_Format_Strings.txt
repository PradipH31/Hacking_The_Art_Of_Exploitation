The printf function can print more than just fixed strings
It can also use format strings to print variables in many different forms
A format string is just a character string with special escape sequences that tell the function to insert variables printed in a specific format in place of the escape sequence
The way the printf() function has been used in the previous programs, the "Hello, world!\n" string technically is the format string, but is devoid of special escape sequences
These escape sequences are also called format parameters, and for each one found in the format string, the function is expected to take an additional argument
Each format parameter begins with a percent sign(%) and uses a single-character shorthand very similar to formatting characters used by GDB's examine command

Parameter     Output Type 
%d            Decimal 
%u            Unsigned decimal 
%x            Hexadecimal 

All the preceding format parameters receiev their data as values, not pointers to values
There are some format pointers that expect pointers such as the following

Parameter     Output Type 
%s            String
%n            Number of bytes written so far

The %s format parameter expects to be given a memory address; it prints the data at that memory address until a null byte is encountered
The %n format is unique in that it actually writes data
It also expects to be given a memory address, and writes the number of bytes that have been written so far into that memory address

Different format parameters in C;
fmt_strings.c
___________________________________________________________________
#include <stdio.h>

int main() {
    char string[0];
    int A = -73;
    unsigned int B = 31337;

    strcpy(string, "sample");
    //Printing data with different format string
    printf("[A] Dec: %d, Hex: %x, Unsigned: %u\n", A, A, A);
    printf("[B] Dec: %d, Hex: %x, Unsigned: %u\n", B, B, B);
    printf("[field width on B] 3: '%3u', 10: '%10u, '%08u''n", B, B, B);
    printf("[String] %s Address %08x\n", string, string);

    //Example of unary address operator (dereferencing) and a %x format string
    printf("variable A is at address: %08x\n", &A);
}

reader@hacking:~/booksrc $ \\\gcc -o fmt_strings fmt_strings.c
reader@hacking:~/booksrc $ \\\./fmt_strings
[A] Dec: -73, Hex: ffffffb7, Unsigned: 4294967223
[B] Dec: 31337, Hex: 7a69, Unsigned: 31337
[field width on B] 3: '31337', 10: '
 31337', '00031337'
[string] sample Address bffff870
variable A is at address: bffff86c

The first two calls to printf() print the variables A and B, using different format parameters
Since there are three format parameters in each line, the variables A and B needed to be supplied three times each
The %d format parameter allows for negative values, while %u does not, since it is expecting unsigned values

When the variable A is printed using the %u format parameter, it appears at a very high value
This is because A is a negative number stored in two's complement and the format parameter is trying to print it as if it were an unsigned value
If A were 73, it would be stored as 00000000000000000000000001001001, but as it -73, it is stored as 11111111111111111111111110110111(reversing the bits and adding 1) which is 4294967223(you can get this by subtracting 73 from 32bit-binariy converted to decimal)

The third line in the example, labeled [filed width on B] shows the use of field-width option in a format parameter
This is just an integer that designates the minimum filed width for that format parameter
However, this is not a maximum field-widht, if the value of output is greater than the field width, the field width will be exceeded
This happens when 3 is used, since the output data needs 5 bytes
When 10 is used as the field width, 5 bytes of blank space are outputted before the output data
If a field width begins with 0, this means the field should be padded with zeroes
When 08 is used for example, the output is 001337

The fourth line labeled [string], shows the use of %s format parameter
The variable string is actually a pointer containing the address of the string, which works out well, since the %s format parameter expects its data to be passed by reference

The final line just shows the address of the variable A, using the unary address operator to dereference the variable
This value is displayed as eight hexadecimal digits, padded by zeroes(beacuse of the format parameter)

Summary:
     %d for decimal, %u for unsigned, %x for hexadecimal
     putting a number right after % sets the minimum field width
     if field width begins with 0, it will be padded with zeroes
     %s for strings and should be passed the address of string


Format strings are used by an entire family of I/O functions, including scanf(), which works like printf() but is used for input instead of output
scanf() expects all of its arguments to be pointers, so arguments must be variable addresses, not the variables themselves
This can be done by using pointer variables or unary address operator

Using scanf
input.c
____________________________________________________________________
#include <stdio.h>
#include <string.h>

int main() {
    char message[10];
    int count, i;

    strcpy(message, "Hello, world!");

    printf("Repeat how many times?");
    scanf("%d", &count);

    for(i=0; i < count; i++)
        printf("%3d - %s\n", i, message);
}

We use the scanf() function to set the count variable

reader@hacking:~/booksrc $ \\\gcc -o input input.c
reader@hacking:~/booksrc $ \\\./input
Repeat how many times? \\\3
0 - Hello, world!
1 - Hello, world!
2 - Hello, world!

Format strings are used quite often, so familiarity with them is valuable
The ability to output the values of variables allows for debugging without the use of a debugger
Having some form of immediate feedback is fairly vital to hacekr's learning process and printing a variable can allow lots of exploitation