The value "Hello, world!\n" passed to printf() in the previous program is a string, technically a character array
In C, an array is simply a list of n elements of a specific data type
A 20-character array is simply 20 adjacent characters located in memory
Arrays are also referred to as buffers
The char_array.c program is an example of a character array

char_array.c
____________________________________________________
#include <stdio.h>
int main()
{
    char_str_a[20];
    str_a[0] = 'H';
    str_a[1] = 'e';
    str_a[2] = 'l';
    str_a[3] = 'l';
    str_a[4] = 'o';
    str_a[5] = ',';
    str_a[6] = ' ';
    str_a[7] = 'w';
    str_a[8] = 'o';
    str_a[9] = 'r';
    str_a[10] = 'l';
    str_a[11] = 'd';
    str_a[12] = '!';
    str_a[13] = '\n';
    str_a[14] = 0;
    printf(str_a);
}


The GCC compiler can also be given the -o switch to define the output file
\\\gcc -o char_array char_array.c
\\\./char_array
Hello, World

In the above program, a 20-element character array is defined as str_a and each element of array is written to
The number begins at 0, as opposed to 1
The last character is a 0(called a null byte
The character array was defined, so 20 bytes are allocated for it, but only 12 of these bytes are used
The null byte at the end is used as a delimiter character to tell any function that is dealing with the string to stop operations right there
The remaining characters will be ignored
If a null byte is inserted in fifth element of the array, only Hello would be printed

Setting each character in a character array is painstaking & strings are used fairly often, a set of standard functions was created for string manipulation
Function strcopy() will copy a strnig form a source to a destinaiton, iterating through the source string and copying each byte to the destination(stopping after copying the null termination byte)
The order of the funciton's argument is similar to Intel assembly syntax: destination first and then source

Rewriting char_array.c using strcopy()
char_array2.c
______________________________________________
#include <stdio.h>
#include <string.h>

int main(){
    char str_a[20];

    strcpy(str_a, "Hello, world!\n");
    printf(str_a);
}

Using GDB on char_array2.c:

\\\gcc -g -o char_array2 char_array2.c
\\\gdb -q ./char_array2
Using host libthread_db library "/lib/tls/i686/cmov/libthread_db.so.1".
(gdb) \\\list
1    #include <stdio.h>
2    #include <string.h>
3
4    int main() {
5        char str_a[20];
6
7        strcpy(str_a, "Hello, world!\n");
8        printf(str_a);
9    }
(gdb) \\\break 6
Breakpoint 1 at 0x80483c4: file char_array2.c, line 6.
(gdb) \\\break strcpy
Function "strcpy" not defined.
Make breakpoint pending on future shared library load? (y or [n]) \\\y
Breakpoint 2 (strcpy) pending.
(gdb) \\\break 8
Breakpoint 3 at 0x80483d7: file char_array2.c, line 8.

We compile the program and open with GDB and set breakpoints before, in and after the strcpy() call
The debugger will pause the program at each breakpoint allowing us to examine registers and memory
The strcpy() function's code comes from a shared library, so the breakpoint in this function can't actually be set until the program is executed
When we run the program, the strcpy() breakpoint is resolved

(gdb) \\\run
Starting program: /home/reader/booksrc/char_array2
Breakpoint 4 at 0xb7f076f4
Pending breakpoint "strcpy" resolved
Breakpoint 1, main () at char_array2.c:7
7          strcpy(str_a, "Hello, world!\n");
(gdb) \\\i r eip
eip       0x80483c4         0x80483c4 <main+16>
(gdb) \\\x/5i $eip
0x80483c4 <main+16>:      mov      DWORD PTR [esp+4],0x80484c4 
0x80483cc <main+24>:      lea      eax,[ebp-40] 
0x80483cf <main+27>:      mov      DWORD PTR [esp],eax 
0x80483d2 <main+30>:      call     0x80482c4 <strcpy@plt> 
0x80483d7 <main+35>:      lea      eax,[ebp-40] 
(gdb) \\\continue
Continuing.

Breakpoint 4, 0xb7f076f4 in strcpy () from /lib/tls/i686/cmov/libc.so.6
(gdb) \\\i r eip
eip      0xb7f076f4      0xb7f076f4 <strcpy+4> 
(gdb) \\\x/5i $eip
0xb7f076f4 <strcpy+4>:      mov      esi,DWORD PTR [ebp+8] 
0xb7f076f7 <strcpy+7>:      mov      eax,DWORD PTR [ebp+12] 
0xb7f076fa <strcpy+10>:     mov      ecx,esi 
0xb7f076fc <strcpy+12>:     sub      ecx,eax 
0xb7f076fe <strcpy+14>:     mov      edx,eax 
(gdb) \\\continue
Continuing.

Breakpoint 3, main () at char_array2.c:8
8              printf(str_a);
(gdb) \\\i r eip
eip      0x80483d7      0x80483d7 <main+35>
(gdb) \\\x/5i $eip
0x80483d7 <main+35>:      lea      eax,[ebp-40] 
0x80483da <main+38>:      mov      DWORD PTR [esp],eax 
0x80483dd <main+41>:      call     0x80482d4 <printf@plt> 
0x80483e2 <main+46>:      leave     
0x80483e3 <main+47>:      ret     

The address in EIP at the middle breakpoint is different beacuse the code for strcpy() function comes form a loaded binary
In fact, the debugger shows EIP for the middle breakpoint in strcpy() fucntion, while EIP of other two brekapoints is in main function
EIP is able to travel from main code to strcpy() code and back again
--\\Each time a function is called, a record is kept on a data structure simply called the stack
The stack lets EIP return through long chains of function calls

Backtracing the stack at each breakpoint in GDB:

(gdb) \\\break 6
Breakpoint 1 at 0x80483c4: file char_array2.c, line 6.
(gdb) \\\break strcpy
Function "strcpy" not defined.
Make breakpoint pending on future shared library load? (y or [n]) \\\y
Breakpoint 2 (strcpy) pending.
(gdb) \\\break 8
Breakpoint 3 at 0x80483d7: file char_array2.c, line 8.
(gdb) \\\run
Breakpoint 1, main () at char_array2.c:7
7             strcpy(str_a, "Hello, world!\n");
(gdb) \\\bt
#0 main () at char_array2.c:7
(gdb) \\\cont
Continuing.

Breakpoint 4, 0xb7f076f4 in strcpy () from /lib/tls/i686/cmov/libc.so.6
(gdb) \\\bt
#0 0xb7f076f4 in strcpy () from /lib/tls/i686/cmov/libc.so.6
#1 0x080483d7 in main () at char_array2.c:7
(gdb) \\\cont
Continuing.

Breakpoint 3, main () at char_array2.c:8
8             printf(str_a);
(gdb) \\\bt
#0 main () at char_array2.c:8

At the middle breakpoint, the backtrace of stack shows its record of strcpy() call
Also, the strcpy() function is at a slightly different address during the second time
This is due to an exploit protection method turned on by default in Linux kernel since 2.6.11