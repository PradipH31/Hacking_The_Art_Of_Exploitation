Since we will be using Intel syntax assembly language for this book, our programs must be configured to use Intel syntax

Setting GDB to use Intel syntax
gdb -q
set dis intel
Configuring gdb to use Intel syntax everytime GDB starts up
echo "set dis intel" > ~/.gdbinit

Understanding Intel Assembly Language
Assembly instructions in Intel syntax generally follow this style
    operation <destination>, <source>

The destination and source values will be a register, or a memory address, or a value
The oprations are usually intuitive mnemonics: 
    mov operation will move a value form source to destination
    sub will subtract
    inc will increment, etc

8048375:    89 e5          mov   ebp,esp
8048377:    83 ec 08       sub   esp,0x8
The instructions above will move the value from ESP to EBP and then subtract 8 from ESP(storing the result in ESP)

Controlling the flow of execution
The cmp operation is used to compare values
Any operation beginning with j is used to jump to a different part of code

804838b:     83 7d fc 09     cmp     DWORD PTR [ebp-4],0x9 
804838f:     7e 02           jle     8048393 <main+0x1f> 
8048391:     eb 13           jmp     80483a6 <main+0x32> 
The instructions above will first compare a 4-byte value located at EPB-4 with 9
The next instruction jle(jump if less than or equal to), refers to the result of the previous comparison
If that value is less than or equal to 9
    execution jumps to the instruction at 0x8048393
Otherwise
    execution flows to next instruction with an unconditional jump
If the value isn't less than or equal to 9, execution will jump to 0x80483a6

Using the debugger to step through the first program at the assembly instruction level
GCC with -g flag will include extra debugging information, giving GDB access to the source code

-------------In the terminal------------
gcc -g firstprog.c
gdb -q ./a.out
Using host libthread_db library "/lib/libthread_db.so.1".
(gdb) \\\list\\\
1    #include <stdio.h>
2  
3    int main()
4    {
5    int i;
6    for(i=0; i < 10; i++)
7    {
8    printf("Hello, world!\n");
9    }
10   }
(gdb) disassemble main
Dump of assembler code for function main():
0x08048384 <main+0>:     push      ebp 
0x08048385 <main+1>:     mov       ebp,esp 
0x08048387 <main+3>:     sub       esp,0x8 
0x0804838a <main+6>:     and       esp,0xfffffff0 
0x0804838d <main+9>:     mov       eax,0x0 
0x08048392 <main+14>:    sub       esp,eax 
0x08048394 <main+16>:    mov       DWORD PTR [ebp-4],0x0 
0x0804839b <main+23>:    cmp       DWORD PTR [ebp-4],0x9 
0x0804839f <main+27>:    jle       0x80483a3 <main+31> 
0x080483a1 <main+29>:    jmp       0x80483b6 <main+50> 
0x080483a3 <main+31>:    mov       DWORD PTR [esp],0x80484d4 
0x080483aa <main+38>:    call      0x80482a8 <_init+56> 
0x080483af <main+43>:    lea       eax,[ebp-4] 
0x080483b2 <main+46>:    inc       DWORD PTR [eax] 
0x080483b4 <main+48>:    jmp       0x804839b <main+23> 
0x080483b6 <main+50>:    leave
0x080483b7 <main+51>:    ret
End of assembler dump.
(gdb) \\\break main\\\
Breakpoint 1 at 0x8048394: file firstprog.c, line 6.
(gdb) \\\run\\\
Starting program: /hacking/a.out
Breakpoint 1, main() at firstprog.c:6
6
 for(i=0; i < 10; i++)
(gdb) \\\info register eip\\\
eip     0x8048394     0x8048394

First, we list the code and disassemble the main() function
Then we set a breakpoint at the start of main() and run the program
The breakpoint simply tells the debugger to pause execution of program when it gets to that point
With the breakpoint set at start of main() function, the program hits the breakpoint and pauses before actually executing the main() function
Then, we display the value of EIP(Instruction Pointer)

EIP contains a memory address that points to an instruction in the main() function's disassembly
0x08048394 <main+16>:    mov       DWORD PTR [ebp-4],0x0 
The instructions before this are collectively known as function prologue and generated by compiler to set up memory for rest of the main() function's local variables
The reason for declaring variables in C is to aid the construction of this section of code
The debugger knows this part of the code is automatically generated and skips over it

Examining memory is a critical skill for any hacker
Since a running program is mostly just a processor and segments of memory, examining memory is the first way to look at what's really going on
The GDB debugger lets you directly examine a memory, using the command |x|(examine)
It expects two arguments when used:
  the location in memory to examine
  how to display the memory
    The display format alos uses single-letter shorthand, optionally preceded by a count of how many items to examine
    Some format letters are
      o    Display in octal
      x    Display in hexadecimal
      u    Display in unsigned, standard base-10 decimal
      t    Display in binary
Shothand commands are often used in GDB
info register eip can be shortened to i r eip

-------------In the terminal------------
(gdb) \\\i r eip\\\
eip     0x8048394     0x8048394
(gdb) \\\x/o 0x8048384\\\
0x8048384 <main+16>:     077042707
(gdb) \\\x/x $eip\\\
0x8048384 <main+16>:     0x00fc45c7
(gdb) \\\x/u $eip\\\
0x8048384 <main+16>:     16532935
(gdb) \\\x/t $eip\\\
0x8048384 <main+16>:     00000000111111000100010111000111

The memory pointed by the EIP register can be examined by using its address
The debugger lets you reference the registers directly, so $eip is equivalent to the value EIP contains at that moment(0x8048384)
We examine the memory, which is a 4-byte unit, contained in the address of the EIP register in octal, hexadecimal, decimal and binary system
Prepending numbers to the format of examine to examine multiple units at target address

-------------In the terminal------------
(gdb) \\\x/2x $eip\\\
0x8048384 <main+16>:   0x00fc45c7   0x83000000
(gdb) \\\x/12x $eip\\\
0x8048384 <main+16>:   0x00fc45c7   0x83000000   0x7e09fc7d   0xc713eb02
0x8048394 <main+32>:   0x84842404   0x01e80804   0x8dffffff   0x00fffc45
0x80483a4 <main+48>:   0xc3c9e5eb   0x90909090   0x90909090   0x5de58955

The default size of a single unit is a four-byte unit called a word
To better understand the above ouput and the statement, view the memory in binary

-------------In the terminal------------
gdb) \\\x/2t $eip\\\
0x8048384 <main+16>:   00000000111111000100010111000111   10000011000000000000000000000000

The default size of a single unit is a four-byte unit called a word
The size of display units for the examine command can be changed by adding a size letter to end of the format letter. Valid size letters:
    b    A single byte
    h    A halfword, two bytes in size
    w    A word, four bytes in size
    g    A giant, eight bytes in size
This is slightly confusing as sometimes word also refers to 2-byte values and double word /DWORD refers to 4-byte values
In this project, DWOR and word both refer to 4-byte values and short and halfword refer to 2-byte value

Showing outputs in various sizes
-------------In the terminal------------
(gdb) \\\x/8xb $eip\\\
0x8048384 <main+16>:   0xc7     0x45     0xfc     0x00     0x00     0x00     0x00     0x83
(gdb) \\\x/8xh $eip\\\
0x8048384 <main+16>:   0x45c7   0x00fc   0x0000   0x8300   0xfc7d   0x7e09   0xeb02   0xc713
(gdb) \\\x/8xw $eip\\\
0x8048384 <main+16>:   0x00fc45c7   0x83000000   0x7e09fc7d   0xc713eb02
0x8048394 <main+32>:   0x84842404   0x01e80804   0x8dffffff   0x00fffc45

Observing the data above, the first examine shows the first two bytes of data to be 0xc7 and 0x45, but when a halfword is examined at the same memory address, the value 0x45c7, which is the bytes reversed
The same byte reversal can be seen when a four-byte word is shown as 0x00fc45c7, but when the bytes are shown byte by byte, they are in the order: 0xc7, 0x45, 0xfc and 0x00
This is because on x86 processor values are stored in little-endian byte order, which means the least significant byte is stored first
If more than 1 bytes are to be used as a single value, the bytes must be used in reverse oder

What happens is that the processor stores the data in reverse order and it reads it in the same way
Viewing these values as hexadecimal and unsigned decimals
(gdb) x/4xb $eip
0x8048384 <main+16>:    0xc7    0x45    0xfc    0x00
(gdb) x/4ub $eip
0x8048384 <main+16>:    199    69    252    0
(gdb) x/1xw $eip
0x8048384 <main+16>:    0x00fc45c7
(gdb) x/1uw $eip
0x8048384 <main+16>:    16532935
(gdb) quit
The program is running. Exit anyway? (y or n) y
reader@hacking:~/booksrc $ bc -ql
199*(256^3) + 69*(256^2) + 252*(256^1) + 0*(256^0)
3343252480
0*(256^3) + 252*(256^2) + 69*(256^1) + 199*(256^0)
16532935

The first four bytes are shown in hex and decimal notation
bc(command-line calculator) shows that if bytes are interpreted incorrectly, incorrect value is generated
The byte order of given architecture is important to be aware of

The examine(x) command also accepts the format letter i, short for instruction, to display the memory as disassembled assembly language instructions

-------------In the terminal------------
\\\gdb -q ./a.out\\\
Using host libthread_db library "/lib/tls/i686/cmov/libthread_db.so.1".
(gdb) \\\break main\\\
Breakpoint 1 at 0x8048384: file firstprog.c, line 6.
(gdb) \\\run\\\
Starting program: /home/reader/booksrc/a.out
Breakpoint 1, main () at firstprog.c:6
6
 for(i=0; i < 10; i++)
(gdb) \\\i r $eip\\\
eip        0x8048384        0x8048384 <main+16>
(gdb) \\\x/i $eip\\\
0x8048384 <main+16>:   mov   DWORD PTR [ebp-4],0x0
(gdb) \\\x/3i $eip\\\
0x8048384 <main+16>:   mov   DWORD PTR [ebp-4],0x0
0x804838b <main+23>:   cmp   DWORD PTR [ebp-4],0x9
0x804838f <main+27>:   jle   0x8048393 <main+31>
(gdb) \\\x/7xb $eip\\\
0x8048384 <main+16>:   0xc7   0x45   0xfc   0x00   0x00   0x00   0x00
(gdb) \\\x/i $eip\\\
0x8048384 <main+16>:   mov   DWORD PTR [ebp-4],0x0

In the output above, its the fucking same as all above examples until (i)
Since the EIP register is pointing to memory that contains machine language instructions, they disassemble easily

0x8048384 <main+16>:   mov   DWORD PTR [ebp-4],0x0

This assembly instruction will move the value 0 into memory located at the address stored in EBP register -4, where the i variable is stored in memory
So, this command sets the value of i to 0 for the for loop
Right now, if that memory is examined, it will contain nowhting but random garbage
Examining the memory at this location(EBP-4)

-------------In the terminal------------
(gdb) \\\i r ebp\\\
ebp        0xbffff808        0xbffff808
(gdb) \\\x/4xb $ebp - 4\\\
0xbffff804:    0xc0    0x83    0x04    0x08
(gdb) \\\x/4xb 0xbffff804\\\
0xbffff804:    0xc0    0x83    0x04    0x08
(gdb) \\\print $ebp - 4\\\
$1 = (void *) 0xbffff804
(gdb) \\\x/4xb $1\\\
0xbffff804:    0xc0    0x83    0x04    0x08
(gdb) \\\x/xw $1\\\
0xbffff804:        0x080483c0

The EBP register contains the address 0xbffff808 and the assembly isntruction will write to a value offset by 4 less than that, 0xbffff804
We examine this memory address using the examine command or using maths on the fly
The print command can also be used, but the result will be stored in a temporary varaible in debugger
The variable, named $1, can be used later to access that memory address
All the methods above accomplish the same task, displaying the 4 garbage bytes found in memory which is a placeholder for variable i

-------------In the terminal------------
(gdb) \\\nexti\\\
0x0804838b     6     for(i=0; i < 10; i++)
(gdb) \\\x/4xb $1\\\
0xbffff804:     0x00     0x00     0x00     0x00
(gdb) \\\x/dw $1\\\
0xbffff804:     0
(gdb) \\\i r eip\\\
eip        0x804838b        0x804838b <main+23>
(gdb) \\\x/i $eip\\\
0x804838b <main+23>:      cmp      DWORD PTR [ebp-4],0x9

Executing the current instruction using command nexti(next instruction)
The processor reads the instruction at EIP, executes it and advances EIP to next instruction
The command has zeroed out the 4 bytes at EBP-4(variable i)

-------------In the terminal------------
(gdb) \\\x/10i $eip\\\
0x804838b <main+23>:    cmp     DWORD PTR [ebp-4],0x9 
0x804838f <main+27>:    jle     0x8048393 <main+31> 
0x8048391 <main+29>:    jmp     0x80483a6 <main+50> 
0x8048393 <main+31>:    mov     DWORD PTR [esp],0x8048484 
0x804839a <main+38>:    call    0x80482a0 <printf@plt> 
0x804839f <main+43>:    lea     eax,[ebp-4] 
0x80483a2 <main+46>:    inc     DWORD PTR [eax] 
0x80483a4 <main+48>:    jmp     0x804838b <main+23> 
0x80483a6 <main+50>:    leave    
0x80483a7 <main+51>:    ret    

The first instruction, cmp, is a compare instruction, which compares the memory used by the C variable i with the value 9
The next instruction, jle(jump if less than or equal to), uses the result of previous comparison(stored in EFLAGS register) to jump EIP to point at different memory address if the destination of the previous comparison operation is less than or equal to the source
In this case, instruction says to jump to 0x8048393 if the value in memory for C variable i is less than or equal to 9
If this isn't the case, EIP will continue to the next instruction, an unconditional jump
This causes EIP to jump to 0x80483a6
-------These 3 instructions combine to create an if-else structure-------

-------------In the terminal------------
(gdb) \\\nexti\\\
0x0804838f      6      for(i=0; i < 10; i++)
(gdb) \\\x/i $eip\\\
0x804838f <main+27>:     jle     0x8048393 <main+31>
(gdb) \\\nexti\\\
8       printf("Hello, world!\n");
(gdb) \\\i r eip\\\
eip      0x8048393      0x8048393 <main+31>
(gdb) \\\x/2i $eip\\\
0x8048393 <main+31>:     mov      DWORD PTR [esp],0x8048484
0x804839a <main+38>:     call     0x80482a0 <printf@plt>

After executing the next two instructions, EIP should be at 0x8048393, which is true

-------------In the terminal------------
(gdb) i r esp
esp        0xbffff800        0xbffff800

The next instruction is another mov instruction that will write the address 0x8048484 into the memory address contained in the ESP register (just makes ESP point to the address 0x8048484)
Currently, ESP points to memory address 0xbffff800
When the mov instruction is executed, the address 0x8048484 will be written there

Examining the value at address 0x8048484

-------------In the terminal------------
(gdb) x/2xw 0x8048484
0x8048484:        0x6c6c6548        0x6f57206f
(gdb) x/6xb 0x8048484
0x8048484:    0x48    0x65    0x6c    0x6c    0x6f    0x20
(gdb) x/6ub 0x8048484
0x8048484:    72    101    108    108    111    32

A trained eye in memory examination will know that these bytes fall within the printable ASCII range
ASCII maps characters on keyboard and not on keyboard to fixed numbers
Bytes 0x48, 0x65, 0x6c and 0x6f correspond to letters in alphabet on ASCII table
----View ASCII table with man ascii--------

The GDB examine command with the c format letter looks up a byte on ASCII table and s format letter displays an entire string of character data

-------------In the terminal------------
(gdb) \\\x/6cb 0x8048484\\\
0x8048484:      72 'H' 101 'e' 108 'l' 108 'l' 111 'o' 32 ' '
(gdb) \\\x/s 0x8048484\\\
0x8048484:     "Hello, world!\n"

These commands reveal that string "Hello, world!\n" is stored at memory address 0x8048484
This string is the argument for printf() function

-------------In the terminal------------
(gdb) \\\x/xw $esp\\\
0xbffff800:       0xb8000ce0
(gdb) nexti
0x0804839a        8        printf("Hello, world!\n");
(gdb) \\\x/xw $esp\\\
0xbffff800:       0x08048484

The next instruction is called the printf() function; it prints the data string
The previous instruction was setting up for the function call
Seeing the results of function call:

-------------In the terminal------------
(gdb) \\\x/i $eip\\\
0x804839a <main+38>:      call      0x80482a0 <printf@plt>
(gdb) \\\nexti\\\
Hello, world!
6      for(i=0; i < 10; i++)

Examining next two instructions:

-------------In the terminal------------
(gdb) \\\x/2i $eip\\\
0x804839f <main+43>:    lea    eax,[ebp-4]
0x80483a2 <main+46>:    inc    DWORD PTR [eax]

These two instructions collectively increment the variable i by 1
The lea instruction is an acronym for Load Effective Address, which will load the familiar address of EBP-4 into the EAX register

-------------In the terminal------------
(gdb) \\\x/i $eip\\\
0x804839f <main+43>:    lea    eax,[ebp-4]
(gdb) \\\i r eax\\\
eax        0xd        13
(gdb) \\\nexti\\\
0x080483a2    6    for(i=0; i < 10; i++)
(gdb) \\\i r eax\\\
eax        0xbffff804        -1073743868
(gdb) \\\x/xw $eax\\\
0xbffff804:       0x00000000
(gdb) \\\x/dw $eax\\\
0xbffff804:       0

The following instruction will increment the value found at 0xbffff804(now stored in EAX register) by 1

-------------In the terminal------------
(gdb) \\\x/i $eip\\\
0x80483a2 <main+46>:      inc      DWORD PTR[eaxx]
(gdb) \\\x/dw $eax\\\
0xbffff804:        0
(gdb) \\\nexti\\\
0x080483a4         6         for(i=0; i < 10; i++)
(gdb) \\\x/dw $eax\\\
0xbffff804:         1
(gdb) \\\x/i $eip\\\
0x80483a4 <main+48>:     jmp        0x804838b <main+23>

The end result is the value stored at the memory address EBP-4(0xbffff804) is incremented by 1
This is the i++ of the C code
The next instruction is an unconditional jump, sending program back to instruction at 0x804838b by setting EIP to that value

Looking at full disassmebly:

-------------In the terminal------------
(gdb) \\\disass main\\\
Dump of assembler code for function main:
0x08048374 <main+0>:    push    ebp
0x08048375 <main+1>:    mov    ebp,esp
0x08048377 <main+3>:    sub    esp,0x8
0x0804837a <main+6>:    and    esp,0xfffffff0
0x0804837d <main+9>:    mov    eax,0x0
0x08048382 <main+14>:   sub   esp,eax
0x08048384 <main+16>:   mov   DWORD PTR [ebp-4],0x0
0x0804838b <main+23>:   cmp   DWORD PTR [ebp-4],0x9
0x0804838f <main+27>:   jle   0x8048393 <main+31>
0x08048391 <main+29>:   jmp   0x80483a6 <main+50>
0x08048393 <main+31>:   mov   DWORD PTR [esp],0x8048484
0x0804839a <main+38>:   call   0x80482a0 <printf@plt>
0x0804839f <main+43>:   lea   eax,[ebp-4]
0x080483a2 <main+46>:   inc   DWORD PTR [eax]
0x080483a4 <main+48>:   jmp   0x804838b <main+23>
0x080483a6 <main+50>:   leave
0x080483a7 <main+51>:   ret
End of assembler dump.
(gdb) list
1     #include <stdio.h>
2
3     int main()
4     {
5        int i;
6        for(i=0; i < 10; i++)
7        {
8           printf("Hello, world!\n");
9         }
10    }