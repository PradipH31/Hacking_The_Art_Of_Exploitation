Since we will be using Intel syntax assembly language for this book, our programs must be configured to use Intel syntax

Setting GDB to use Intel syntax
gdb -q
set dis intel
Configuring gdb to use Intel syntax everytime GDB starts up
echo "set dis intel" > ~/.gdbinit

Understanding Intel Assembly Language
Assembly instructions in Intel syntax generally follow this style
    operation <destination>, <source>

The destination and source values will be a register, or a memory address, or a value
The oprations are usually intuitive mnemonics: 
    mov operation will move a value form source to destination
    sub will subtract
    inc will increment, etc

8048375:    89 e5          mov   ebp,esp
8048377:    83 ec 08       sub   esp,0x8
The instructions above will move the value from ESP to EBP and then subtract 8 from ESP(storing the result in ESP)

Controlling the flow of execution
The cmp operation is used to compare values
Any operation beginning with j is used to jump to a different part of code

804838b:     83 7d fc 09     cmp     DWORD PTR [ebp-4],0x9 
804838f:     7e 02           jle     8048393 <main+0x1f> 
8048391:     eb 13           jmp     80483a6 <main+0x32> 
The instructions above will first compare a 4-byte value located at EPB-4 with 9
The next instruction jle(jump if less than or equal to), refers to the result of the previous comparison
If that value is less than or equal to 9
    execution jumps to the instruction at 0x8048393
Otherwise
    execution flows to next instruction with an unconditional jump
If the value isn't less than or equal to 9, execution will jump to 0x80483a6

Using the debugger to step through the first program at the assembly instruction level
GCC with -g flag will include extra debugging information, giving GDB access to the source code

-------------In the terminal------------
gcc -g firstprog.c
gdb -q ./a.out
Using host libthread_db library "/lib/libthread_db.so.1".
(gdb) \\\list\\\
1    #include <stdio.h>
2  
3    int main()
4    {
5    int i;
6    for(i=0; i < 10; i++)
7    {
8    printf("Hello, world!\n");
9    }
10   }
(gdb) disassemble main
Dump of assembler code for function main():
0x08048384 <main+0>:     push      ebp 
0x08048385 <main+1>:     mov       ebp,esp 
0x08048387 <main+3>:     sub       esp,0x8 
0x0804838a <main+6>:     and       esp,0xfffffff0 
0x0804838d <main+9>:     mov       eax,0x0 
0x08048392 <main+14>:    sub       esp,eax 
0x08048394 <main+16>:    mov       DWORD PTR [ebp-4],0x0 
0x0804839b <main+23>:    cmp       DWORD PTR [ebp-4],0x9 
0x0804839f <main+27>:    jle       0x80483a3 <main+31> 
0x080483a1 <main+29>:    jmp       0x80483b6 <main+50> 
0x080483a3 <main+31>:    mov       DWORD PTR [esp],0x80484d4 
0x080483aa <main+38>:    call      0x80482a8 <_init+56> 
0x080483af <main+43>:    lea       eax,[ebp-4] 
0x080483b2 <main+46>:    inc       DWORD PTR [eax] 
0x080483b4 <main+48>:    jmp       0x804839b <main+23> 
0x080483b6 <main+50>:    leave
0x080483b7 <main+51>:    ret
End of assembler dump.
(gdb) \\\break main\\\
Breakpoint 1 at 0x8048394: file firstprog.c, line 6.
(gdb) \\\run\\\
Starting program: /hacking/a.out
Breakpoint 1, main() at firstprog.c:6
6
 for(i=0; i < 10; i++)
(gdb) \\\info register eip\\\
eip     0x8048394     0x8048394

First, we list the code and disassemble the main() function
Then we set a breakpoint at the start of main() and run the program
The breakpoint simply tells the debugger to pause execution of program when it gets to that point
With the breakpoint set at start of main() function, the program hits the breakpoint and pauses before actually executing the main() function
Then, we display the value of EIP(Instruction Pointer)

EIP contains a memory address that points to an instruction in the main() function's disassembly
0x08048394 <main+16>:    mov       DWORD PTR [ebp-4],0x0 
The instructions before this are collectively known as function prologue and generated by compiler to set up memory for rest of the main() function's local variables
The reason for declaring variables in C is to aid the construction of this section of code
The debugger knows this part of the code is automatically generated and skips over it

Examining memory is a critical skill for any hacker
Since a running program is mostly just a processor and segments of memory, examining memory is the first way to look at what's really going on
The GDB debugger lets you directly examine a memory, using the command |x|(examine)
It expects two arguments when used:
  the location in memory to examine
  how to display the memory
    The display format alos uses single-letter shorthand, optionally preceded by a count of how many items to examine
    Some format letters are
      o    Display in octal
      x    Display in hexadecimal
      u    Display in unsigned, standard base-10 decimal
      t    Display in binary
Shothand commands are often used in GDB
info register eip can be shortened to i r eip

-------------In the terminal------------
(gdb) \\\i r eip\\\
eip     0x8048394     0x8048394
(gdb) \\\x/o 0x8048384\\\
0x8048384 <main+16>:     077042707
(gdb) \\\x/x $eip\\\
0x8048384 <main+16>:     0x00fc45c7
(gdb) \\\x/u $eip\\\
0x8048384 <main+16>:     16532935
(gdb) \\\x/t $eip\\\
0x8048384 <main+16>:     00000000111111000100010111000111

The memory pointed by the EIP register can be examined by using its address
The debugger lets you reference the registers directly, so $eip is equivalent to the value EIP contains at that moment(0x8048384)
We examine the memory, which is a 4-byte unit, contained in the address of the EIP register in octal, hexadecimal, decimal and binary system
Prepending numbers to the format of examine to examine multiple units at target address

-------------In the terminal------------
(gdb) \\\x/2x $eip\\\
0x8048384 <main+16>:   0x00fc45c7   0x83000000
(gdb) \\\x/12x $eip\\\
0x8048384 <main+16>:   0x00fc45c7   0x83000000   0x7e09fc7d   0xc713eb02
0x8048394 <main+32>:   0x84842404   0x01e80804   0x8dffffff   0x00fffc45
0x80483a4 <main+48>:   0xc3c9e5eb   0x90909090   0x90909090   0x5de58955

The default size of a single unit is a four-byte unit called a word
To better understand the above ouput and the statement, view the memory in binary

-------------In the terminal------------
gdb) \\\x/2t $eip\\\
0x8048384 <main+16>:   00000000111111000100010111000111   10000011000000000000000000000000

The default size of a single unit is a four-byte unit called a word
The size of display units for the examine command can be changed by adding a size letter to end of the format letter. Valid size letters:
    b    A single byte
    h    A halfword, two bytes in size
    w    A word, four bytes in size
    g    A giant, eight bytes in size
This is slightly confusing as sometimes word also refers to 2-byte values and double word /DWORD refers to 4-byte values
In this project, DWOR and word both refer to 4-byte values and short and halfword refer to 2-byte value

Showing outputs in various sizes
-------------In the terminal------------
(gdb) \\\x/8xb $eip\\\
0x8048384 <main+16>:   0xc7     0x45     0xfc     0x00     0x00     0x00     0x00     0x83
(gdb) \\\x/8xh $eip\\\
0x8048384 <main+16>:   0x45c7   0x00fc   0x0000   0x8300   0xfc7d   0x7e09   0xeb02   0xc713
(gdb) \\\x/8xw $eip\\\
0x8048384 <main+16>:   0x00fc45c7   0x83000000   0x7e09fc7d   0xc713eb02
0x8048394 <main+32>:   0x84842404   0x01e80804   0x8dffffff   0x00fffc45

Observing the data above, the first examine shows the first two bytes of data to be 0xc7 and 0x45, but when a halfword is examined at the same memory address, the value 0x45c7, which is the bytes reversed
The same byte reversal can be seen when a four-byte word is shown as 0x00fc45c7, but when the bytes are shown byte by byte, they are in the order: 0xc7, 0x45, 0xfc and 0x00
This is because on x86 processor values are stored in little-endian byte order, which means the least significant byte is stored first
If more than 1 bytes are to be used as a single value, the bytes must be used in reverse oder

What happens is that the processor stores the data in reverse order and it reads it in the same way
Viewing these values as hexadecimal and unsigned decimals
(gdb) x/4xb $eip
0x8048384 <main+16>:    0xc7    0x45    0xfc    0x00
(gdb) x/4ub $eip
0x8048384 <main+16>:    199    69    252    0
(gdb) x/1xw $eip
0x8048384 <main+16>:    0x00fc45c7
(gdb) x/1uw $eip
0x8048384 <main+16>:    16532935
(gdb) quit
The program is running. Exit anyway? (y or n) y
reader@hacking:~/booksrc $ bc -ql
199*(256^3) + 69*(256^2) + 252*(256^1) + 0*(256^0)
3343252480
0*(256^3) + 252*(256^2) + 69*(256^1) + 199*(256^0)
16532935

The first four bytes are shown in hex and decimal notation
bc(command-line calculator) shows that if bytes are interpreted incorrectly, incorrect value is generated
The byte order of given architecture is important to be aware of

The examine(x) command also accepts the format letter i, short for instruction, to display the memory as disassembled assembly language instructions

-------------In the terminal------------
\\\gdb -q ./a.out\\\
Using host libthread_db library "/lib/tls/i686/cmov/libthread_db.so.1".
(gdb) \\\break main\\\
Breakpoint 1 at 0x8048384: file firstprog.c, line 6.
(gdb) \\\run\\\
Starting program: /home/reader/booksrc/a.out
Breakpoint 1, main () at firstprog.c:6
6
 for(i=0; i < 10; i++)
(gdb) \\\i r $eip\\\
eip        0x8048384        0x8048384 <main+16>
(gdb) \\\x/i $eip\\\
0x8048384 <main+16>:   mov   DWORD PTR [ebp-4],0x0
(gdb) \\\x/3i $eip\\\
0x8048384 <main+16>:   mov   DWORD PTR [ebp-4],0x0
0x804838b <main+23>:   cmp   DWORD PTR [ebp-4],0x9
0x804838f <main+27>:   jle   0x8048393 <main+31>
(gdb) \\\x/7xb $eip\\\
0x8048384 <main+16>:   0xc7   0x45   0xfc   0x00   0x00   0x00   0x00
(gdb) \\\x/i $eip\\\
0x8048384 <main+16>:   mov   DWORD PTR [ebp-4],0x0

In the output above, its the fucking same as all above examples until (i)
Since the EIP register is pointing to memory that contains machine language instructions, they disassemble easily

0x8048384 <main+16>:   mov   DWORD PTR [ebp-4],0x0

This assembly instruction will move the value 0 into memory located at the address stored in EBP register -4, where the i variable is stored in memory
So, this command sets the value of i to 0 for the for loop
Right now, if that memory is examined, it will contain nowhting but random garbage
Examining the memory at this location(EBP-4)

-------------In the terminal------------
(gdb) \\\i r ebp\\\
ebp        0xbffff808        0xbffff808
(gdb) \\\x/4xb $ebp - 4\\\
0xbffff804:    0xc0    0x83    0x04    0x08
(gdb) \\\x/4xb 0xbffff804\\\
0xbffff804:    0xc0    0x83    0x04    0x08
(gdb) \\\print $ebp - 4\\\
$1 = (void *) 0xbffff804
(gdb) \\\x/4xb $1\\\
0xbffff804:    0xc0    0x83    0x04    0x08
(gdb) \\\x/xw $1\\\
0xbffff804:        0x080483c0

The EBP register contains the address 0xbffff808 and the assembly isntruction will write to a value offset by 4 less than that, 0xbffff804
We examine this memory address using the examine command or using maths on the fly
The print command can also be used, but the result will be stored in a temporary varaible in debugger
The variable, named $1, can be used later to access that memory address
All the methods above accomplish the same task, displaying the 4 garbage bytes found in memory which is a placeholder for variable i