To see the bigger picture, realise that C code is meant to be compiled
The code can't actually do anything until it's compiled into an executable bimary file
Thinking of C-source as a program is a common misconception

The binary a.out's instructions are written in machine language, an elementary language the CPU can understand
Compilers are designed to translate the language of C code into machine language for a variety of processor architecures
    In the current case, it is x86 architecture
    There are also Sparc processor architectures(Sun Workstations), PowerPC processor architecture(pre-Intel Macs)
Each architecture has a different machine code and the compiler acts as a middle ground by translating C code into machine language for the target architecture

The average programmer is concerned with source code as long as the compiled program works
A hacker realizes that the compiled program is what actally gets executed in the real world
With a better understaning of how a CPU operates, a hacker can manipulate the programs that run on it

Looking at the binary for the first program
The GNU development tools include a program called objdump to examine compiled binaries

Looking at the machine code of the main function:
objdump -D a.out | grep -A20 main.:
08048374 <main>:
  8048374:     55                      push    %ebp 
  8048375:     89 e5                   mov     %esp,%ebp 
  8048377:     83 ec 08                sub     $0x8,%esp 
  804837a:     83 e4 f0                and     $0xfffffff0,%esp 
  804837d:     b8 00 00  00 00         mov     $0x0,%eax 
  8048382:     29 c4                   sub     %eax,%esp 
  8048384:     c7 45 fc  00 00 00 00   movl    $0x0,0xfffffffc(%ebp) 
  804838b:     83 7d fc  09            cmpl    $0x9,0xfffffffc(%ebp) 
  804838f:     7e 02                   jle     8048393 <main+0x1f> 
  8048391:     eb 13                   jmp     80483a6 <main+0x32> 
  8048393:     c7 04 24  84 84 04 08   movl    $0x8048484,(%esp) 
  804839a:     e8 01 ff  ff ff         call    80482a0 <printf@plt> 
  804839f:     8d 45 fc                lea     0xfffffffc(%ebp),%eax 
  80483a2:     ff 00                   incl    (%eax) 
  80483a4:     eb e5                   jmp     804838b <main+0x17> 
  80483a6:     c9                      leave
  80483a7:     c3                      ret
  80483a8:     90                      nop
  80483a9:     90                      nop
  80483aa:     90                      nop

The objdump spits out far too many lines of output to examine
So, the output is piped into grep, the -A20 means to display 20 lines after the matched pattern

In the output, each byte is represented in hexadecimal notation
This is a convenient notation as a byte contains 8 bits, each of which can be either true or fales
This means a byte has 256(2^8) possible values, so each byte can be described with 2 hexadecimal digits

------------------------The hexadecimal numbers starting with 0x8048374 on the left are memory addresses
The bits of machine language instructions are put in memory
Memory is just a collection of bytes and temporary storage space that are numbered with addresses

Memory can be thought of as a row of bytes, each with its own memory address
Each byte of memory can be accessed by its address
In the above program, the CPU accesses this part of memory to retrieve the machine language instructions that make up the compiled program

Older Intel x86 processors use a 32-bit addressing scheme and newer ones use a 64-bit one
The 32-bit processors have 2^32(4,294,967.296) possible addresses, while the 64-bit ones have 2^64(1.84467441 x 10^19) possible addresses
64-bit processors can run in 32-bit compatibility mode, allowing them to run 32-bit code quickly

------------------------The hexadecimal numbers in the middle of the list above are the machine language instrucitons for the x86 processor
These hexadecimal numbers are representations of the bytes of binary 1s and 0s that the CPU can understand
As binary is way difficult to read, the machine code is displayed as hexadecimal bytes and each instruction is put on a separate line
The hexadecimal numbers are also difficult to read for the humans, so assembly language is used

------------------------The instructions on the far left are in assembly language
Assembly language is a collection of mnemonics for the corresponding machine language instructions
The instructions ret is easier to remember and make sense of than 0xc3 or 11000011
Assmebly language has a direct one-to-one relationship with their corresponding machine language instructions
This means every processor has a different form of assembly language

Two main x86 assembly language syntax: AT&T and Intel syntax
------------------------The above assembly language is AT&T syntax, as almost all Linux disassembly tools use this syntax by default
AT&T syntax can be recognized by the cacophony of % and $ symbols prefixing everything

Viewing assembly code in Intel syntax
objdump -M intel -D a.out | grep -A20 main.:
08048374 <main>:
  8048374:     55                      push   ebp 
  8048375:     89 e5                   mov   ebp,esp 
  8048377:     83 ec 08                sub   esp,0x8 
  804837a:     83 e4 f0                and   esp,0xfffffff0 
  804837d:     b8 00 00  00 00         mov   eax,0x0 
  8048382:     29 c4                   sub   esp,eax 
  8048384:     c7 45 fc  00 00 00 00   mov     DWORD PTR [ebp-4],0x0 
  804838b:     83 7d fc  09            cmp   DWORD PTR [ebp-4],0x9 
  804838f:     7e 02                   jle   8048393 <main+0x1f>      
  8048391:     eb 13                   jmp   80483a6 <main+0x32> 
  8048393:     c7 04 24 84 84 04 08    mov     DWORD PTR [esp],0x8048484 
  804839a:     e8 01 ff ff ff          call   80482a0 <printf@plt> 
  804839f:     8d 45 fc                lea   eax,[ebp-4] 
  80483a2:     ff 00                   inc   DWORD PTR [eax] 
  80483a4:     eb e5                   jmp   804838b <main+0x17> 
  80483a6:     c9                      leave
  80483a7:     c3                      ret
  80483a8:     90                      nop
  80483a9:     90                      nop
  80483aa:     90                      nop

The Intel syntax is much more readable and easier to understand, so it will be followed
Regardless of assembly language presentation, the commands a processor understands are quite simple
These commands consist of an operation and sometimes the additional argumentsthat describe the destination and/or the source for the operation
These operations move memory around, perform some sort of basic math, or interrupt the processor to get it to do something else
As millions of books have been written using a relatively small alphabet, infinite number of possible programs can be created using a relatively small collection of machine instructions

Processors have their own sets of variables called registers
Most instructions use these registers to read or write data