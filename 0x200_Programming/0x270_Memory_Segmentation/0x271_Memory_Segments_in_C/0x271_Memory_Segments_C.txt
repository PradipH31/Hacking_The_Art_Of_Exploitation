In C, as in other compiled languages, the compiled code goes to the text segment, while the variables reside in the remaining segments
Exactly which memory segment a variable will be stored in depends on how the variable is defined

Variables that are defined outside of any function are considered to be global
The static keyword can be prepended to any variable declaration to make a variable static
If static or global variable are initialized with data, they are stored in the datat memroy segment; otherwise, these variables are put in the bss memory segment

Memory on the heap segment must first be allocated using a memory funciton called malloc()
Usually, pointers are used to reference memory on the heap

Finally, the remaining function variables are stored in the stack memory segment
Sice the stack can contain many different stack frames, stack variables can maintain uniqueness within different functional contexts

memory_segments.c
__________________________________________________________________________________
#include <stdio.h>

int global_var;
int global_initialized_var = 5;

void function() { // This is just a demo function
    int stack_var; // This variable has the same name as the one in main()
    printf("the function's stack_var is at address 0x%08x\n", &stack_var);
}

int main(){
    int stack_var; // Same name as the variable in function()
    static int static_initialized_var = 5;
    static int static_var;
    int *heap_var_ptr;

    heap_var_ptr = (int *) malloc(4);

    //These variables are in the data segment
    printf("global_initialized_var is at address 0x%08x\n", &global_initialized_var);
    printf("static_initialized_var is at address 0x%08x\n\n", &static_initialized_var);

    //These variables ar eni the bss segment
    printf("static_var is at address 0x%08x\n", &static_var);
    printf("global_var is at address 0x%08x\n\n", &global_var);

    //This variable is int the heap segment
    printf("heap_var is at address 0x%08x\n\n", heap_var_ptr);

    //These variables are in the stack segment
    printf("stack_var is at address 0x%08x\n", &stack_var);
    function();
}
__________________________________________________________________________________

The global and static variables are declared as described earlier, and initialized counterparts are also declared
The stack variable is declared both in main() and in function() to showcase the effect of functional contexts
The heap variable is actually declared as an integer pointer, which will point to memory allocated to the heap memory segment
The malloc() function is called to allocate four bytes on the heap
Since the newly allocated memory could be of any data type, the malloc() function returns a void pointer, which needs to be typecast into an integer pointer

__________________________________________________________________________________
reader@hacking:~/booksrc $ gcc memory_segments.c
reader@hacking:~/booksrc $ ./a.out
global_initialized_var is at address 0x080497ec
static_initialized_var is at address 0x080497f0

static_var is at address 0x080497f8
global_var is at address 0x080497fc

heap_var is at address 0x0804a008

stack_var is at address 0xbffff834
the function's stack_var is at address 0xbffff814
__________________________________________________________________________________

The first two initialized variables have the lowest memory addresses, since they are located in the data memory segment
The next two variables, static_var and global_var, are stored in the bss memory segment, since they aren't initialized
These memory addresses are slightly larger than the previous variables' addresses, since the bss segment is located below the data segment
Since both of these segments have a fixed size after compilation, there is little wasted space, and the addresses aren't very far apart

The heap variable is stored in space allocated on the heap segment which is located below the bss segment
Memory in this segment isn't fixed and more space can be dynamically allocated later

The last two stack_vars have very large memory addresses, since they are located in the stack segment
Memory in the stack isn't fixed, either; however this memory starts at the bottom and grows backward toward the heap segment
This allows both memory segment to be dynamic without wasting space in memory
The first stack_var in the main() function's context is stored in the stack segment within a stack frame
The second stack_var in function() has its own unique context, so that variable is stored within a different stack frame in the stack segment
When function() is called near the end of the program, a new stack frame is created to store (among other things) the stack_var for function()'s context
Since the stack geows back up towards the heap segment with each new stack frame, the memory address for the second stack_var is smaller than the address for the first stack_var foudn within main()'s context