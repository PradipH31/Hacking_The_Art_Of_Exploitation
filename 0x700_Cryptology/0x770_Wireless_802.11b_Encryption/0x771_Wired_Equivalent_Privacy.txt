WEP was meant to be an encryption method providing security equivalent to a a wired access point
It was originally designed with 40-bit keys; later, WEP2 came along to increase the key size to 104 bits
All of the encryption is done on a per-packet basis, so each packet is essentially a separate plaintext message to send
The packet will be called M

First, a checksum of message M is computed, so the message integrity can be checked later
This is done using a 32-bit cyclic redundancy checksum function named CRC32
This checksum will be called CS, so CS = CRC32(M)
This value is appended to the end of the message, which makes up the plaintext message P:

                 Plaintext message P
 _______________________________________________
|           Message M             |  CRC(M) CS  |
|_________________________________|_____________|

Now, the plaintext message needs to be encrypted
This is done using RC4, which is a stream cipher
This cipher, initialized with a seed value, can generate a keystream, which is just an arbitrarily long stream of pseudo-random bytes
WEP uses an initialization vector (IV) for the seed value
The IV consists of 24 bits generated for each packet
Some older WEP implementations simply use sequential values for the IV, while others use some form of pseudo-randomizer

Regardless of how the 24 bits of IV are chosen, they are prepended to the WEP key
(These 24 bits of IV are included in the WEP key size in a bit of clever marketing spin; when a vendor talks about 64-bit or 128-bit WEP keys, the actual keys are only 40 bits and 104 bits, respectively, combined with 25 bits of IV)
The IV and the WEP key together make up the seed value, which will be called S

         Seed value S
 _______________________________________
| 24-bit IV | 40-bit or 104-bit WEP key |
|___________|___________________________|

Then the seed value S is fed into RC4, which will generate a keystream
This keystream is XORed with the plaintext message P to produce the ciphertext C
The IV is prepended to the ciphertext, and the whole thing is encapsulated with yet another header and sent out over the radio link

            ______________________________________
            |Plaintext message P (M with 32-bit CS|
            |_____________________________________|

                           XOR
             _____________________________________ 
            |  Keystream generated by RC4(seed)   |
            |_____________________________________|

                           equals
 __________________________________________________
| 24-bit IV |             Ciphertext C             |
|___________|______________________________________|

When the recipient receives a WEP-encrypted packet, the process is simply reversed
The recipient pulls the IV from the message and then concatenates the IV with his own WEP key to produce a seed value of S
If the sender and receiver both have the same WEP key, the seed values will be the same
This seed is fed into RC4 again to produce the same keystream, which is XORed with the rest of the encrypted message
This will produce the original plaintext message, consisting of the packet message M concatenated with the integrity checksum CS
The recipitent then uses the same CRC32 function to recalculate the checksum for M and checks that the calculated value matches the received value of CS
If the checksum match, the packet is passed on
Otherwise, there were too many transmission errors or the WEP keys didn't match, and the packet is dropped

That's basically WEP in a nustshell