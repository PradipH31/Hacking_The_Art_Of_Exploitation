Passwords aren't generally stored in plaintext form
A file containing all the passwords in plaintext form would be far too attractive a target, so instead, a one-way hash function is used
The best-known of these functions is based on DES and is called crypt(), which is described in the manual page shown below:
__________________________________________________________________________________
NAME
       crypt - password and data encryption

SYNOPSIS
       #define _XOPEN_SOURCE
       #include <unistd.h>

       char *crypt(const char *key, const char *salt);

DESCRIPTION
       crypt() is the password encryption function. It is based on the Data
       Encryption Standard algorithm with variations intended (among other
       things) to discourage use of hardware implementations of a key search.
       
       key is a user's typed password.
       
       salt is a two-character string chosen from the set [a–zA–Z0–9./]. This
       string is used to perturb the algorithm in one of 4096 different ways
__________________________________________________________________________________

This is a one-way hash function that expects a plaintext password and a salt value for input, and then outputs a hash with the salt value prepended to it
This hash is mathematically irreversible, meaning that it is impossible to determine the original password using only the hash
Writing a quick program to experiment with this function will help clarify any confusion

crypt_test.c
__________________________________________________________________________________
#define _XOPEN_SOURCE
#include <unistd.h>
#include <stdio.h>

int main(int argc, char *argv[]) {
   if(argc < 2) {
      printf("Usage: %s <plaintext password> <salt value>\n", argv[0]);
      exit(1);
   }
   printf("password \"%s\" with salt \"%s\"\n", argv[1], argv[2]);
   printf("hashes to ==> %s\n", crypt(argv[1], argv[2]));
}
__________________________________________________________________________________

When this program is compiled, the crypt library needs to be linked
This is shown in the following output, along with some test runs

__________________________________________________________________________________
reader@hacking:~/booksrc $ gcc -o crypt_test crypt_test.c
/tmp/cccrSvYU.o: In function `main':
crypt_test.c:(.text+0x73): undefined reference to `crypt'
collect2: ld returned 1 exit status
reader@hacking:~/booksrc $ gcc -o crypt_test crypt_test.c -l crypt

reader@hacking:~/booksrc $ ./crypt_test testing je
password "testing" with salt "je" hashes to ==> jeLu9ckBgvgX.

reader@hacking:~/booksrc $ ./crypt_test test je
password "test" with salt "je" hashes to ==> jeHEAX1m66RV.

reader@hacking:~/booksrc $ ./crypt_test test xy
password "test" with salt "xy" hashes to ==> xyVSuHLjceD92
__________________________________________________________________________________

Notice that in the last 2 runs, the same password is encrypted, but using different salt values
The salt value is used to pertrub the algorithm further, so there can be multiple hash values for the same plaintext value if different salt values are used
The hash value (including the prepended salt) is stored in the password file under the premise that if an attacker were to steal the password file, the hashes would be useless

When a legitimate user needs to authenticate using the password hash, that user's hash is looked up in the password file
The user is prompted to enter her password, the original salt value is extracted from the password file, and whatever the user types is sent through the same one-way hash function with the salt value
If the correct password was entered, the one-way hashing function will produce the same hash output as is stored in the password file
This allows authentication to function as expected, without ever having to store the plaintext password