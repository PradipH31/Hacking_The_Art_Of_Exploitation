It turns out that the encrypted passwords in the password file aren't so useless after all
Sure, it's mathematically impossible to reverse the hash, but it is possible to just quickly hash every word in a dictionary, using the salt value for a specific hash, and then compare the result with that hash
If the hashes match, then that word from the dictionary must be the plaintext password

A simple dictionary attack program can be whipped up fairly easily
It just needs to read words from a file, hash each one using the proper salt value, and display the word if there is a match
THe following source code does this using filestream functions, which are included with stdio.h
These functions are easier to work with, since they wrap up the messiness of open() calls and file descriptors, using FILE structure pointers, instead
In the source below, the fopen() call's r argument tells it to open the file for reading
It returns NULL on failure, or a pointer to the open filestream 
THe fgets() call gets a string from the filestream, up to a maximum length or when it reaches the end of a line
In this case, it's used to read each line from the word-list file
This function also returns NULL on failure, which is used to detect the end of the file

crypt_crack.c
__________________________________________________________________________________
#define _XOPEN_SOURCE
#include <unistd.h>
#include <stdio.h>

/* Barf a message and exit */
void barf(char *message, char *extra) {
   printf(message, extra);
   exit(1);
}

/* A dictionary attack example program */
int main(int argc, char *argv[]) {
   FILE *wordlist;
   char *hash, word[30], salt[3];
   if(argc < 2)
      barf("Usage: %S <wordlist file> <password hash>\n", argv[0]);

   strncpy(salt, argv[2]. 2); // First 2 bytes of hash are the salt
   salt[2] = '\0'; // terminate string

   printf("Salt value is \'%s\'\n", salt);

   if( (wordlist = fopen(argv[1], "r")) == NULL) // Open the wordlist
      barf("Fatal: couldn't open the file \'%s\'.\n", argv[1]);

   while(fgets(word, 30, wordlist) != NULL) { // Read each word
      word[strlen(word)-1] = '\0'; // Remove the '\n' byte at the end
      hash = crypt(word, salt); // Hash the word using the salt
      printf("trying word:   %-30s ==> %15s\n", word, hash);
      if(strcmp(hash, argv[2]) == 0) { // If the hash matches
         printf("The hash \"%s\" is from the ", argv[2]);
         printf("plaintext password \"%s\".\n", word);
         fclose(wordlist);
         exit(0);
      }
   }
   printf("Couldn't find the plaintext password in the supplied wordlist.\n");
   fclose(wordlist);
}
__________________________________________________________________________________

The following output shows this program being used to crack the password hash jeHEAX1m66RV., using the words found in /usr/share/dict/words

__________________________________________________________________________________
reader@hacking:~/booksrc $ gcc -o crypt_crack crypt_crack.c -lcrypt
reader@hacking:~/booksrc $ ./crypt_crack /usr/share/dict/words jeHEAX1m66RV.
Salt value is 'je'
trying word:                ==>     jesS3DmkteZYk 
trying word:    A           ==>     jeV7uK/S.y/KU 
trying word:    A's         ==>     jeEcn7sF7jwWU 
trying word:    AOL         ==>     jeSFGex8ANJDE 
trying word:    AOL's       ==>     jesSDhacNYUbc 
trying word:    Aachen      ==>     jeyQc3uB14q1E 
trying word:    Aachen's    ==>     je7AQSxfhvsyM 
trying word:    Aaliyah     ==>     je/vAqRJyOZvU 

.:[ output trimmed ]:.

trying word:    terse       ==>     jelgEmNGLflJ2 
trying word:    tersely     ==>     jeYfo1aImUWqg 
trying word:    terseness   ==>     jedH11z6kkEaA 
trying word:    terseness's ==>     jedH11z6kkEaA 
trying word:    terser      ==>     jeXptBe6psF3g 
trying word:    tersest     ==>     jenhzylhDIqBA 
trying word:    tertiary    ==>     jex6uKY9AJDto 
trying word:    test        ==>     jeHEAX1m66RV. 
The hash "jeHEAX1m66RV." is from the plaintext password "test".
__________________________________________________________________________________

Since the word test was the original password and this word is found in the words file, the password hash will eventually be cracked
This is why it's considered poor security practice to use passwords that are dictionary words or based on dictionary words

The downside to this attack is that if the original password isn't a word found in the dictionary file, the password won't be found
For example, if a non-dictionary word such as h4R% is used as a password, the dictionary attack won't be able to find it:

__________________________________________________________________________________
reader@hacking:~/booksrc $ ./crypt_test h4R% je
password "h4R%" with salt "je" hashes to ==> jeMqqfIfPNNTE
reader@hacking:~/booksrc $ ./crypt_crack /usr/share/dict/words jeMqqfIfPNNTE
Salt value is 'je'
trying word:
trying word:    A           ==>    jeV7uK/S.y/KU 
trying word:    A's         ==>    jeEcn7sF7jwWU 
trying word:    AOL         ==>    jeSFGex8ANJDE 
trying word:    AOL's       ==>    jesSDhacNYUbc 
trying word:    Aachen      ==>    jeyQc3uB14q1E 
trying word:    Aachen's    ==>    je7AQSxfhvsyM 
trying word:    Aaliyah     ==>    je/vAqRJyOZvU 

.:[ output trimmed ]:.

trying word:    zooms       ==>   je8A6DQ87wHHI 
trying word:    zoos        ==>   jePmCz9ZNPwKU 
trying word:    zucchini    ==>   jeqZ9LSWt.esI 
trying word:    zucchini's  ==>   jeqZ9LSWt.esI 
trying word:    zucchinis   ==>   jeqZ9LSWt.esI 
trying word:    zwieback    ==>   jezzR3b5zwlys 
trying word:    zwieback's  ==>   jezzR3b5zwlys 
trying word:    zygote      ==>   jei5HG7JrfLy6 
trying word:    zygote's    ==>   jej86M9AG0yj2 
trying word:    zygotes     ==>   jeWHQebUlxTmo 
Couldn't find the plaintext password in the supplied wordlist.
__________________________________________________________________________________

Custom dictionary files are often made using different languages, standard modification of words (such as transforming letters to numbers), or simply appending numbers to the end of each word
While a bigger dictionary will yield more passwords, it will also take more time to process