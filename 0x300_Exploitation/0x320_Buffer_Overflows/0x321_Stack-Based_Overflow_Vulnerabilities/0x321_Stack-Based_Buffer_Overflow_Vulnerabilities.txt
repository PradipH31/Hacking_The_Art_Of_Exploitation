The notesearch exploit works by corrupting memory to control execution flow
It is demonstrated in auth_overflow.c below:

auth_overflow.c
__________________________________________________________________________________
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int check_authentication(char *password) {
	int auth_flag = 0;
	char password_buffer[16];

	strcpy(password_buffer, password);

	if(strcmp(password_buffer, "brillig") == 0)
		auth_flag = 1;
	if(strcmp(password_buffer, "outgrabe") == 0)
		auth_flag = 1;

	return auth_flag;
}

int main(int argc, char *argv[]) {
	if(argc < 2){
		printf("Usage: %s <password>\n", argv[0]);
		exit(0);
	}
	if(check_authentication(argv[1])) {
		printf(""\n-=-=-=-=-=-=-=-=-=-=-=-=-=-\n");
		printf("       Access Granted.\n");
		printf(""\n-=-=-=-=-=-=-=-=-=-=-=-=-=-\n");
	} else {
		printf("\nAccess Denied.\n");
	}
}
__________________________________________________________________________________

This example program accepts a password as its only command-line argument and then calls a check_authentication() function
This function allows two passwords, meant to be representative of multiple authentication methods
If either of these passwords is used, the function returns 1, which grants access
Use -g option while compiling for debugging later

__________________________________________________________________________________
reader@hacking:~/booksrc $ gcc -g -o auth_overflow auth_overflow.c
reader@hacking:~/booksrc $ ./auth_overflow
Usage: ./auth_overflow <password>
reader@hacking:~/booksrc $ ./auth_overflow test

Access Denied.
reader@hacking:~/booksrc $ ./auth_overflow brillig

-=-=-=-=-=-=-=-=-=-=-=-=-=-
Access Granted.
-=-=-=-=-=-=-=-=-=-=-=-=-=-
reader@hacking:~/booksrc $ ./auth_overflow outgrabe

-=-=-=-=-=-=-=-=-=-=-=-=-=-
Access Granted.
-=-=-=-=-=-=-=-=-=-=-=-=-=-
__________________________________________________________________________________

So far, everything works as source code says it should
This is to be expected from something as deterministic as a computer program
But an overflow can lead to unexpected and even contradictory behavior, allowing access without a proper password

__________________________________________________________________________________
reader@hacking:~/booksrc $ ./auth_overflow AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

-=-=-=-=-=-=-=-=-=-=-=-=-=-
Access Granted.
-=-=-=-=-=-=-=-=-=-=-=-=-=-
__________________________________________________________________________________

What has happened may have been figured out, but looking at the debugger:

__________________________________________________________________________________
reader@hacking:~/booksrc $ gdb -q ./auth_overflow
Using host libthread_db library "/lib/tls/i686/cmov/libthread_db.so.1".
(gdb) list 1
1      #include <stdio.h> 
2      #include <stdlib.h> 
3      #include <string.h> 
4     
5      int check_authentication(char *password) { 
6              int auth_flag = 0; 
7              char password_buffer[16]; 
8
9              strcpy(password_buffer, password); 
10
(gdb)
11             if(strcmp(password_buffer, "brillig") == 0) 
12             auth_flag = 1; 
13             if(strcmp(password_buffer, "outgrabe") == 0) 
14             auth_flag = 1; 
15
16     return auth_flag; 
17     } 
18
19     int main(int argc, char *argv[]) { 
20             if(argc < 2) { 
(gdb) break 9
Breakpoint 1 at 0x8048421: file auth_overflow.c, line 9.
(gdb) break 16
Breakpoint 2 at 0x804846f: file auth_overflow.c, line 16.
__________________________________________________________________________________

The GDB debugger is started with -q option to suppress the welcome banner, and breakpoints are set on lines 9 and 17
When the program is run, execution will pause at breakpoints and give us a chance to examine memory

__________________________________________________________________________________
(gdb) run AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Starting program: /home/reader/booksrc/auth_overflow AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

Breakpoint 1, check_authentication (password=0xbffff9af 'A' <repeats 30 times>) at
auth_overflow.c:9
9                     strcpy(password_buffer, password);
(gdb) x/s password_buffer
0xbffff7a0:           ")????o??????)\205\004\b?o??p???????"
(gdb) x/x &auth_flag
0xbffff7bc:           0x00000000
(gdb) print 0xbffff7bc - 0xbffff7a0
$1 = 28
(gdb) x/16xw password_buffer
0xbffff7a0:      0xb7f9f729      0xb7fd6ff4      0xbffff7d8      0x08048529 
0xbffff7b0:      0xb7fd6ff4      0xbffff870      0xbffff7d8   (a)0x00000000 
0xbffff7c0:      0xb7ff47b0      0x08048510      0xbffff7d8      0x080484bb 
0xbffff7d0:      0xbffff9af      0x08048510      0xbffff838      0xb7eafebc 
__________________________________________________________________________________

The first breakpoint is before the strcpy() happens
By examining the password_buffer pointer, the debugger shows it is filled with random uninitialized data and is located at 0xbffff7a0 in memory
By examining the auth_flag variable, we can see both its location at 0xbffff7bc and its value of 0
The print command can be used to do arithmetic and shows that auth_flag is 28 bytes past the start of password_buffer
This relationship can also be seen in a block of memory starting at password_buffer
The location of auth_flag is at (a)

__________________________________________________________________________________
(gdb) continue
Continuing.

Breakpoint 2, check_authentication (password=0xbffff9af 'A' <repeats 30 times>) at
auth_overflow.c:16
16              return auth_flag;
(gdb) x/s password_buffer
0xbffff7a0:      'A' <repeats 30 times>
(gdb) x/x &auth_flag
0xbffff7bc:      0x00004141
(gdb) x/16xw password_buffer
0xbffff7a0:      0x41414141      0x41414141      0x41414141      0x41414141 
0xbffff7b0:      0x41414141      0x41414141      0x41414141      0x00004141 
0xbffff7c0:      0xb7ff47b0      0x08048510      0xbffff7d8      0x080484bb 
0xbffff7d0:      0xbffff9af      0x08048510      0xbffff838      0xb7eafebc 
(gdb) x/4cb &auth_flag
0xbffff7bc:     65 'A' 65 'A' 0 '\0' 0 '\0'
(gdb) x/dw &auth_flag
0xbffff7bc:     16705
__________________________________________________________________________________

Continuing to the next breakpoint found after the strcpy(), these memory locations are examined again
The password_buffer overflowed into the auth_flag, changing its first two bytes to 0x41
The value of 0x00004141 might look backward, but this is because x86 has little-endian architecture, so it is supposed to look that way
If you examine each of these 4 bytes individually, you can see how the memory is laid out
Ultimately, the program will treat this value as an integer, with a value of 16705
The 0 in this case means nothing as 0 has hex value of 30 and ASCII value of 48

__________________________________________________________________________________
(gdb) continue
Continuing.

-=-=-=-=-=-=-=-=-=-=-=-=-=-
Access Granted.
-=-=-=-=-=-=-=-=-=-=-=-=-=-

Program exited with code 034.
__________________________________________________________________________________

After the overflow, the check_authentication() function will return 16705 instead of 0
Since the if statement considers any nonzero value to be authenticated, the program's execution flow is controlled into the authenticated section
In this example, the auth_flag variable is the execution control point, since overwriting this value is the source of the control
But this is a very contrived example that depends on memory layout of the variables
In the next program, the variables are declared in reverse order

auth_overflow2.c
__________________________________________________________________________________
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int check_authentication(char *password) {
	char password_buffer[16];
	int auth_flag = 0;

	strcpy(password_buffer, password);

	if(strcmp(password_buffer, "brillig") == 0)
		auth_flag = 1;
	if(strcmp(password_buffer, "outgrabe") == 0)
		auth_flag = 1;

	return auth_flag;
}

int main(int argc, char *argv[]) {
	if(argc < 2){
		printf("Usage: %s <password>\n", argv[0]);
		exit(0);
	}
	if(check_authentication(argv[1])) {
		printf(""\n-=-=-=-=-=-=-=-=-=-=-=-=-=-\n");
		printf("       Access Granted.\n");
		printf(""\n-=-=-=-=-=-=-=-=-=-=-=-=-=-\n");
	} else {
		printf("\nAccess Denied.\n");
	}
}
__________________________________________________________________________________

This simple change puts the auth_flag variable before the password_buffer in memory
This eliminates the use of the return_value variable as an execution control point, since it can no longer be corrupted by an overflow

__________________________________________________________________________________
reader@hacking:~/booksrc $ gcc -g auth_overflow2.c
reader@hacking:~/booksrc $ gdb -q ./a.out
Using host libthread_db library "/lib/tls/i686/cmov/libthread_db.so.1".
(gdb) list 1
1      #include <stdio.h> 
2      #include <stdlib.h> 
3      #include <string.h> 
4     
5      int check_authentication(char *password) { 
6               char password_buffer[16]; 
7               int auth_flag = 0; 
8              
9               strcpy(password_buffer, password); 
10     
(gdb)
11              if(strcmp(password_buffer, "brillig") == 0) 
12                      auth_flag = 1; 
13              if(strcmp(password_buffer, "outgrabe") == 0) 
14                      auth_flag = 1; 
15
16              return auth_flag; 
17     } 
18             
19     int main(int argc, char *argv[]) { 
20              if(argc < 2) { 
(gdb) break 9
Breakpoint 1 at 0x8048421: file auth_overflow2.c, line 9.
(gdb) break 16
Breakpoint 2 at 0x804846f: file auth_overflow2.c, line 16.
(gdb) run AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Starting program: /home/reader/booksrc/a.out AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

Breakpoint 1, check_authentication (password=0xbffff9b7 'A' <repeats 30 times>) at
auth_overflow2.c:9
9            strcpy(password_buffer, password);
(gdb) x/s password_buffer
0xbffff7c0:   "?o??\200????????o???G??\020\205\004\b?????\204\004\b????\020\205\004\bH???????\002"
(gdb) x/x &auth_flag
0xbffff7bc:     0x00000000
(gdb) x/16xw &auth_flag
0xbffff7bc:   (a)0x00000000      0xb7fd6ff4      0xbffff880      0xbffff7e8 
0xbffff7cc:      0xb7fd6ff4      0xb7ff47b0      0x08048510      0xbffff7e8 
0xbffff7dc:      0x080484bb      0xbffff9b7      0x08048510      0xbffff848 
0xbffff7ec:      0xb7eafebc      0x00000002      0xbffff874      0xbffff880 
__________________________________________________________________________________

Similar breakpoints are set, and an examination of memory shows that auth_flog, (a) is located before password_buffer in memory
This means auth_flag can never be overwritten by an overflow in password_buffer
__________________________________________________________________________________
(gdb) cont
Continuing.

Breakpoint 2, check_authentication (password=0xbffff9b7 'A' <repeats 30 times>) at auth_overflow2.c:16
16             return auth_flag;
(gdb) x/s password_buffer
0xbffff7c0:    'A' <repeats 30 times>
(gdb) x/x &auth_flag
0xbffff7bc:     0x00000000
(gdb) x/16xw &auth_flag
0xbffff7bc:      0x00000000      0x41414141      0x41414141      0x41414141 
0xbffff7cc:      0x41414141      0x41414141      0x41414141      0x41414141 
0xbffff7dc:      0x08004141      0xbffff9b7      0x08048510      0xbffff848 
0xbffff7ec:      0xb7eafebc      0x00000002      0xbffff874      0xbffff880 
__________________________________________________________________________________

As expected, the overflow cannot disturb the auth_flag variable, since its located before the buffer
But another execution control point does exist, even though you can't see it in the C code
It's conveniently located after all the stack variables, so it can easily be overwritten
This memory is integral to the operation of all programs, so it exists in all programs, and when it's over-written, it usually results in a program crash
__________________________________________________________________________________
(gdb) c
Continuing.

Program received signal SIGSEGV, Segmentation fault.
0x08004141 in ?? ()
__________________________________________________________________________________

The stack is one of the five memory segments used by the programs
The stack is a FILO data structure used to maintain execution flow and context for local variables during function calls
WHen a function is called, a structure called a stack frame is pushed onto the stack, and the EIP register jumps to the first instruction of the function
Each stack frame contains the local variables for that function and a return address so that EIP can be restored
When the function is done, the stack frame is popped off the stack and return address is used to restore EIP
All of this is built in to the architecture and is usually handled by the compiler, not the programmer

WHen the check_authentication() function is called, a new stack frame is pushed onto the stack above main()'s stack frame
In this frame are the local variables, a return address, and the function's arguments

__________________________
|return_value variable    |
|_________________________|
|                         |
|password_buffer variable |
|_________________________|
|Saved frame pointer(SFP) |
|_________________________|
|Return address(ret)      |
|_________________________|
|*password(func argument) |
|_________________________|
|main()'s stack frame     |
|/\/\/\/\/\/\/\/\/\/\/\/\/|

Seeing all the elements in debugger:

__________________________________________________________________________________
reader@hacking:~/booksrc $ gcc -g auth_overflow2.c
reader@hacking:~/booksrc $ gdb -q ./a.out
Using host libthread_db library "/lib/tls/i686/cmov/libthread_db.so.1".
(gdb) list 1
1      #include <stdio.h> 
2      #include <stdlib.h> 
3      #include <string.h> 
4     
5      int check_authentication(char *password) { 
6               char password_buffer[16]; 
7               int auth_flag = 0; 
8              
9               strcpy(password_buffer, password); 
10     
(gdb)
11              if(strcmp(password_buffer, "brillig") == 0) 
12                      auth_flag = 1; 
13              if(strcmp(password_buffer, "outgrabe") == 0) 
14                      auth_flag = 1; 
15
16              return auth_flag; 
17     } 
18             
19     int main(int argc, char *argv[]) { 
20              if(argc < 2) {
(gdb)
21              printf("Usage: %s <password>\n", argv[0]);
22              exit(0);
23      }
24        if(check_authentication(argv[1])) {
25              printf("\n-=-=-=-=-=-=-=-=-=-=-=-=-=-\n");
26              printf("      Access Granted.\n");
27              printf("-=-=-=-=-=-=-=-=-=-=-=-=-=-\n");
28        } else {
29              printf("\nAccess Denied.\n");
30     }
(gdb) break 24
Breakpoint 1 at 0x80484ab: file auth_overflow2.c, line 24.
(gdb) break 9
Breakpoint 2 at 0x8048421: file auth_overflow2.c, line 9.
(gdb) break 16
Breakpoint 3 at 0x804846f: file auth_overflow2.c, line 16.
(gdb) run AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Starting program: /home/reader/booksrc/a.out AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

Breakpoint 1, main (argc=2, argv=0xbffff874) at auth_overflow2.c:24
24              if(check_authentication(argv[1])) {
(gdb) i r esp
esp             0xbffff7e0             0xbffff7e0
(gdb) x/32xw $esp
0xbffff7e0:      0xb8000ce0      0x08048510      0xbffff848      0xb7eafebc 
0xbffff7f0:      0x00000002      0xbffff874      0xbffff880      0xb8001898 
0xbffff800:      0x00000000      0x00000001      0x00000001      0x00000000 
0xbffff810:      0xb7fd6ff4      0xb8000ce0      0x00000000      0xbffff848 
0xbffff820:      0x40f5f7f0      0x48e0fe81      0x00000000      0x00000000 
0xbffff830:      0x00000000      0xb7ff9300      0xb7eafded      0xb8000ff4 
0xbffff840:      0x00000002      0x08048350      0x00000000      0x08048371 
0xbffff850:      0x08048474      0x00000002      0xbffff874      0x08048510 
__________________________________________________________________________________

The first breakpoint is right before the call to check_authentication() in main()
At this point, the stack pointer(ESP) is 0xbffff7e0 and the top of the stack is shown
This is all part of main()'s stack frame

Continuing to the next breakpoint inside check_authentication(), the output below shows ESP is smaller as it moves up the list of memory to make room for check_authentication()'s stack frame(marked), which is now on the stack
After finding the address of the auth_flag variable(1) and the variable password_buffer(2), their locations can be seen within the stack frame
__________________________________________________________________________________
(gdb) c
Continuing.

Breakpoint 2, check_authentication (password=0xbffff9b7 'A' <repeats 30 times>) at
auth_overflow2.c:9
9                strcpy(password_buffer, password);
(gdb) i r esp
esp              0xbffff7a0              0xbffff7a0
(gdb) x/32xw $esp
                            ------------------------------------------------
0xbffff7a0:      0x00000000 |    0x08049744      0xbffff7b8      0x080482d9| 
             ----------------                                              |
0xbffff7b0:  |   0xb7f9f729      0xb7fd6ff4      0xbffff7e8   (1)0x00000000|
0xbffff7c0:  |(2)0xb7fd6ff4      0xbffff880      0xbffff7e8      0xb7fd6ff4|  
0xbffff7d0:  |   0xb7ff47b0      0x08048510      0xbffff7e8      0x080484bb| 
             |               -----------------------------------------------
0xbffff7e0:  |   0xbffff9b7  |   0x08048510      0xbffff848      0xb7eafebc 
             -----------------
0xbffff7f0:      0x00000002      0xbffff874      0xbffff880      0xb8001898 
0xbffff800:      0x00000000      0x00000001      0x00000001      0x00000000 
0xbffff810:      0xb7fd6ff4      0xb8000ce0      0x00000000      0xbffff848
(gdb) p 0xbffff7e0 - 0xbffff7a0
$1 = 64
(gdb) x/s password_buffer
0xbffff7c0:      "?o??\200????????o???G??\020\205\004\b?????\204\004\b????\020\205\004\bH???????\002"
(gdb) x/x &auth_flag
0xbffff7bc:      0x00000000
__________________________________________________________________________________

Continuing to the second breakpoint in check_authentication(), a stack frame(marked) is pushed onto the stack when the function is called
Since the stack grows upward toward lower memory addresses, the stack pointer is now 64 bytes less at 0xbffff7a0
The size and structure of a stack frame can vary greatly, depending on the function and certain compiler optimizations
For example, the first 24 bytes of this stack frame are just padding put there by the compiler
The local stack variables, auth_flag and password_buffer, are shown at their respective memory locations in the stack frame
The auth_flag(1) is shown at 0xbffff7bc and the 16 bytes of the password_buffer(2) are shown at 0xbffff7c0

The stack frame contains more than just the local variables and padding
Elements of the check_authentication() stack frame are shown below

First, the memory saved for the local variables is marked(with **)
This starts at auth_flag variable at 0xbffff7bc and continues through the end of the 16-byte password_buffer variable
The next few values on the stack are just padding the compiler threw in, plus something called the saved frame pointer
If the program is compiled with the flag -fomit-frame-pointer for optimization, the frame pointer won't be used in the stack frame
At(3) the value 0x080484bb is the return address of the stack frame, and at (4) the address 0xbffff9b7 is a pointer to a string containing 30 As
This must be the argument to the check_authentication() function

__________________________________________________________________________________
(gdb) x/32xw $esp
                              ----------------------------------------------
0xbffff7a0:      0x00000000  |   0x08049744      0xbffff7b8      0x080482d9| 
             -----------------                                             |
0xbffff7b0:  |   0xb7f9f729      0xb7fd6ff4      0xbffff7e8    **0x00000000|
0xbffff7c0:  | **0xb7fd6ff4    **0xbffff880    **0xbffff7e8    **0xb7fd6ff4|  
0xbffff7d0:  |   0xb7ff47b0      0x08048510      0xbffff7e8   (3)0x080484bb| 
             |               -----------------------------------------------
0xbffff7e0:  |(4)0xbffff9b7  |   0x08048510      0xbffff848      0xb7eafebc 
             -----------------
0xbffff7f0:      0x00000002      0xbffff874      0xbffff880      0xb8001898 
0xbffff800:      0x00000000      0x00000001      0x00000001      0x00000000 
0xbffff810:      0xb7fd6ff4      0xb8000ce0      0x00000000      0xbffff848
(gdb) x/32xb 0xbffff9b7
0xbffff9b7:    0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41 
0xbffff9bf:    0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41 
0xbffff9c7:    0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41 
0xbffff9cf:    0x41    0x41    0x41    0x41    0x41    0x41    0x00    0x53 
(gdb) x/s 0xbffff9b7
0xbffff9b7:
 'A' <repeats 30 times>
__________________________________________________________________________________

The return address in a stack frame can be located by understanding how the stack frame is created
The process begins in the main() function, even before the function call

__________________________________________________________________________________
(gdb) disass main
Dump of assembler code for function main:
0x08048474 <main+0>:       push     ebp 
0x08048475 <main+1>:       mov      ebp,esp 
0x08048477 <main+3>:       sub      esp,0x8 
0x0804847a <main+6>:       and      esp,0xfffffff0 
0x0804847d <main+9>:       mov      eax,0x0 
0x08048482 <main+14>:      sub      esp,eax 
0x08048484 <main+16>:      cmp      DWORD PTR [ebp+8],0x1 
0x08048488 <main+20>:      jg       0x80484ab <main+55> 
0x0804848a <main+22>:      mov      eax,DWORD PTR [ebp+12] 
0x0804848d <main+25>:      mov      eax,DWORD PTR [eax] 
0x0804848f <main+27>:      mov      DWORD PTR [esp+4],eax 
0x08048493 <main+31>:      mov      DWORD PTR [esp],0x80485e5 
0x0804849a <main+38>:      call     0x804831c <printf@plt> 
0x0804849f <main+43>:      mov      DWORD PTR [esp],0x0 
0x080484a6 <main+50>:      call     0x804833c <exit@plt> 
0x080484ab <main+55>:      mov      eax,DWORD PTR [ebp+12] 
0x080484ae <main+58>:      add      eax,0x4 
0x080484b1 <main+61>:      mov      eax,DWORD PTR [eax]
----------------------------------------------------------------------
|0x080484b3 <main+63>:      mov      DWORD PTR [esp],eax             |
|0x080484b6 <main+66>:      call     0x8048414 <check_authentication>|
----------------------------------------------------------------------
0x080484bb <main+71>:      test     eax,eax 
0x080484bd <main+73>:      je       0x80484e5 <main+113> 
0x080484bf <main+75>:      mov      DWORD PTR [esp],0x80485fb 
0x080484c6 <main+82>:      call     0x804831c <printf@plt> 
0x080484cb <main+87>:      mov      DWORD PTR [esp],0x8048619 
0x080484d2 <main+94>:      call     0x804831c <printf@plt> 
0x080484d7 <main+99>:      mov      DWORD PTR [esp],0x8048630 
0x080484de <main+106>:     call     0x804831c <printf@plt> 
0x080484e3 <main+111>:     jmp      0x80484f1 <main+125> 
0x080484e5 <main+113>:     mov      DWORD PTR [esp],0x804864d 
0x080484ec <main+120>:     call     0x804831c <printf@plt> 
0x080484f1 <main+125>:     leave     
0x080484f2 <main+126>:     ret
End of assembler dump.
__________________________________________________________________________________

Notice the two lines marked
At this point, the EAX register contains a pointer to the first command-line argument
This is also the argument to check_authentication()
The first assembly instruction writes EAX to where ESP is pointing(the top of the stack)
This starts the stack frame for check_authentication() with the function argument
The second argument is the actual call
This instruction pushes the address of the next instruction to the stack and moves the execution pointer register(EIP) to the start of the check_authentication() function
The address pushed to the stack is the return address for the stack frame
In this case, the address of the next instruction is 0x080484bb, so that is the return address

__________________________________________________________________________________
(gdb) disass check_authentication
Dump of assembler code for function check_authentication:
------------------------------------------------------------
|0x08048414 <check_authentication+0>:     push     ebp     |
|0x08048415 <check_authentication+1>:     mov      ebp,esp |
|0x08048417 <check_authentication+3>:     sub      esp,0x38|
------------------------------------------------------------

...

0x08048472 <check_authentication+94>:    leave
0x08048473 <check_authentication+95>:    ret
End of assembler dump.
(gdb) p 0x38
$3 = 56
(gdb) p 0x38 + 4 + 4
$4 = 64
__________________________________________________________________________________

Execution will continue into the check_authentication() function as EIP is changed, and the first few instructions (marked above) finish saving memory for the stack frame
These instructions are known as the function prologue
The first 2 instructions are for the saved frame pointer, and the third instruction subtracts 0x38 from ESP
This saves 56 bytes for the local variables on the function
The return address and the saved frame pointer are already pushed to the stack and account for the additional 8 bytes of the 64-back stack frame

When the function finishes, the leave and ret instructions remove the stack frame and set the execution pointer register(EIP) to the saved return address in the stack frame(1)
This brings the program execution back to the next instruction in main() after the function call at 0x080484bb
This process happens every time a function is called in any program

__________________________________________________________________________________
(gdb) x/32xw $esp
                            ------------------------------------------------
0xbffff7a0:      0x00000000 |    0x08049744      0xbffff7b8      0x080482d9| 
             ----------------                                              |
0xbffff7b0:  |   0xb7f9f729      0xb7fd6ff4      0xbffff7e8      0x00000000|
0xbffff7c0:  |   0xb7fd6ff4      0xbffff880      0xbffff7e8      0xb7fd6ff4|  
0xbffff7d0:  |   0xb7ff47b0      0x08048510      0xbffff7e8   (1)0x080484bb| 
             |               -----------------------------------------------
0xbffff7e0:  |   0xbffff9b7  |   0x08048510      0xbffff848      0xb7eafebc 
             -----------------
0xbffff7f0:      0x00000002      0xbffff874      0xbffff880      0xb8001898 
0xbffff800:      0x00000000      0x00000001      0x00000001      0x00000000 
0xbffff810:      0xb7fd6ff4      0xb8000ce0      0x00000000      0xbffff848

(gdb) cont
Continuing.

Breakpoint 3, check_authentication (password=0xbffff9b7 'A' <repeats 30 times>) at auth_overflow2.c:16
16               return auth_flag;
(gdb) x/32xw $esp
                ------------------------------------------------------------
0xbffff7a0:     |0xbffff7c0      0x080485dc      0xbffff7b8      0x080482d9|
0xbffff7b0:     |0xb7f9f729      0xb7fd6ff4      0xbffff7e8      0x00000000|
0xbffff7c0:     |0x41414141      0x41414141      0x41414141      0x41414141|
0xbffff7d0:     |0x41414141      0x41414141      0x41414141   (2)0x08004141|
                |            ----------------------------------------------|
0xbffff7e0:     |0xbffff9b7  |   0x08048510      0xbffff848      0xb7eafebc
                --------------
0xbffff7f0:      0x00000002      0xbffff874      0xbffff880      0xb8001898 
0xbffff800:      0x00000000      0x00000001      0x00000001      0x00000000 
0xbffff810:      0xb7fd6ff4      0xb8000ce0      0x00000000      0xbffff848 
(gdb) cont
Continuing.

Program received signal SIGSEGV, Segmentation fault.
0x08004141 in ?? ()

When some of the bytes of the saved return address are overwritten, the program will still try to use that value to restore the execution pointer register (EIP)
This usually results in a crash, since execution is essentially jumping to a random location
But this value doesn't need to be random
If the over-write is controlled, execution can, in turn, be controlled to jump to a specific location(but where?)