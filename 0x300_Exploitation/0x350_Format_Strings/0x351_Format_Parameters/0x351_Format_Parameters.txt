Format strings havebeen used excessively with functions like printf() in previous programs
A function that uses format strings, such as printf(), simlpy evaluates the format string passed to it and performs a special action each time a format parameter is encountered
Each format parameter expects an additional variable to be passed, so if there are 3 format parameters in a format string, there should be 3 more arguments to the function(in addition to the format string argument)

Various format parameters
======================================================
Parameter  Input Type  Output Type
______________________________________________________
%d          Value       Decimal
%u          Value       Unsigned decimal
%x          Value       Hexadecimal
%s          Pointer     String
%n          Pointer     Number of bytes written so far
______________________________________________________

Use of %n format parameter

fmt_uncommon.c
__________________________________________________________________________________
#include <stdio.h>
#include <stdlib.h>

int main() {
    int A = 5, B = 7, count_one, count_two;

    // Example of a %n format string
    printf("The number of bytes written up to this point X%n is being stored in count_one, and the number of bytes up to here X%n is being stored in count_two.\n", &count_one, &count_two);

    printf("count_one: %d\n", count_one);
    printf("count_two: %d\n", count_two);

    // Stack example
    printf("A is %d and is at %08x. B is %x.\n", A, &A, B);

    exit(0);
}
__________________________________________________________________________________

This program uses two %n format parameters in printf() statement
__________________________________________________________________________________
reader@hacking:~/booksrc $ gcc fmt_uncommon.c
reader@hacking:~/booksrc $ ./a.out
The number of bytes written up to this point X is being stored in count_one, and the number of bytes up to here X is being stored in count_two.
count_one: 46
count_two: 113
A is 5 and is at bffff7f4. B is 7.
__________________________________________________________________________________

The %n format parameter is unique in that it writes data without displaying anything, as opposed to reading and then displaying data
When a format function encounters a %n format parameter, it writes the number of bytes that have been written by the function to the address in the corresponding function argument
In fmt_uncommon, this is done in 2 places, and the unary operator is used to write this data into the variabels count_one and count_two respectively
The values are then outputted, revealing that 46 bytes are found before the first %n and 113 before the second


The stack example at the end is a convenient segue into an explanation of the stack's role with no format strings:
__________________________________________________________________________________
printf("A is %d and is at %08x. B is %x.\n", A, &A, B);
__________________________________________________________________________________

When this printf() function is called (as with many functions), the arguments are pushed to the stack in reverse order
First the value of B, then the address of A, then the value of A, and finally the address of the format string
The stack will look like this:

                 Top of the Stack
                --------------------------
                |Address of format string|
                --------------------------
                |Value of A              |
                --------------------------
                |Address of A            |
                --------------------------
                |Value of B              |
                --------------------------
                |Bottom of the Stack     |
                |/\/\/\/\/\/\/\/\/\/\/\/\|

The format function iterates through the format string one character at a time
If the character isn't the beginning of a format parameter(which is desigated by the percent sign), the character is copied to the output
If a format parameter is encountered, the appropriate action is taken, using the argument in the stack corresponding to that parameter
But what if only 2 arguments are pushed to the stack with a format string that uses 3 format paramenter?
Changing the code:
__________________________________________________________________________________
printf("A is %d and is at %08x. B is %x.\n", A, &A);
__________________________________________________________________________________

This can be done with a bit of sed magic:
__________________________________________________________________________________
reader@hacking:~/booksrc $ sed -e 's/, B)/)/' fmt_uncommon.c > fmt_uncommon2.c
reader@hacking:~/booksrc $ diff fmt_uncommon.c fmt_uncommon2.c
14c14
<
 printf("A is %d and is at %08x. B is %x.\n", A, &A, B);
---
>
 printf("A is %d and is at %08x. B is %x.\n", A, &A);
reader@hacking:~/booksrc $ gcc fmt_uncommon2.c
reader@hacking:~/booksrc $ ./a.out
The number of bytes written up to this point X is being stored in count_one, and the number of bytes up to here X is being stored in count_two.
count_one: 46
count_two: 113
A is 5 and is at bffffc24. B is b7fd6ff4.
__________________________________________________________________________________

The result is b7fd6ff4
What is b7fd6ff4? It turns out that since there wasn't a value pushed to the stack, the format function just pulled data from where the third argument should have been (by adding to the current frame pointer/EBP)
This means 0xb7fd6ff4 is the first value found below the stack frame for the format function

It is an interesting detail that should be remembered
It would be useful if there were a way to control either the number of arguments passed to or expected by a format function
Luckily, there is a fairly common programming mistake that allows for the latter