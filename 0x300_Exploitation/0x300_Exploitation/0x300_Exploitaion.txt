Program exploitation is a staple of hacking
A program is made up of complex set of rules following a certain execution flow that ultimately tells the computer what to do
Exploiting a program is simply a clever way of getting the computer to do what you want it to do, even if the currently running program was designed to prevent that action
Since a program can really only do what it's designed to do, the security holes are actually flaws or oversights in the design of the program or the environment the program is running
It takes a creative mind to find these holes and to write programs that compensate for them
Sometimes, these holes are the products of relatively obvious programming errors, but there are some less obvious errors that have given birth to more complex exploit techniques that can be applied in many different places

A program can only do what it's programmed to do, to the letter of the law
Unfortunately, what's written doesn't always coincide with what the programmer intended the program to do
Programmers are human, and sometimes what they write isn't exactly what they mean
For example, a common error is called an off-by-one error
It's an error where the programmer has miscounted by one and happens more often
If you're building a 100-foot fence, with fence posts spaced 10 feet apart, how may fence posts do you need?(10 is incorrect since you actually 11)
This type of off-by-one error is commonly called a fencepost error, and occurs when a programmer counts items instead of spaces between items, or vice versa
Another example is when a programmer is trying to select a range if numbers or items for processing, such as items N through M
If N = 5 and M = 17, how many items are there to process?(17-5 = 12 is incorrect, since there are actually M - N + 1 items for a total of 13 items)

Often fencepost errors go unnocticed because programmers aren't tested for every single possibility and the effects of a fencepost error doesn't generally occur during normal program execution
However, when the program is fed the input that makes the effects of the error manifest, the consequences of te error can have an avalanche effect on the rest of the program logic
When properly exploited, an off-by-one error can cause a seemingly secure program to become a security vulnerability

One classic example of this is OpenSSH, meant to be a secure termial communication program suite, designed to replace insecure and unencrypted services such as telnet, rsh, and rcp
However, there was an off-by-one error in the channel-allocation code that was heavily exploited
The code:

----------------------------------------------------------------------------------
if (id < 0 || id > channels_alloc)
----------------------------------------------------------------------------------

It should have been

----------------------------------------------------------------------------------
if (id < 0 || id >= channels_alloc)
----------------------------------------------------------------------------------

This simple off-by-one error allowed further exploitation of the program, so that a normal user authentication and logging in could gain full administrative rights to the system
This type of functionality certainly wasn't what the programmers had inteded for a secure program like OpenSSH, but a computer can only do what it's told

Another situation that seems to breed exploitable programmer errors is when a program is quickly modified or expand its functionality
While the increase in funcionality makes the program more marketable and increases its value, it also increases the program's complexity, which increases the chances of an oversight
Microsoft's IIS webserver program is designed to serve static and interactive content to users
In order to accomplish this, the program must allow users to read, write, and execute programs and files within certian directories; however, this functionality must be limited to those praticular directories
Without this limitaiton, users would have full control of system, which is obviously undesirable from a security perspective
To prevent this situation, the program has path-checking code designed to prevent users form using the backslash character to traverse backward through the directory tree and enter other directories

With the addition of support for the Unicode character set, though, the complexity of the program continued to increase
Unicode is a double-byte character set designed to provide characters for every language, including Chinese and Arabic
By using 2 bytes for each character instead of just 1, Unicode allows for tens of thousands of possible characters, as opposed to the few hundred allowed by single-byte characters
This additional complexity means there are now multiple representations of the backslash character, but this translation was done after the path-checking code had run
So by using %5c instead if \, it was indeed possible to traverse directories, allowing the aforementioned security dangers
Both the Sadmind worm and the CodeRed worm used this type of Unicode conversion oversight to deface web pages