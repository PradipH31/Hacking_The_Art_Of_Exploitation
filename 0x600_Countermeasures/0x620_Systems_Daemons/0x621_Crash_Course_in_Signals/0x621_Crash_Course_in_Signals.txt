Signals provide a method of interprocess communication in Unix
When a process receives a signal, its flow of execution is interrupted by the operating system to a signal handler
Signals are identified by a number, and each one has a default signal handler
For example, when CTRL-C is typed in a program's controlling terminal, an interrupt signal is sent, which has default signal handler that exits the program
This allows the program to be interrupted, even if it is stuck in an infinite loop

Custom signal handlers can be registered using the signal() function
In the example code below, several signal handlers are registered for certain signals, whereas the main code contains an infinite loop

signal_example.c
__________________________________________________________________________________
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
/* some labeled signal defines from signal.h 
 * #define SIGHUP        1  hangup 
 * #define SIGINT        2  interrupt  (Ctrl-C) 
 * #define SIGQUIT       3  quit (Ctrl-\) 
 * #define SIGILL        4  illegal instruction 
 * #define SIGTRAP       5  trace/breakpoint trap 
 * #define SIGABRT       6  process aborted 
 * #define SIGBUS        7  bus error 
 * #define SIGFPE        8  floating point error 
 * #define SIGKILL       9  kill 
 * #define SIGUSR1      10  user defined signal 1 
 * #define SIGSEGV      11  segmentation fault 
 * #define SIGUSR2      12  user defined signal 2 
 * #define SIGPIPE      13  write to pipe with no one reading 
 * #define SIGALRM      14  countdown alarm set by alarm() 
 * #define SIGTERM      15  termination (sent by kill command) 
 * #define SIGCHLD      17  child process signal 
 * #define SIGCONT      18  continue if stopped 
 * #define SIGSTOP      19  stop (pause execution) 
 * #define SIGTSTP      20  terminal stop [suspend] (Ctrl-Z) 
 * #define SIGTTIN      21  background process trying to read stdin 
 * #define SIGTTOU      22  background process trying to read stdout 
 */ 

/* A signal handler */
void signal_handler(int signal) {
   printf("Caught signal %d\t", signal);
   if (signal == SIGTSTP)
      printf("SIGTSTP (Ctrl-Z)");
   else if (signal == SIGQUIT)
      printf("SIGQUIT (Ctrl-\\)");
   else if (signal == SIGUSR1)
      printf("SIGUSR1");
   else if (signal == SIGUSR2)
      printf("SIGUSR2");
   
   printf("\n");
}

void sigint_handler(int x) {
   printf("Caught a Ctrl-C (SIGINT) in a separate handler\nExiting.\n");
   exit(0);
}

int main() {
   /* Registering signal handlers */
   signal(SIGQUIT, signal_handler); // Set signal_handler() as the
   signal(SIGTSTP, signal_handler); // signal handler for these
   signal(SIGUSR1, signal_handler); // signals
   signal(SIGUSR2, signal_handler);

   signal(SIGINT, sigint_handler); // Set sigint_handler() for SIGINT

   while(1) {} // Loop forever
}
__________________________________________________________________________________

When this program is compiled and executed, signal handlers are registered, and the program enters an infinite loop
Even though the program is stuck looping, incoming signals will interrupt execution and call the registered signal handlers
In the output below, signals that can be triggered from the controlling terminal are used
The signal_handler() function, when finished, returns execution back into the interrupted loop, whereas the sigint_handler() function exits the program
__________________________________________________________________________________
reader@hacking:~/booksrc $ gcc -o signal_example signal_example.c
reader@hacking:~/booksrc $ ./signal_example
Caught signal 20        SIGTSTP (Ctrl-Z)
Caught signal 3 SIGQUIT (Ctrl-\)
Caught a Ctrl-C (SIGINT) in a separate handler
Exiting.
__________________________________________________________________________________

Specific signals can be sent to a process using the kill command
By default, the kill command sends the terminate signal (SIGTERM) to a process
With the -l command-line switch, kill lists all the possible signals
In the output below, the SIGUSR1 and SIGUSR2 signals are sent to the signal_example program being executed in another terminal

__________________________________________________________________________________
reader@hacking:~/booksrc $ kill -l
1) SIGHUP        2) SIGINT       3) SIGQUIT      4) SIGILL
5) SIGTRAP       6) SIGABRT      7) SIGBUS       8) SIGFPE
9) SIGKILL      10) SIGUSR1     11) SIGSEGV     12) SIGUSR2
13) SIGPIPE     14) SIGALRM     15) SIGTERM     16) SIGSTKFLT
17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU
25) SIGXFSZ     26) SIGVTALRM   27) SIGPROF     28) SIGWINCH
29) SIGIO       30) SIGPWR      31) SIGSYS      34) SIGRTMIN
35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3  38) SIGRTMIN+4
39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12
47) SIGRTMIN+13 48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14
51) SIGRTMAX-13 52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10
55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7  58) SIGRTMAX-6
59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
63) SIGRTMAX-1  64) SIGRTMAX

reader@hacking:~/booksrc $ ps a | grep signal_example
24491 pts/3    R+     0:17 ./signal_example
24512 pts/1    S+     0:00 grep signal_example

reader@hacking:~/booksrc $ kill -10 24491
reader@hacking:~/booksrc $ kill -12 24491
reader@hacking:~/booksrc $ kill -9 24491
__________________________________________________________________________________

Finally, the SIGKILL signal is sent using kill -9
This signal's handler cannot be changed, so kill -9 can always be used to kill processes
In the other terminal, the running signal_example shows the signals as they are caught and the process is killed

__________________________________________________________________________________
reader@hacking:~/booksrc $ ./signal_example
Caught signal 10        SIGUSR1
Caught signal 12        SIGUSR2
Killed
__________________________________________________________________________________

Signals themselves are very simple; however, interprocess communication can quickly become a complex web of dependencies
Fortunately, in the new tinyweb daemon, signals are only used for clean termination, so the implementation is simple