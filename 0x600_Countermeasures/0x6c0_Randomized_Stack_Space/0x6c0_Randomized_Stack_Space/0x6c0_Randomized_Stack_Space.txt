Another protective countermeasure tries a slightly different approach
Instead of preventing execution on the stack, this countermeasure randomizes the stack memory layout
When the memory layout is randomized, the attacker won't be able to return execution into waiting shellcode, since he won't know where it is

The countermeasure has been enabled by default in the Linux kernel since 2.6.12 but this book's LiveCD has been configured with it turned off
TO turn this protection on again, echo 1 to the /proc filesystem:
__________________________________________________________________________________
reader@hacking:~/booksrc $ sudo su -
root@hacking:~ # echo 1 > /proc/sys/kernel/randomize_va_space

root@hacking:~ # exit
logout

reader@hacking:~/booksrc $ gcc exploit_notesearch.c
reader@hacking:~/booksrc $ ./a.out
[DEBUG] found a 34 byte note for user id 999
[DEBUG] found a 41 byte note for user id 999
-------[ end of note data ]-------
__________________________________________________________________________________

With this countermeasure turned on, the notesearch exploit no longer works, since the layout of the stack is randomized
Every time a program starts, the stack begins at a random location
The following example demonstrates this

aslr_demo.c
__________________________________________________________________________________
#include <stdio.h>

int main(int argc, char *argv[]) {
   char buffer[50];

   printf("buffer is at %p\n", &buffer);

   if(argc > 1)
      strcpy(buffer, argv[1]);

   return 1;
}
__________________________________________________________________________________

The program has an obvious buffer overflow vulnerability in it
However, with ASLR turned on, exploitation isn't that easy

__________________________________________________________________________________
reader@hacking:~/booksrc $ gcc -g -o aslr_demo aslr_demo.c

reader@hacking:~/booksrc $ ./aslr_demo
buffer is at 0xbffbbf90
reader@hacking:~/booksrc $ ./aslr_demo
buffer is at 0xbfe4de20
reader@hacking:~/booksrc $ ./aslr_demo
buffer is at 0xbfc7ac50

reader@hacking:~/booksrc $ ./aslr_demo $(perl -e 'print "ABCD"x20')
buffer is at 0xbf9a4920
Segmentation fault
__________________________________________________________________________________

Notice how the location of the buffer on the stack changes with every run
We can still inject the shellcode and corrupt memory to overwrite the return address, but we don't know where the shellcode is in memory
The randomization changes the location of everything on the stack, including environment variables

__________________________________________________________________________________
reader@hacking:~/booksrc $ export SHELLCODE=$(cat shellcode.bin)

reader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./aslr_demo
SHELLCODE will be at 0xbfd919c3
reader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./aslr_demo
SHELLCODE will be at 0xbfe499c3
reader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./aslr_demo
SHELLCODE will be at 0xbfcae9c3
__________________________________________________________________________________

This type of protection can be very effective in stopping exploits by average attacker, but it isn't always enough to stop a determined hacker
Can you think of a way to successfully exploit this program under these conditions?