In fact, I had written this chapter before linux-gate was fixed in the Linux kernel, so I had to hack together an ASLR bypass
My first thought was to leverage the execl() family of functions
We've been using the execve() function in our shellcode to spawn a shell, and if you pay close attention (or just read the man page), you'll notice the execve() function replaces the currently running process with the new process image

______________________________________________________________________
EXEC(3)               Linux Programmer's Manual                EXEC(3)

NAME
       execl, execlp, execle, execv, execvp - execute a file

SYNOPSIS
       #include<unistd.h>
       
       extern char **environ;
       
       int execl(const char *path, const char *arg, ...);
       int execlp(const char *file, const char *arg, ...);
       int execle(const char *path, const char *arg,
                  ..., char * const envp[]);
       int execv(const char *path, char *const argv[]);
       int execvp(const char *file, char *const argv[]);

DESCRIPTION
       The exec() family of functions replaces the current process
       image with a new process image. The functions described in this
       manual page are front-ends for the function execve(2). (See the
       manual page for execve() for detailed information about the
       replacement of the current process.)
______________________________________________________________________

It seems like there could be a weakness here if the memory layout is randomized only when the process is started
Let's test this hypothesis with a piece of code that prints the address of a stack variable and then executes aslr_demo using an execl() function

aslr_execl.c
__________________________________________________________________________________
#include <stdio.h>
#include <unistd.h>

int main(int argc, char *argv[]) {
   int stack_var;

   // Print an address from the current stack frame
   printf("stack_var is at %p\n", &stack_var);

   // Start aslr_demo to see how its stack is arranged
   execl("./aslr_demo", "aslr_demo", NULL);
}
__________________________________________________________________________________

When this program is compiled and executed, it will execl() aslr_demo, which also prints the address of a stack variable (buffer)
This lets us compare the memory layouts

__________________________________________________________________________________
reader@hacking:~/booksrc $ gcc -o aslr_demo aslr_demo.c
reader@hacking:~/booksrc $ gcc -o aslr_execl aslr_execl.c

reader@hacking:~/booksrc $ ./aslr_demo test
buffer is at 0xbf9f31c0
reader@hacking:~/booksrc $ ./aslr_demo test
buffer is at 0xbffaaf70

reader@hacking:~/booksrc $ ./aslr_execl
stack_var is at 0xbf832044
buffer is at 0xbf832000

reader@hacking:~/booksrc $ gdb -q --batch -ex "p 0xbf832044 - 0xbf832000"
$1 = 68

reader@hacking:~/booksrc $ ./aslr_execl
stack_var is at 0xbfa97844
buffer is at 0xbf82f800
reader@hacking:~/booksrc $ gdb -q --batch -ex "p 0xbfa97844 - 0xbf82f800"
$1 = 2523204

reader@hacking:~/booksrc $ ./aslr_execl
stack_var is at 0xbfbb0bc4
buffer is at 0xbff3e710
reader@hacking:~/booksrc $ gdb -q --batch -ex "p 0xbfbb0bc4 - 0xbff3e710"
$1 = 4291241140

reader@hacking:~/booksrc $ ./aslr_execl
stack_var is at 0xbf9a81b4
buffer is at 0xbf9a8180
reader@hacking:~/booksrc $ gdb -q --batch -ex "p 0xbf9a81b4 - 0xbf9a8180"
$1 = 52
__________________________________________________________________________________

The first result looks promising, but further attempts show that there is some degree of randomization happening when the new process is executed with execl()
I'm sure this wasn't always the case, but the progress of open source is rather constant
This isn't much of a problem though, since we have ways to deal with that partial uncertainty